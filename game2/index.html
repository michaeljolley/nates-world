<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAR SHIPS 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        h1 {
            color: #fff;
            text-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff;
            margin: 20px 0;
            font-size: 2.5em;
            letter-spacing: 8px;
        }
        #scoreboard {
            display: flex;
            gap: 50px;
            margin: 10px 0;
            font-size: 1.5em;
        }
        .score {
            padding: 10px 30px;
            border-radius: 10px;
            font-weight: bold;
        }
        .red-score {
            background: rgba(255, 50, 50, 0.3);
            color: #ff5555;
            border: 2px solid #ff5555;
        }
        .blue-score {
            background: rgba(50, 150, 255, 0.3);
            color: #5599ff;
            border: 2px solid #5599ff;
        }
        #money-display {
            position: relative;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffd700;
            font-size: 1.5em;
            font-weight: bold;
            margin: 10px auto;
        }
        #shop-btn, #quests-btn {
            background: linear-gradient(180deg, #ff9900, #cc6600);
            border: 2px solid #ffaa00;
            padding: 8px 20px;
            font-size: 1em;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
        }
        #quests-btn {
            background: linear-gradient(180deg, #00d4ff, #0088aa);
            border-color: #00d4ff;
        }
        #shop-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #ff9900;
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            z-index: 2000;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #shop-panel h2 {
            color: #ff9900;
            text-align: center;
            margin-bottom: 10px;
        }
        .shop-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .shop-tab {
            background: rgba(255,255,255,0.1);
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            color: #aaa;
        }
        .shop-tab.active {
            background: #ff9900;
            border-color: #ff9900;
            color: #000;
        }
        .ship-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        .ship-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }
        .ship-card.owned {
            border-color: #00ff66;
            background: rgba(0,255,100,0.1);
        }
        .ship-card.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 15px #00d4ff;
        }
        .ship-card .ship-name {
            font-weight: bold;
            color: #fff;
            font-size: 1.1em;
        }
        .ship-card .ship-price {
            color: #ffd700;
            margin: 5px 0;
        }
        .ship-card .ship-stats {
            font-size: 0.8em;
            color: #aaa;
            text-align: left;
        }
        .ship-card .buff {
            color: #00ff66;
        }
        .ship-card .debuff {
            color: #ff4444;
        }
        .ship-card button {
            margin-top: 8px;
            padding: 5px 15px;
            font-size: 0.9em;
        }
        .close-shop {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            cursor: pointer;
            color: #ff4444;
        }
        .current-ship {
            text-align: center;
            color: #00d4ff;
            margin: 10px 0;
            font-size: 1.1em;
        }
        #quest-panel {
            display: none;
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            font-size: 0.9em;
            min-width: 280px;
            max-width: 320px;
            margin: 10px auto;
            max-height: 300px;
            overflow-y: auto;
        }
        #quest-panel h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #00d4ff;
            padding-bottom: 5px;
        }
        .quest-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 8px;
        }
        .quest-item.completed {
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #00ff66;
        }
        .quest-name {
            font-weight: bold;
            color: #fff;
        }
        .quest-progress {
            color: #aaa;
            font-size: 0.85em;
            margin-top: 3px;
        }
        .quest-reward {
            color: #ffd700;
            font-size: 0.85em;
            margin-top: 3px;
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        #controls {
            margin-top: 10px;
            pointer-events: auto;
        }
        button {
            background: linear-gradient(180deg, #00d4ff, #0088aa);
            border: none;
            padding: 10px 25px;
            font-size: 1em;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.7);
        }
        #info {
            color: #aaa;
            font-size: 0.9em;
            margin-top: 5px;
        }
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #0a1628 0%, #1a3a5c 50%, #0d2840 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #homeScreen h1 {
            font-size: 4em;
            color: #fff;
            text-shadow: 0 0 30px #00d4ff, 0 0 60px #00d4ff, 0 0 90px #0088ff;
            margin-bottom: 20px;
            letter-spacing: 12px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 30px #00d4ff, 0 0 60px #00d4ff; }
            to { text-shadow: 0 0 40px #00ffff, 0 0 80px #00ffff, 0 0 120px #0088ff; }
        }
        #homeScreen .subtitle {
            font-size: 1.5em;
            color: #88ccff;
            margin-bottom: 50px;
            letter-spacing: 4px;
        }
        #homeScreen .menu-btn {
            background: linear-gradient(180deg, #00d4ff, #0066aa);
            border: 2px solid #00ffff;
            padding: 20px 60px;
            font-size: 1.5em;
            color: #fff;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        #homeScreen .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.8);
            background: linear-gradient(180deg, #00ffff, #0088cc);
        }
        #homeScreen .menu-btn.secondary {
            background: transparent;
            border: 2px solid #5599ff;
            padding: 12px 40px;
            font-size: 1em;
        }
        #homeScreen .menu-btn.secondary:hover {
            background: rgba(85, 153, 255, 0.2);
            box-shadow: 0 0 20px rgba(85, 153, 255, 0.5);
        }
        #homeScreen .ship-silhouette {
            font-size: 8em;
            margin-bottom: 30px;
            filter: drop-shadow(0 0 20px #00d4ff);
        }
        #homeScreen .controls-info {
            position: absolute;
            bottom: 40px;
            color: #668899;
            font-size: 0.9em;
            text-align: center;
        }
        #homeScreen .controls-info span {
            color: #00d4ff;
            font-weight: bold;
        }
        #homeScreen .version {
            position: absolute;
            bottom: 15px;
            right: 20px;
            color: #445566;
            font-size: 0.8em;
        }
        #homeScreen .difficulty-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        #homeScreen .difficulty-label {
            color: #88ccff;
            font-size: 1.1em;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        #homeScreen .difficulty-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #homeScreen .diff-btn {
            background: rgba(0, 100, 150, 0.3);
            border: 2px solid #446688;
            padding: 10px 20px;
            font-size: 0.9em;
            color: #88aacc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        #homeScreen .diff-btn:hover {
            background: rgba(0, 150, 200, 0.4);
            border-color: #00d4ff;
            color: #fff;
        }
        #homeScreen .diff-btn.selected {
            background: linear-gradient(180deg, #00d4ff, #0066aa);
            border-color: #00ffff;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }
        #homeScreen .diff-btn.easy { border-color: #44aa44; }
        #homeScreen .diff-btn.easy.selected { background: linear-gradient(180deg, #44dd44, #228822); border-color: #66ff66; }
        #homeScreen .diff-btn.medium { border-color: #aaaa44; }
        #homeScreen .diff-btn.medium.selected { background: linear-gradient(180deg, #dddd44, #888822); border-color: #ffff66; }
        #homeScreen .diff-btn.hard { border-color: #dd8844; }
        #homeScreen .diff-btn.hard.selected { background: linear-gradient(180deg, #ff8844, #884422); border-color: #ffaa66; }
        #homeScreen .diff-btn.extreme { border-color: #dd4444; }
        #homeScreen .diff-btn.extreme.selected { background: linear-gradient(180deg, #ff4444, #882222); border-color: #ff6666; }
        #homeScreen .diff-btn.nightmare { border-color: #aa44aa; }
        #homeScreen .diff-btn.nightmare.selected { background: linear-gradient(180deg, #dd44dd, #662266); border-color: #ff66ff; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>‚öì WAR SHIPS ‚öì</h1>
        <div id="scoreboard">
            <div class="score red-score">üî¥ RED: <span id="redScore">0</span></div>
            <div class="score blue-score">üîµ BLUE: <span id="blueScore">0</span></div>
        </div>
        <div id="controls">
            <button onclick="resetGame()">üîÑ RESTART</button>
            <button onclick="togglePause()">‚è∏Ô∏è PAUSE</button>
        </div>
        <div id="info">W/S throttle | A/D or Q/E to steer | SPACE to fire | Your ship has GREEN lights</div>
    </div>
    
    <div id="homeScreen">
        <div class="ship-silhouette">üö¢</div>
        <h1>‚öì WAR SHIPS ‚öì</h1>
        <div class="subtitle">NAVAL COMBAT SIMULATOR</div>
        
        <div id="money-display">üí∞ $<span id="money">0</span></div>
        
        <div class="current-ship">Current Ship: <span id="current-ship-name">Starter Vessel</span></div>
        
        <div>
            <button id="shop-btn" onclick="toggleShop()">üö¢ SHIP SHOP</button>
            <button id="quests-btn" onclick="toggleQuests()">üìú QUESTS</button>
        </div>
        
        <div id="quest-panel">
            <h3>üìú QUESTS</h3>
            <div id="quest-list"></div>
        </div>
        
        <div class="difficulty-container">
            <div class="difficulty-label">SELECT DIFFICULTY</div>
            <div class="difficulty-buttons">
                <button class="diff-btn easy" onclick="setDifficulty(1)">EASY</button>
                <button class="diff-btn medium selected" onclick="setDifficulty(2)">MEDIUM</button>
                <button class="diff-btn hard" onclick="setDifficulty(3)">HARD</button>
                <button class="diff-btn extreme" onclick="setDifficulty(4)">EXTREME</button>
                <button class="diff-btn nightmare" onclick="setDifficulty(5)">NIGHTMARE</button>
            </div>
        </div>
        <button class="menu-btn" onclick="startGame()">‚ñ∂ START BATTLE</button>
        <button class="menu-btn secondary" onclick="showControls()">‚å® CONTROLS</button>
        <div class="controls-info">
            <span>W/S</span> Throttle &nbsp;|&nbsp; 
            <span>A/D</span> Steer &nbsp;|&nbsp; 
            <span>SPACE</span> Fire Main Guns
        </div>
        <div class="version">v1.0</div>
    </div>
    
    <div id="shop-panel">
        <span class="close-shop" onclick="toggleShop()">‚úï</span>
        <h2>üö¢ SHIP SHOP</h2>
        <div class="shop-tabs">
            <button class="shop-tab active" onclick="showShopCategory('all')">All</button>
            <button class="shop-tab" onclick="showShopCategory('speed')">Speed</button>
            <button class="shop-tab" onclick="showShopCategory('tank')">Tank</button>
            <button class="shop-tab" onclick="showShopCategory('damage')">Damage</button>
            <button class="shop-tab" onclick="showShopCategory('balanced')">Balanced</button>
            <button class="shop-tab" onclick="showShopCategory('special')">Special</button>
        </div>
        <div id="ship-grid" class="ship-grid"></div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, water, sun, sky;
        let ships = [];
        let bullets = [];
        let explosions = [];
        let wakes = [];
        let redScore = 0;
        let blueScore = 0;
        let paused = true;
        let difficulty = 2; // 1=Easy, 2=Medium, 3=Hard, 4=Extreme, 5=Nightmare
        let keys = {};
        let playerShip = null;
        let clock = new THREE.Clock();
        const WORLD_SIZE = 400;
        
        // Money and Quest System - persistent with localStorage
        let money = parseInt(localStorage.getItem('warships_money') || '0');
        let totalMoneyEarned = parseInt(localStorage.getItem('warships_totalEarned') || '0');
        let quests = [];
        
        // Load persistent stats from localStorage
        let questStats = JSON.parse(localStorage.getItem('warships_stats') || '{}');
        questStats = {
            kills: questStats.kills || 0,
            shotsFired: questStats.shotsFired || 0,
            shotsHit: questStats.shotsHit || 0,
            damageDealt: questStats.damageDealt || 0,
            survived: questStats.survived || 0,
            gamesPlayed: questStats.gamesPlayed || 0,
            moneyEarned: totalMoneyEarned
        };
        
        const questTemplates = [
            // Kill quests (15)
            { id: 'kill1', name: 'First Blood', desc: 'Destroy 1 enemy ship', type: 'kills', target: 1, reward: 100 },
            { id: 'kill3', name: 'Triple Threat', desc: 'Destroy 3 enemy ships', type: 'kills', target: 3, reward: 300 },
            { id: 'kill5', name: 'Ace Captain', desc: 'Destroy 5 enemy ships', type: 'kills', target: 5, reward: 500 },
            { id: 'kill10', name: 'Fleet Destroyer', desc: 'Destroy 10 enemy ships', type: 'kills', target: 10, reward: 1000 },
            { id: 'kill15', name: 'Naval Terror', desc: 'Destroy 15 enemy ships', type: 'kills', target: 15, reward: 1500 },
            { id: 'kill25', name: 'Sea Wolf', desc: 'Destroy 25 enemy ships', type: 'kills', target: 25, reward: 2500 },
            { id: 'kill50', name: 'Admiral of Death', desc: 'Destroy 50 enemy ships', type: 'kills', target: 50, reward: 5000 },
            { id: 'kill75', name: 'Ocean Reaper', desc: 'Destroy 75 enemy ships', type: 'kills', target: 75, reward: 7500 },
            { id: 'kill100', name: 'Legendary Captain', desc: 'Destroy 100 enemy ships', type: 'kills', target: 100, reward: 10000 },
            { id: 'kill150', name: 'Fleet Annihilator', desc: 'Destroy 150 enemy ships', type: 'kills', target: 150, reward: 15000 },
            { id: 'kill200', name: 'Dreadnought', desc: 'Destroy 200 enemy ships', type: 'kills', target: 200, reward: 20000 },
            { id: 'kill300', name: 'Kraken', desc: 'Destroy 300 enemy ships', type: 'kills', target: 300, reward: 30000 },
            { id: 'kill500', name: 'Poseidon\'s Wrath', desc: 'Destroy 500 enemy ships', type: 'kills', target: 500, reward: 50000 },
            { id: 'kill750', name: 'God of War', desc: 'Destroy 750 enemy ships', type: 'kills', target: 750, reward: 75000 },
            { id: 'kill1000', name: 'Immortal Admiral', desc: 'Destroy 1000 enemy ships', type: 'kills', target: 1000, reward: 100000 },
            
            // Shots fired quests (15)
            { id: 'shots10', name: 'Trigger Happy', desc: 'Fire 10 shots', type: 'shotsFired', target: 10, reward: 50 },
            { id: 'shots50', name: 'Artillery Barrage', desc: 'Fire 50 shots', type: 'shotsFired', target: 50, reward: 200 },
            { id: 'shots100', name: 'Gunner', desc: 'Fire 100 shots', type: 'shotsFired', target: 100, reward: 400 },
            { id: 'shots250', name: 'Heavy Artillery', desc: 'Fire 250 shots', type: 'shotsFired', target: 250, reward: 800 },
            { id: 'shots500', name: 'Bombardment', desc: 'Fire 500 shots', type: 'shotsFired', target: 500, reward: 1500 },
            { id: 'shots1000', name: 'Shell Storm', desc: 'Fire 1000 shots', type: 'shotsFired', target: 1000, reward: 3000 },
            { id: 'shots2000', name: 'Endless Barrage', desc: 'Fire 2000 shots', type: 'shotsFired', target: 2000, reward: 5000 },
            { id: 'shots3500', name: 'Lead Rain', desc: 'Fire 3500 shots', type: 'shotsFired', target: 3500, reward: 8000 },
            { id: 'shots5000', name: 'Arsenal Master', desc: 'Fire 5000 shots', type: 'shotsFired', target: 5000, reward: 12000 },
            { id: 'shots7500', name: 'Cannon King', desc: 'Fire 7500 shots', type: 'shotsFired', target: 7500, reward: 18000 },
            { id: 'shots10000', name: 'Thunder God', desc: 'Fire 10000 shots', type: 'shotsFired', target: 10000, reward: 25000 },
            { id: 'shots15000', name: 'Infinite Ammo', desc: 'Fire 15000 shots', type: 'shotsFired', target: 15000, reward: 35000 },
            { id: 'shots20000', name: 'Bullet Hell', desc: 'Fire 20000 shots', type: 'shotsFired', target: 20000, reward: 50000 },
            { id: 'shots30000', name: 'Apocalypse', desc: 'Fire 30000 shots', type: 'shotsFired', target: 30000, reward: 75000 },
            { id: 'shots50000', name: 'Armageddon', desc: 'Fire 50000 shots', type: 'shotsFired', target: 50000, reward: 100000 },
            
            // Accuracy quests (15)
            { id: 'hit5', name: 'Sharpshooter', desc: 'Hit enemies 5 times', type: 'shotsHit', target: 5, reward: 150 },
            { id: 'hit20', name: 'Master Gunner', desc: 'Hit enemies 20 times', type: 'shotsHit', target: 20, reward: 400 },
            { id: 'hit50', name: 'Sniper', desc: 'Hit enemies 50 times', type: 'shotsHit', target: 50, reward: 800 },
            { id: 'hit100', name: 'Deadshot', desc: 'Hit enemies 100 times', type: 'shotsHit', target: 100, reward: 1500 },
            { id: 'hit200', name: 'Eagle Eye', desc: 'Hit enemies 200 times', type: 'shotsHit', target: 200, reward: 2500 },
            { id: 'hit350', name: 'Precision Master', desc: 'Hit enemies 350 times', type: 'shotsHit', target: 350, reward: 4000 },
            { id: 'hit500', name: 'Perfect Aim', desc: 'Hit enemies 500 times', type: 'shotsHit', target: 500, reward: 6000 },
            { id: 'hit750', name: 'Bullseye', desc: 'Hit enemies 750 times', type: 'shotsHit', target: 750, reward: 9000 },
            { id: 'hit1000', name: 'Hawkeye', desc: 'Hit enemies 1000 times', type: 'shotsHit', target: 1000, reward: 12000 },
            { id: 'hit1500', name: 'Marksman Elite', desc: 'Hit enemies 1500 times', type: 'shotsHit', target: 1500, reward: 18000 },
            { id: 'hit2000', name: 'Legendary Aim', desc: 'Hit enemies 2000 times', type: 'shotsHit', target: 2000, reward: 25000 },
            { id: 'hit3000', name: 'Aimbot', desc: 'Hit enemies 3000 times', type: 'shotsHit', target: 3000, reward: 35000 },
            { id: 'hit5000', name: 'Inhuman Accuracy', desc: 'Hit enemies 5000 times', type: 'shotsHit', target: 5000, reward: 50000 },
            { id: 'hit7500', name: 'Godlike Precision', desc: 'Hit enemies 7500 times', type: 'shotsHit', target: 7500, reward: 75000 },
            { id: 'hit10000', name: 'Omniscient Gunner', desc: 'Hit enemies 10000 times', type: 'shotsHit', target: 10000, reward: 100000 },
            
            // Damage quests (15)
            { id: 'damage500', name: 'Heavy Hitter', desc: 'Deal 500 damage', type: 'damageDealt', target: 500, reward: 250 },
            { id: 'damage1000', name: 'Pain Dealer', desc: 'Deal 1000 damage', type: 'damageDealt', target: 1000, reward: 500 },
            { id: 'damage2500', name: 'Hull Breaker', desc: 'Deal 2500 damage', type: 'damageDealt', target: 2500, reward: 1000 },
            { id: 'damage5000', name: 'Destroyer', desc: 'Deal 5000 damage', type: 'damageDealt', target: 5000, reward: 2000 },
            { id: 'damage10000', name: 'Devastator', desc: 'Deal 10000 damage', type: 'damageDealt', target: 10000, reward: 4000 },
            { id: 'damage20000', name: 'Annihilator', desc: 'Deal 20000 damage', type: 'damageDealt', target: 20000, reward: 7000 },
            { id: 'damage35000', name: 'Obliterator', desc: 'Deal 35000 damage', type: 'damageDealt', target: 35000, reward: 11000 },
            { id: 'damage50000', name: 'Decimator', desc: 'Deal 50000 damage', type: 'damageDealt', target: 50000, reward: 16000 },
            { id: 'damage75000', name: 'Eradicator', desc: 'Deal 75000 damage', type: 'damageDealt', target: 75000, reward: 22000 },
            { id: 'damage100000', name: 'Exterminator', desc: 'Deal 100000 damage', type: 'damageDealt', target: 100000, reward: 30000 },
            { id: 'damage150000', name: 'Cataclysm', desc: 'Deal 150000 damage', type: 'damageDealt', target: 150000, reward: 40000 },
            { id: 'damage200000', name: 'Ragnarok', desc: 'Deal 200000 damage', type: 'damageDealt', target: 200000, reward: 55000 },
            { id: 'damage300000', name: 'Apocalypse Bringer', desc: 'Deal 300000 damage', type: 'damageDealt', target: 300000, reward: 75000 },
            { id: 'damage500000', name: 'World Ender', desc: 'Deal 500000 damage', type: 'damageDealt', target: 500000, reward: 100000 },
            { id: 'damage1000000', name: 'Universe Destroyer', desc: 'Deal 1000000 damage', type: 'damageDealt', target: 1000000, reward: 200000 },
            
            // Survival quests (15)
            { id: 'survive1', name: 'Survivor', desc: 'Win 1 battle', type: 'survived', target: 1, reward: 500 },
            { id: 'survive3', name: 'Victor', desc: 'Win 3 battles', type: 'survived', target: 3, reward: 1200 },
            { id: 'survive5', name: 'Champion', desc: 'Win 5 battles', type: 'survived', target: 5, reward: 2000 },
            { id: 'survive10', name: 'Veteran', desc: 'Win 10 battles', type: 'survived', target: 10, reward: 4000 },
            { id: 'survive15', name: 'War Hero', desc: 'Win 15 battles', type: 'survived', target: 15, reward: 6000 },
            { id: 'survive25', name: 'Battle Master', desc: 'Win 25 battles', type: 'survived', target: 25, reward: 10000 },
            { id: 'survive40', name: 'Unbreakable', desc: 'Win 40 battles', type: 'survived', target: 40, reward: 15000 },
            { id: 'survive60', name: 'Invincible', desc: 'Win 60 battles', type: 'survived', target: 60, reward: 22000 },
            { id: 'survive80', name: 'Unstoppable', desc: 'Win 80 battles', type: 'survived', target: 80, reward: 30000 },
            { id: 'survive100', name: 'Legendary Victor', desc: 'Win 100 battles', type: 'survived', target: 100, reward: 40000 },
            { id: 'survive150', name: 'Eternal Champion', desc: 'Win 150 battles', type: 'survived', target: 150, reward: 55000 },
            { id: 'survive200', name: 'Mythic Admiral', desc: 'Win 200 battles', type: 'survived', target: 200, reward: 75000 },
            { id: 'survive300', name: 'Godlike Captain', desc: 'Win 300 battles', type: 'survived', target: 300, reward: 100000 },
            { id: 'survive500', name: 'Immortal Legend', desc: 'Win 500 battles', type: 'survived', target: 500, reward: 150000 },
            { id: 'survive1000', name: 'Eternal God', desc: 'Win 1000 battles', type: 'survived', target: 1000, reward: 300000 },
            
            // Games played quests (15)
            { id: 'games1', name: 'Rookie', desc: 'Play 1 game', type: 'gamesPlayed', target: 1, reward: 50 },
            { id: 'games5', name: 'Enlisted', desc: 'Play 5 games', type: 'gamesPlayed', target: 5, reward: 200 },
            { id: 'games10', name: 'Sailor', desc: 'Play 10 games', type: 'gamesPlayed', target: 10, reward: 400 },
            { id: 'games25', name: 'Seaman', desc: 'Play 25 games', type: 'gamesPlayed', target: 25, reward: 800 },
            { id: 'games50', name: 'Officer', desc: 'Play 50 games', type: 'gamesPlayed', target: 50, reward: 1500 },
            { id: 'games75', name: 'Lieutenant', desc: 'Play 75 games', type: 'gamesPlayed', target: 75, reward: 2500 },
            { id: 'games100', name: 'Commander', desc: 'Play 100 games', type: 'gamesPlayed', target: 100, reward: 4000 },
            { id: 'games150', name: 'Captain', desc: 'Play 150 games', type: 'gamesPlayed', target: 150, reward: 6000 },
            { id: 'games200', name: 'Rear Admiral', desc: 'Play 200 games', type: 'gamesPlayed', target: 200, reward: 8000 },
            { id: 'games300', name: 'Vice Admiral', desc: 'Play 300 games', type: 'gamesPlayed', target: 300, reward: 12000 },
            { id: 'games400', name: 'Admiral', desc: 'Play 400 games', type: 'gamesPlayed', target: 400, reward: 16000 },
            { id: 'games500', name: 'Fleet Admiral', desc: 'Play 500 games', type: 'gamesPlayed', target: 500, reward: 22000 },
            { id: 'games750', name: 'Grand Admiral', desc: 'Play 750 games', type: 'gamesPlayed', target: 750, reward: 35000 },
            { id: 'games1000', name: 'Supreme Admiral', desc: 'Play 1000 games', type: 'gamesPlayed', target: 1000, reward: 50000 },
            { id: 'games2000', name: 'Eternal Mariner', desc: 'Play 2000 games', type: 'gamesPlayed', target: 2000, reward: 100000 },
            
            // Money earned quests (14)
            { id: 'earn1000', name: 'Penny Pincher', desc: 'Earn $1,000 total', type: 'moneyEarned', target: 1000, reward: 200 },
            { id: 'earn5000', name: 'Coin Collector', desc: 'Earn $5,000 total', type: 'moneyEarned', target: 5000, reward: 500 },
            { id: 'earn10000', name: 'Wealthy Sailor', desc: 'Earn $10,000 total', type: 'moneyEarned', target: 10000, reward: 1000 },
            { id: 'earn25000', name: 'Rich Captain', desc: 'Earn $25,000 total', type: 'moneyEarned', target: 25000, reward: 2500 },
            { id: 'earn50000', name: 'Treasure Hunter', desc: 'Earn $50,000 total', type: 'moneyEarned', target: 50000, reward: 5000 },
            { id: 'earn100000', name: 'Fortune Seeker', desc: 'Earn $100,000 total', type: 'moneyEarned', target: 100000, reward: 10000 },
            { id: 'earn250000', name: 'Wealthy Admiral', desc: 'Earn $250,000 total', type: 'moneyEarned', target: 250000, reward: 25000 },
            { id: 'earn500000', name: 'Naval Tycoon', desc: 'Earn $500,000 total', type: 'moneyEarned', target: 500000, reward: 50000 },
            { id: 'earn1000000', name: 'Millionaire', desc: 'Earn $1,000,000 total', type: 'moneyEarned', target: 1000000, reward: 100000 },
            { id: 'earn2500000', name: 'Multi-Millionaire', desc: 'Earn $2,500,000 total', type: 'moneyEarned', target: 2500000, reward: 200000 },
            { id: 'earn5000000', name: 'Billionaire', desc: 'Earn $5,000,000 total', type: 'moneyEarned', target: 5000000, reward: 400000 },
            { id: 'earn10000000', name: 'Naval Empire', desc: 'Earn $10,000,000 total', type: 'moneyEarned', target: 10000000, reward: 750000 },
            { id: 'earn25000000', name: 'Ocean Mogul', desc: 'Earn $25,000,000 total', type: 'moneyEarned', target: 25000000, reward: 1500000 },
            { id: 'earn50000000', name: 'Infinite Wealth', desc: 'Earn $50,000,000 total', type: 'moneyEarned', target: 50000000, reward: 3000000 }
        ];
        
        function saveStats() {
            localStorage.setItem('warships_money', money.toString());
            localStorage.setItem('warships_totalEarned', totalMoneyEarned.toString());
            localStorage.setItem('warships_stats', JSON.stringify(questStats));
        }
        
        function loadCompletedQuests() {
            const completed = JSON.parse(localStorage.getItem('warships_completedQuests') || '[]');
            return completed;
        }
        
        function saveCompletedQuests() {
            const completed = quests.filter(q => q.claimed).map(q => q.id);
            localStorage.setItem('warships_completedQuests', JSON.stringify(completed));
        }
        
        function initQuests() {
            const completedIds = loadCompletedQuests();
            quests = questTemplates.map(t => {
                const wasCompleted = completedIds.includes(t.id);
                return { 
                    ...t, 
                    progress: wasCompleted ? t.target : Math.min(questStats[t.type] || 0, t.target), 
                    completed: wasCompleted, 
                    claimed: wasCompleted 
                };
            });
            document.getElementById('money').textContent = money.toLocaleString();
            updateQuestUI();
        }
        
        function updateQuestProgress(type, amount = 1) {
            questStats[type] += amount;
            saveStats();
            quests.forEach(quest => {
                if (quest.type === type && !quest.completed) {
                    quest.progress = Math.min(questStats[type], quest.target);
                    if (quest.progress >= quest.target) {
                        quest.completed = true;
                        claimQuest(quest);
                    }
                }
            });
            updateQuestUI();
        }
        
        function claimQuest(quest) {
            if (!quest.claimed) {
                quest.claimed = true;
                // Difficulty multiplier: Easy=1x, Medium=1.5x, Hard=2x, Extreme=3x, Nightmare=5x
                const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
                const multiplier = difficultyMultipliers[difficulty] || 1;
                const reward = Math.round(quest.reward * multiplier);
                money += reward;
                totalMoneyEarned += reward;
                questStats.moneyEarned = totalMoneyEarned;
                saveStats();
                saveCompletedQuests();
                document.getElementById('money').textContent = money.toLocaleString();
                showQuestComplete(quest, reward);
                // Check money earned quests
                checkMoneyQuests();
            }
        }
        
        function checkMoneyQuests() {
            quests.forEach(quest => {
                if (quest.type === 'moneyEarned' && !quest.completed) {
                    quest.progress = Math.min(totalMoneyEarned, quest.target);
                    if (quest.progress >= quest.target) {
                        quest.completed = true;
                        claimQuest(quest);
                    }
                }
            });
            updateQuestUI();
        }
        
        function showQuestComplete(quest, reward) {
            const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
            const multiplier = difficultyMultipliers[difficulty] || 1;
            const diffNames = ['', 'Easy', 'Medium', 'Hard', 'Extreme', 'Nightmare'];
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,50,0,0.9);border:3px solid #00ff66;border-radius:15px;padding:20px 40px;color:#fff;text-align:center;z-index:1000;animation:fadeOut 2s forwards;';
            popup.innerHTML = `<div style="color:#00ff66;font-size:1.5em;">‚úì QUEST COMPLETE!</div><div style="margin:10px 0;">${quest.name}</div><div style="color:#ffd700;font-size:1.3em;">+$${reward.toLocaleString()}</div>${multiplier > 1 ? `<div style="color:#00d4ff;font-size:0.9em;">(${diffNames[difficulty]} ${multiplier}x bonus!)</div>` : ''}`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
        }
        
        function getRewardMultiplier() {
            const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
            return difficultyMultipliers[difficulty] || 1;
        }
        
        function updateQuestUI() {
            const list = document.getElementById('quest-list');
            if (!list) return;
            const multiplier = getRewardMultiplier();
            // Sort: incomplete first, then by target
            const sortedQuests = [...quests].sort((a, b) => {
                if (a.completed !== b.completed) return a.completed ? 1 : -1;
                return a.target - b.target;
            });
            list.innerHTML = sortedQuests.map(q => {
                const displayReward = q.completed ? q.reward : Math.round(q.reward * multiplier);
                return `
                <div class="quest-item ${q.completed ? 'completed' : ''}">
                    <div class="quest-name">${q.completed ? '‚úì ' : ''}${q.name}</div>
                    <div class="quest-progress">${q.desc} (${q.progress.toLocaleString()}/${q.target.toLocaleString()})</div>
                    <div class="quest-reward">üí∞ $${displayReward.toLocaleString()}${!q.completed && multiplier > 1 ? ` <span style="color:#00d4ff">(${multiplier}x)</span>` : ''}</div>
                </div>
            `}).join('');
        }
        
        // Initialize money display on page load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('money').textContent = money.toLocaleString();
            initQuests();
            initShop();
        });
        
        // ============ SHIP SHOP SYSTEM ============
        let selectedShipId = localStorage.getItem('warships_selectedShip') || 'starter';
        let ownedShips = JSON.parse(localStorage.getItem('warships_ownedShips') || '["starter"]');
        
        const shipTemplates = [
            // STARTER (free)
            { id: 'starter', name: 'Starter Vessel', category: 'balanced', price: 0, health: 100, speed: 1.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['Free ship'], debuffs: ['Basic stats'] },
            
            // SPEED SHIPS (20)
            { id: 'swift1', name: 'Swift Runner', category: 'speed', price: 500, health: 80, speed: 1.3, fireRate: 1.0, damage: 0.9, accuracy: 1.0, buffs: ['+30% Speed'], debuffs: ['-20% Health', '-10% Damage'] },
            { id: 'swift2', name: 'Sea Dart', category: 'speed', price: 1200, health: 75, speed: 1.4, fireRate: 1.1, damage: 0.85, accuracy: 1.0, buffs: ['+40% Speed', '+10% Fire Rate'], debuffs: ['-25% Health', '-15% Damage'] },
            { id: 'swift3', name: 'Velocity', category: 'speed', price: 2500, health: 70, speed: 1.5, fireRate: 1.0, damage: 0.9, accuracy: 1.1, buffs: ['+50% Speed', '+10% Accuracy'], debuffs: ['-30% Health'] },
            { id: 'swift4', name: 'Lightning Bolt', category: 'speed', price: 5000, health: 65, speed: 1.6, fireRate: 1.2, damage: 0.85, accuracy: 1.0, buffs: ['+60% Speed', '+20% Fire Rate'], debuffs: ['-35% Health', '-15% Damage'] },
            { id: 'swift5', name: 'Tempest', category: 'speed', price: 8000, health: 70, speed: 1.7, fireRate: 1.0, damage: 1.0, accuracy: 0.9, buffs: ['+70% Speed'], debuffs: ['-30% Health', '-10% Accuracy'] },
            { id: 'swift6', name: 'Zephyr', category: 'speed', price: 12000, health: 60, speed: 1.8, fireRate: 1.1, damage: 0.9, accuracy: 1.1, buffs: ['+80% Speed', '+10% Fire Rate', '+10% Accuracy'], debuffs: ['-40% Health', '-10% Damage'] },
            { id: 'swift7', name: 'Hurricane', category: 'speed', price: 18000, health: 65, speed: 1.9, fireRate: 1.2, damage: 0.85, accuracy: 1.0, buffs: ['+90% Speed', '+20% Fire Rate'], debuffs: ['-35% Health', '-15% Damage'] },
            { id: 'swift8', name: 'Sonic Wave', category: 'speed', price: 25000, health: 55, speed: 2.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+100% Speed'], debuffs: ['-45% Health'] },
            { id: 'swift9', name: 'Phantom', category: 'speed', price: 35000, health: 50, speed: 2.1, fireRate: 1.3, damage: 0.8, accuracy: 1.2, buffs: ['+110% Speed', '+30% Fire Rate', '+20% Accuracy'], debuffs: ['-50% Health', '-20% Damage'] },
            { id: 'swift10', name: 'Blur', category: 'speed', price: 50000, health: 60, speed: 2.2, fireRate: 1.1, damage: 0.9, accuracy: 1.0, buffs: ['+120% Speed', '+10% Fire Rate'], debuffs: ['-40% Health', '-10% Damage'] },
            { id: 'swift11', name: 'Supersonic', category: 'speed', price: 70000, health: 55, speed: 2.3, fireRate: 1.2, damage: 0.85, accuracy: 1.1, buffs: ['+130% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-45% Health', '-15% Damage'] },
            { id: 'swift12', name: 'Hyperdrive', category: 'speed', price: 100000, health: 50, speed: 2.4, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+140% Speed'], debuffs: ['-50% Health'] },
            { id: 'swift13', name: 'Light Speed', category: 'speed', price: 150000, health: 45, speed: 2.5, fireRate: 1.4, damage: 0.8, accuracy: 1.2, buffs: ['+150% Speed', '+40% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-20% Damage'] },
            { id: 'swift14', name: 'Warp Runner', category: 'speed', price: 200000, health: 55, speed: 2.6, fireRate: 1.2, damage: 0.9, accuracy: 1.1, buffs: ['+160% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-45% Health', '-10% Damage'] },
            { id: 'swift15', name: 'Quantum', category: 'speed', price: 300000, health: 50, speed: 2.7, fireRate: 1.3, damage: 0.85, accuracy: 1.2, buffs: ['+170% Speed', '+30% Fire Rate', '+20% Accuracy'], debuffs: ['-50% Health', '-15% Damage'] },
            { id: 'swift16', name: 'Teleporter', category: 'speed', price: 400000, health: 45, speed: 2.8, fireRate: 1.1, damage: 1.0, accuracy: 1.0, buffs: ['+180% Speed', '+10% Fire Rate'], debuffs: ['-55% Health'] },
            { id: 'swift17', name: 'Flash', category: 'speed', price: 550000, health: 40, speed: 2.9, fireRate: 1.5, damage: 0.75, accuracy: 1.3, buffs: ['+190% Speed', '+50% Fire Rate', '+30% Accuracy'], debuffs: ['-60% Health', '-25% Damage'] },
            { id: 'swift18', name: 'Comet', category: 'speed', price: 750000, health: 50, speed: 3.0, fireRate: 1.2, damage: 0.9, accuracy: 1.1, buffs: ['+200% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-50% Health', '-10% Damage'] },
            { id: 'swift19', name: 'Meteor', category: 'speed', price: 1000000, health: 45, speed: 3.2, fireRate: 1.4, damage: 0.85, accuracy: 1.2, buffs: ['+220% Speed', '+40% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-15% Damage'] },
            { id: 'swift20', name: 'Speed Demon', category: 'speed', price: 2000000, health: 40, speed: 3.5, fireRate: 1.5, damage: 0.8, accuracy: 1.3, buffs: ['+250% Speed', '+50% Fire Rate', '+30% Accuracy'], debuffs: ['-60% Health', '-20% Damage'] },
            
            // TANK SHIPS (20)
            { id: 'tank1', name: 'Iron Hull', category: 'tank', price: 500, health: 140, speed: 0.8, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+40% Health'], debuffs: ['-20% Speed'] },
            { id: 'tank2', name: 'Steel Wall', category: 'tank', price: 1200, health: 160, speed: 0.75, fireRate: 0.9, damage: 1.1, accuracy: 0.95, buffs: ['+60% Health', '+10% Damage'], debuffs: ['-25% Speed', '-10% Fire Rate'] },
            { id: 'tank3', name: 'Fortress', category: 'tank', price: 2500, health: 180, speed: 0.7, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+80% Health'], debuffs: ['-30% Speed'] },
            { id: 'tank4', name: 'Juggernaut', category: 'tank', price: 5000, health: 200, speed: 0.65, fireRate: 0.85, damage: 1.2, accuracy: 0.9, buffs: ['+100% Health', '+20% Damage'], debuffs: ['-35% Speed', '-15% Fire Rate', '-10% Accuracy'] },
            { id: 'tank5', name: 'Behemoth', category: 'tank', price: 8000, health: 220, speed: 0.7, fireRate: 0.9, damage: 1.1, accuracy: 1.0, buffs: ['+120% Health', '+10% Damage'], debuffs: ['-30% Speed', '-10% Fire Rate'] },
            { id: 'tank6', name: 'Titan', category: 'tank', price: 12000, health: 240, speed: 0.6, fireRate: 0.85, damage: 1.15, accuracy: 0.95, buffs: ['+140% Health', '+15% Damage'], debuffs: ['-40% Speed', '-15% Fire Rate'] },
            { id: 'tank7', name: 'Colossus', category: 'tank', price: 18000, health: 260, speed: 0.65, fireRate: 0.9, damage: 1.2, accuracy: 0.9, buffs: ['+160% Health', '+20% Damage'], debuffs: ['-35% Speed', '-10% Fire Rate', '-10% Accuracy'] },
            { id: 'tank8', name: 'Leviathan', category: 'tank', price: 25000, health: 280, speed: 0.55, fireRate: 0.8, damage: 1.25, accuracy: 0.95, buffs: ['+180% Health', '+25% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank9', name: 'Mountain', category: 'tank', price: 35000, health: 300, speed: 0.6, fireRate: 0.85, damage: 1.2, accuracy: 1.0, buffs: ['+200% Health', '+20% Damage'], debuffs: ['-40% Speed', '-15% Fire Rate'] },
            { id: 'tank10', name: 'Dreadnought', category: 'tank', price: 50000, health: 320, speed: 0.5, fireRate: 0.75, damage: 1.3, accuracy: 0.9, buffs: ['+220% Health', '+30% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank11', name: 'Ironclad', category: 'tank', price: 70000, health: 340, speed: 0.55, fireRate: 0.8, damage: 1.25, accuracy: 0.95, buffs: ['+240% Health', '+25% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank12', name: 'Mammoth', category: 'tank', price: 100000, health: 360, speed: 0.5, fireRate: 0.75, damage: 1.35, accuracy: 0.9, buffs: ['+260% Health', '+35% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank13', name: 'Bulwark', category: 'tank', price: 150000, health: 380, speed: 0.55, fireRate: 0.8, damage: 1.3, accuracy: 0.95, buffs: ['+280% Health', '+30% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank14', name: 'Citadel', category: 'tank', price: 200000, health: 400, speed: 0.45, fireRate: 0.7, damage: 1.4, accuracy: 0.85, buffs: ['+300% Health', '+40% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate', '-15% Accuracy'] },
            { id: 'tank15', name: 'Bastion', category: 'tank', price: 300000, health: 420, speed: 0.5, fireRate: 0.75, damage: 1.35, accuracy: 0.9, buffs: ['+320% Health', '+35% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank16', name: 'Rampart', category: 'tank', price: 400000, health: 450, speed: 0.45, fireRate: 0.7, damage: 1.4, accuracy: 0.9, buffs: ['+350% Health', '+40% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate'] },
            { id: 'tank17', name: 'Goliath', category: 'tank', price: 550000, health: 480, speed: 0.4, fireRate: 0.65, damage: 1.5, accuracy: 0.85, buffs: ['+380% Health', '+50% Damage'], debuffs: ['-60% Speed', '-35% Fire Rate', '-15% Accuracy'] },
            { id: 'tank18', name: 'Monolith', category: 'tank', price: 750000, health: 500, speed: 0.45, fireRate: 0.7, damage: 1.45, accuracy: 0.9, buffs: ['+400% Health', '+45% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate', '-10% Accuracy'] },
            { id: 'tank19', name: 'Eternal', category: 'tank', price: 1000000, health: 550, speed: 0.4, fireRate: 0.65, damage: 1.5, accuracy: 0.85, buffs: ['+450% Health', '+50% Damage'], debuffs: ['-60% Speed', '-35% Fire Rate', '-15% Accuracy'] },
            { id: 'tank20', name: 'Immortal', category: 'tank', price: 2000000, health: 600, speed: 0.35, fireRate: 0.6, damage: 1.6, accuracy: 0.8, buffs: ['+500% Health', '+60% Damage'], debuffs: ['-65% Speed', '-40% Fire Rate', '-20% Accuracy'] },
            
            // DAMAGE SHIPS (20)
            { id: 'dmg1', name: 'Striker', category: 'damage', price: 500, health: 85, speed: 0.95, fireRate: 1.0, damage: 1.25, accuracy: 1.0, buffs: ['+25% Damage'], debuffs: ['-15% Health'] },
            { id: 'dmg2', name: 'Punisher', category: 'damage', price: 1200, health: 80, speed: 0.9, fireRate: 1.1, damage: 1.35, accuracy: 0.95, buffs: ['+35% Damage', '+10% Fire Rate'], debuffs: ['-20% Health', '-10% Speed'] },
            { id: 'dmg3', name: 'Destroyer', category: 'damage', price: 2500, health: 90, speed: 1.0, fireRate: 0.9, damage: 1.45, accuracy: 1.0, buffs: ['+45% Damage'], debuffs: ['-10% Health', '-10% Fire Rate'] },
            { id: 'dmg4', name: 'Annihilator', category: 'damage', price: 5000, health: 75, speed: 0.85, fireRate: 1.15, damage: 1.55, accuracy: 0.9, buffs: ['+55% Damage', '+15% Fire Rate'], debuffs: ['-25% Health', '-15% Speed', '-10% Accuracy'] },
            { id: 'dmg5', name: 'Executioner', category: 'damage', price: 8000, health: 85, speed: 0.95, fireRate: 1.0, damage: 1.6, accuracy: 1.0, buffs: ['+60% Damage'], debuffs: ['-15% Health'] },
            { id: 'dmg6', name: 'Obliterator', category: 'damage', price: 12000, health: 70, speed: 0.9, fireRate: 1.2, damage: 1.7, accuracy: 0.95, buffs: ['+70% Damage', '+20% Fire Rate'], debuffs: ['-30% Health', '-10% Speed'] },
            { id: 'dmg7', name: 'Devastator', category: 'damage', price: 18000, health: 80, speed: 0.95, fireRate: 1.1, damage: 1.75, accuracy: 0.9, buffs: ['+75% Damage', '+10% Fire Rate'], debuffs: ['-20% Health', '-10% Accuracy'] },
            { id: 'dmg8', name: 'Ravager', category: 'damage', price: 25000, health: 65, speed: 0.85, fireRate: 1.25, damage: 1.85, accuracy: 0.95, buffs: ['+85% Damage', '+25% Fire Rate'], debuffs: ['-35% Health', '-15% Speed'] },
            { id: 'dmg9', name: 'Eliminator', category: 'damage', price: 35000, health: 75, speed: 0.9, fireRate: 1.15, damage: 1.9, accuracy: 1.0, buffs: ['+90% Damage', '+15% Fire Rate'], debuffs: ['-25% Health', '-10% Speed'] },
            { id: 'dmg10', name: 'Terminator', category: 'damage', price: 50000, health: 60, speed: 0.8, fireRate: 1.3, damage: 2.0, accuracy: 0.9, buffs: ['+100% Damage', '+30% Fire Rate'], debuffs: ['-40% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg11', name: 'Eradicator', category: 'damage', price: 70000, health: 70, speed: 0.9, fireRate: 1.2, damage: 2.1, accuracy: 0.95, buffs: ['+110% Damage', '+20% Fire Rate'], debuffs: ['-30% Health', '-10% Speed'] },
            { id: 'dmg12', name: 'Decimator', category: 'damage', price: 100000, health: 55, speed: 0.8, fireRate: 1.35, damage: 2.2, accuracy: 0.9, buffs: ['+120% Damage', '+35% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg13', name: 'Slayer', category: 'damage', price: 150000, health: 65, speed: 0.85, fireRate: 1.25, damage: 2.3, accuracy: 0.95, buffs: ['+130% Damage', '+25% Fire Rate'], debuffs: ['-35% Health', '-15% Speed'] },
            { id: 'dmg14', name: 'Reaper', category: 'damage', price: 200000, health: 50, speed: 0.75, fireRate: 1.4, damage: 2.5, accuracy: 0.85, buffs: ['+150% Damage', '+40% Fire Rate'], debuffs: ['-50% Health', '-25% Speed', '-15% Accuracy'] },
            { id: 'dmg15', name: 'Destroyer X', category: 'damage', price: 300000, health: 60, speed: 0.85, fireRate: 1.3, damage: 2.6, accuracy: 0.9, buffs: ['+160% Damage', '+30% Fire Rate'], debuffs: ['-40% Health', '-15% Speed', '-10% Accuracy'] },
            { id: 'dmg16', name: 'Omega Strike', category: 'damage', price: 400000, health: 55, speed: 0.8, fireRate: 1.4, damage: 2.75, accuracy: 0.9, buffs: ['+175% Damage', '+40% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg17', name: 'Death Dealer', category: 'damage', price: 550000, health: 45, speed: 0.7, fireRate: 1.5, damage: 3.0, accuracy: 0.85, buffs: ['+200% Damage', '+50% Fire Rate'], debuffs: ['-55% Health', '-30% Speed', '-15% Accuracy'] },
            { id: 'dmg18', name: 'Armageddon', category: 'damage', price: 750000, health: 55, speed: 0.8, fireRate: 1.4, damage: 3.2, accuracy: 0.9, buffs: ['+220% Damage', '+40% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg19', name: 'Apocalypse', category: 'damage', price: 1000000, health: 50, speed: 0.75, fireRate: 1.5, damage: 3.5, accuracy: 0.85, buffs: ['+250% Damage', '+50% Fire Rate'], debuffs: ['-50% Health', '-25% Speed', '-15% Accuracy'] },
            { id: 'dmg20', name: 'World Ender', category: 'damage', price: 2000000, health: 40, speed: 0.65, fireRate: 1.6, damage: 4.0, accuracy: 0.8, buffs: ['+300% Damage', '+60% Fire Rate'], debuffs: ['-60% Health', '-35% Speed', '-20% Accuracy'] },
            
            // BALANCED SHIPS (20)
            { id: 'bal1', name: 'Voyager', category: 'balanced', price: 800, health: 110, speed: 1.1, fireRate: 1.05, damage: 1.05, accuracy: 1.05, buffs: ['+10% All Stats'], debuffs: [] },
            { id: 'bal2', name: 'Explorer', category: 'balanced', price: 1500, health: 115, speed: 1.1, fireRate: 1.1, damage: 1.05, accuracy: 1.05, buffs: ['+15% Health', '+10% Speed/Fire Rate'], debuffs: [] },
            { id: 'bal3', name: 'Navigator', category: 'balanced', price: 3000, health: 120, speed: 1.15, fireRate: 1.1, damage: 1.1, accuracy: 1.05, buffs: ['+20% Health', '+15% Speed', '+10% Damage'], debuffs: [] },
            { id: 'bal4', name: 'Pathfinder', category: 'balanced', price: 6000, health: 125, speed: 1.15, fireRate: 1.15, damage: 1.1, accuracy: 1.1, buffs: ['+25% Health', '+15% All Offense'], debuffs: [] },
            { id: 'bal5', name: 'Crusader', category: 'balanced', price: 10000, health: 130, speed: 1.2, fireRate: 1.15, damage: 1.15, accuracy: 1.1, buffs: ['+30% Health', '+20% Speed', '+15% Damage'], debuffs: [] },
            { id: 'bal6', name: 'Guardian', category: 'balanced', price: 15000, health: 140, speed: 1.15, fireRate: 1.2, damage: 1.15, accuracy: 1.15, buffs: ['+40% Health', '+15% Speed', '+20% Fire Rate'], debuffs: [] },
            { id: 'bal7', name: 'Sentinel', category: 'balanced', price: 22000, health: 145, speed: 1.2, fireRate: 1.2, damage: 1.2, accuracy: 1.15, buffs: ['+45% Health', '+20% All Offense'], debuffs: [] },
            { id: 'bal8', name: 'Protector', category: 'balanced', price: 30000, health: 150, speed: 1.25, fireRate: 1.2, damage: 1.2, accuracy: 1.2, buffs: ['+50% Health', '+25% Speed', '+20% Damage'], debuffs: [] },
            { id: 'bal9', name: 'Champion', category: 'balanced', price: 42000, health: 155, speed: 1.25, fireRate: 1.25, damage: 1.25, accuracy: 1.2, buffs: ['+55% Health', '+25% All Offense'], debuffs: [] },
            { id: 'bal10', name: 'Vindicator', category: 'balanced', price: 55000, health: 160, speed: 1.3, fireRate: 1.25, damage: 1.25, accuracy: 1.25, buffs: ['+60% Health', '+30% Speed', '+25% Offense'], debuffs: [] },
            { id: 'bal11', name: 'Conqueror', category: 'balanced', price: 75000, health: 170, speed: 1.3, fireRate: 1.3, damage: 1.3, accuracy: 1.25, buffs: ['+70% Health', '+30% All Offense'], debuffs: [] },
            { id: 'bal12', name: 'Overlord', category: 'balanced', price: 100000, health: 180, speed: 1.35, fireRate: 1.3, damage: 1.3, accuracy: 1.3, buffs: ['+80% Health', '+35% Speed', '+30% Offense'], debuffs: [] },
            { id: 'bal13', name: 'Sovereign', category: 'balanced', price: 140000, health: 190, speed: 1.35, fireRate: 1.35, damage: 1.35, accuracy: 1.3, buffs: ['+90% Health', '+35% All Offense'], debuffs: [] },
            { id: 'bal14', name: 'Emperor', category: 'balanced', price: 180000, health: 200, speed: 1.4, fireRate: 1.35, damage: 1.35, accuracy: 1.35, buffs: ['+100% Health', '+40% Speed', '+35% Offense'], debuffs: [] },
            { id: 'bal15', name: 'Warlord', category: 'balanced', price: 250000, health: 210, speed: 1.4, fireRate: 1.4, damage: 1.4, accuracy: 1.35, buffs: ['+110% Health', '+40% All Offense'], debuffs: [] },
            { id: 'bal16', name: 'Dominator', category: 'balanced', price: 350000, health: 220, speed: 1.45, fireRate: 1.4, damage: 1.4, accuracy: 1.4, buffs: ['+120% Health', '+45% Speed', '+40% Offense'], debuffs: [] },
            { id: 'bal17', name: 'Supremacy', category: 'balanced', price: 500000, health: 240, speed: 1.45, fireRate: 1.45, damage: 1.45, accuracy: 1.4, buffs: ['+140% Health', '+45% All Offense'], debuffs: [] },
            { id: 'bal18', name: 'Infinity', category: 'balanced', price: 700000, health: 260, speed: 1.5, fireRate: 1.5, damage: 1.5, accuracy: 1.45, buffs: ['+160% Health', '+50% All Offense'], debuffs: [] },
            { id: 'bal19', name: 'Omega', category: 'balanced', price: 1000000, health: 280, speed: 1.55, fireRate: 1.55, damage: 1.55, accuracy: 1.5, buffs: ['+180% Health', '+55% All Offense'], debuffs: [] },
            { id: 'bal20', name: 'Perfection', category: 'balanced', price: 2000000, health: 300, speed: 1.6, fireRate: 1.6, damage: 1.6, accuracy: 1.6, buffs: ['+200% Health', '+60% All Stats'], debuffs: [] },
            
            // SPECIAL SHIPS (19)
            { id: 'spec1', name: 'Glass Cannon', category: 'special', price: 3000, health: 40, speed: 1.2, fireRate: 1.5, damage: 2.5, accuracy: 1.2, buffs: ['+150% Damage', '+50% Fire Rate', '+20% Accuracy'], debuffs: ['-60% Health'] },
            { id: 'spec2', name: 'Sniper', category: 'special', price: 5000, health: 70, speed: 0.7, fireRate: 0.5, damage: 3.0, accuracy: 1.5, buffs: ['+200% Damage', '+50% Accuracy'], debuffs: ['-30% Health', '-30% Speed', '-50% Fire Rate'] },
            { id: 'spec3', name: 'Berserker', category: 'special', price: 8000, health: 60, speed: 1.5, fireRate: 2.0, damage: 0.7, accuracy: 0.7, buffs: ['+50% Speed', '+100% Fire Rate'], debuffs: ['-40% Health', '-30% Damage', '-30% Accuracy'] },
            { id: 'spec4', name: 'Vampire', category: 'special', price: 15000, health: 80, speed: 1.1, fireRate: 1.2, damage: 1.3, accuracy: 1.0, buffs: ['+30% Damage', '+20% Fire Rate', 'Lifesteal'], debuffs: ['-20% Health'] },
            { id: 'spec5', name: 'Ninja', category: 'special', price: 20000, health: 50, speed: 2.0, fireRate: 1.8, damage: 1.2, accuracy: 0.8, buffs: ['+100% Speed', '+80% Fire Rate'], debuffs: ['-50% Health', '-20% Accuracy'] },
            { id: 'spec6', name: 'Turtle', category: 'special', price: 25000, health: 400, speed: 0.3, fireRate: 0.5, damage: 2.0, accuracy: 1.0, buffs: ['+300% Health', '+100% Damage'], debuffs: ['-70% Speed', '-50% Fire Rate'] },
            { id: 'spec7', name: 'Gambler', category: 'special', price: 30000, health: 100, speed: 1.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['Random +50% to one stat each game'], debuffs: ['Random -25% to one stat each game'] },
            { id: 'spec8', name: 'Assassin', category: 'special', price: 40000, health: 45, speed: 1.8, fireRate: 0.8, damage: 4.0, accuracy: 1.4, buffs: ['+300% Damage', '+40% Accuracy', '+80% Speed'], debuffs: ['-55% Health', '-20% Fire Rate'] },
            { id: 'spec9', name: 'Tank Destroyer', category: 'special', price: 50000, health: 120, speed: 0.6, fireRate: 0.4, damage: 5.0, accuracy: 1.3, buffs: ['+400% Damage', '+30% Accuracy'], debuffs: ['-40% Speed', '-60% Fire Rate'] },
            { id: 'spec10', name: 'Swarm', category: 'special', price: 60000, health: 35, speed: 1.6, fireRate: 3.0, damage: 0.4, accuracy: 0.6, buffs: ['+60% Speed', '+200% Fire Rate'], debuffs: ['-65% Health', '-60% Damage', '-40% Accuracy'] },
            { id: 'spec11', name: 'Fortress', category: 'special', price: 80000, health: 500, speed: 0.2, fireRate: 0.7, damage: 1.5, accuracy: 1.2, buffs: ['+400% Health', '+50% Damage', '+20% Accuracy'], debuffs: ['-80% Speed'] },
            { id: 'spec12', name: 'Phantom Strike', category: 'special', price: 100000, health: 60, speed: 2.2, fireRate: 1.4, damage: 2.0, accuracy: 1.0, buffs: ['+120% Speed', '+40% Fire Rate', '+100% Damage'], debuffs: ['-40% Health'] },
            { id: 'spec13', name: 'Juggernaut X', category: 'special', price: 150000, health: 350, speed: 0.5, fireRate: 1.0, damage: 2.0, accuracy: 1.0, buffs: ['+250% Health', '+100% Damage'], debuffs: ['-50% Speed'] },
            { id: 'spec14', name: 'Precision', category: 'special', price: 200000, health: 80, speed: 1.0, fireRate: 0.7, damage: 2.5, accuracy: 2.0, buffs: ['+150% Damage', '+100% Accuracy'], debuffs: ['-20% Health', '-30% Fire Rate'] },
            { id: 'spec15', name: 'Rapid Fire', category: 'special', price: 300000, health: 70, speed: 1.3, fireRate: 3.5, damage: 0.5, accuracy: 0.9, buffs: ['+30% Speed', '+250% Fire Rate'], debuffs: ['-30% Health', '-50% Damage', '-10% Accuracy'] },
            { id: 'spec16', name: 'Destroyer Elite', category: 'special', price: 500000, health: 150, speed: 1.3, fireRate: 1.5, damage: 2.5, accuracy: 1.3, buffs: ['+50% Health', '+30% Speed', '+50% Fire Rate', '+150% Damage'], debuffs: [] },
            { id: 'spec17', name: 'Legendary', category: 'special', price: 750000, health: 200, speed: 1.5, fireRate: 1.5, damage: 2.0, accuracy: 1.5, buffs: ['+100% Health', '+50% Speed', '+50% Fire/Damage/Accuracy'], debuffs: [] },
            { id: 'spec18', name: 'Mythic', category: 'special', price: 1500000, health: 250, speed: 1.7, fireRate: 1.8, damage: 2.5, accuracy: 1.6, buffs: ['+150% Health', '+70% Speed', '+80% Fire Rate', '+150% Damage'], debuffs: [] },
            { id: 'spec19', name: 'Divine', category: 'special', price: 3000000, health: 350, speed: 2.0, fireRate: 2.0, damage: 3.0, accuracy: 1.8, buffs: ['+250% Health', '+100% Speed', '+100% Fire Rate', '+200% Damage'], debuffs: [] }
        ];
        
        function initShop() {
            updateShipDisplay();
            renderShop('all');
        }
        
        function toggleShop() {
            const panel = document.getElementById('shop-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function toggleQuests() {
            const panel = document.getElementById('quest-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function showShopCategory(category) {
            document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderShop(category);
        }
        
        function renderShop(category) {
            const grid = document.getElementById('ship-grid');
            const filtered = category === 'all' ? shipTemplates : shipTemplates.filter(s => s.category === category);
            
            grid.innerHTML = filtered.map(ship => {
                const owned = ownedShips.includes(ship.id);
                const selected = selectedShipId === ship.id;
                const canAfford = money >= ship.price;
                
                return `
                    <div class="ship-card ${owned ? 'owned' : ''} ${selected ? 'selected' : ''}">
                        <div class="ship-name">${ship.name}</div>
                        <div class="ship-price">${ship.price === 0 ? 'FREE' : '$' + ship.price.toLocaleString()}</div>
                        <div class="ship-stats">
                            <div>‚ù§Ô∏è ${ship.health}% | ‚ö° ${Math.round(ship.speed * 100)}%</div>
                            <div>üî• ${Math.round(ship.fireRate * 100)}% | üí• ${Math.round(ship.damage * 100)}%</div>
                            <div>üéØ ${Math.round(ship.accuracy * 100)}%</div>
                            ${ship.buffs.map(b => `<div class="buff">‚úì ${b}</div>`).join('')}
                            ${ship.debuffs.map(d => `<div class="debuff">‚úó ${d}</div>`).join('')}
                        </div>
                        ${owned 
                            ? (selected 
                                ? '<button disabled>EQUIPPED</button>' 
                                : `<button onclick="selectShip('${ship.id}')">EQUIP</button>`)
                            : `<button onclick="buyShip('${ship.id}')" ${!canAfford ? 'disabled' : ''}>${canAfford ? 'BUY' : 'Need $' + (ship.price - money).toLocaleString()}</button>`
                        }
                    </div>
                `;
            }).join('');
        }
        
        function buyShip(shipId) {
            const ship = shipTemplates.find(s => s.id === shipId);
            if (!ship || money < ship.price) return;
            
            money -= ship.price;
            ownedShips.push(shipId);
            localStorage.setItem('warships_money', money.toString());
            localStorage.setItem('warships_ownedShips', JSON.stringify(ownedShips));
            document.getElementById('money').textContent = money.toLocaleString();
            
            // Show purchase popup
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,50,100,0.95);border:3px solid #00d4ff;border-radius:15px;padding:20px 40px;color:#fff;text-align:center;z-index:3000;animation:fadeOut 2s forwards;';
            popup.innerHTML = `<div style="color:#00d4ff;font-size:1.5em;">üö¢ SHIP PURCHASED!</div><div style="margin:10px 0;font-size:1.2em;">${ship.name}</div>`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
            
            renderShop(document.querySelector('.shop-tab.active')?.textContent.toLowerCase() || 'all');
        }
        
        function selectShip(shipId) {
            if (!ownedShips.includes(shipId)) return;
            selectedShipId = shipId;
            localStorage.setItem('warships_selectedShip', shipId);
            updateShipDisplay();
            renderShop(document.querySelector('.shop-tab.active')?.textContent.toLowerCase() || 'all');
        }
        
        function updateShipDisplay() {
            const ship = shipTemplates.find(s => s.id === selectedShipId) || shipTemplates[0];
            document.getElementById('current-ship-name').textContent = ship.name;
        }
        
        function getSelectedShipStats() {
            return shipTemplates.find(s => s.id === selectedShipId) || shipTemplates[0];
        }
        
        // Particle limits to prevent memory issues
        const MAX_SMOKE_PARTICLES = 100;
        const MAX_TRAIL_PARTICLES = 50;
        const MAX_EXPLOSION_PARTICLES = 200;
        
        // Helper to properly dispose THREE.js objects
        function disposeMesh(mesh) {
            if (!mesh) return;
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
            scene.remove(mesh);
        }

        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function init() {
            // Scene with fog for atmosphere
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x8fadc7, 0.00015);

            // Camera
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 80, 120);

            // Renderer with maximum quality settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.85;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            document.body.appendChild(renderer.domElement);

            // Sky
            createSky();

            // Realistic lighting setup
            // Ambient - very subtle blue from sky
            const ambientLight = new THREE.AmbientLight(0x4466aa, 0.15);
            scene.add(ambientLight);

            // Main sun light - warm golden hour
            sun = new THREE.DirectionalLight(0xffeedd, 2.5);
            sun.position.set(200, 100, -300);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 4096;
            sun.shadow.mapSize.height = 4096;
            sun.shadow.camera.near = 10;
            sun.shadow.camera.far = 800;
            sun.shadow.camera.left = -300;
            sun.shadow.camera.right = 300;
            sun.shadow.camera.top = 300;
            sun.shadow.camera.bottom = -300;
            sun.shadow.bias = -0.0001;
            sun.shadow.normalBias = 0.02;
            scene.add(sun);

            // Hemisphere light - sky/ground color bounce
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x3a5f4a, 0.4);
            scene.add(hemiLight);
            
            // Rim light from behind (backlight for dramatic effect)
            const rimLight = new THREE.DirectionalLight(0xffd4a6, 0.8);
            rimLight.position.set(-100, 50, 200);
            scene.add(rimLight);

            // Ocean
            createOcean();

            // Ships spawned when game starts

            window.addEventListener('resize', onWindowResize);
        }

        function createSky() {
            // Photorealistic sky with Rayleigh/Mie scattering simulation
            const skyGeometry = new THREE.SphereGeometry(1500, 64, 64);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    sunPosition: { value: new THREE.Vector3(200, 100, -300) },
                    rayleigh: { value: 2.0 },
                    turbidity: { value: 8.0 },
                    mieCoefficient: { value: 0.005 },
                    mieDirectionalG: { value: 0.8 },
                    luminance: { value: 1.1 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec3 vSunDirection;
                    uniform vec3 sunPosition;
                    
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vSunDirection = normalize(sunPosition);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float rayleigh;
                    uniform float turbidity;
                    uniform float mieCoefficient;
                    uniform float mieDirectionalG;
                    uniform float luminance;
                    uniform vec3 sunPosition;
                    
                    varying vec3 vWorldPosition;
                    varying vec3 vSunDirection;
                    
                    // Rayleigh and Mie phase functions
                    float rayleighPhase(float cosTheta) {
                        return (3.0 / (16.0 * 3.14159)) * (1.0 + cosTheta * cosTheta);
                    }
                    
                    float hgPhase(float cosTheta, float g) {
                        float g2 = g * g;
                        float inverse = 1.0 / pow(1.0 - 2.0 * g * cosTheta + g2, 1.5);
                        return (1.0 / (4.0 * 3.14159)) * ((1.0 - g2) * inverse);
                    }
                    
                    void main() {
                        vec3 direction = normalize(vWorldPosition);
                        float zenithAngle = acos(max(0.0, direction.y));
                        float inverse = 1.0 / (cos(zenithAngle) + 0.15 * pow(93.885 - degrees(zenithAngle), -1.253));
                        
                        // Rayleigh scattering coefficients
                        vec3 betaR = vec3(5.5e-6, 13.0e-6, 22.4e-6) * rayleigh;
                        
                        // Mie scattering
                        float Km = turbidity * mieCoefficient;
                        vec3 betaM = vec3(Km, Km, Km);
                        
                        // Optical depth
                        float sR = inverse * 8400.0;
                        float sM = inverse * 1200.0;
                        
                        // Extinction
                        vec3 Fex = exp(-(betaR * sR + betaM * sM));
                        
                        // Sun angle
                        float cosTheta = dot(direction, vSunDirection);
                        
                        // Scattering
                        float rPhase = rayleighPhase(cosTheta);
                        vec3 betaRTheta = betaR * rPhase;
                        
                        float mPhase = hgPhase(cosTheta, mieDirectionalG);
                        vec3 betaMTheta = betaM * mPhase;
                        
                        // Sun intensity
                        vec3 sunE = vec3(1.0, 0.95, 0.85) * 1000.0;
                        
                        // In-scattering
                        vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5));
                        Lin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(0.5)), 
                                   clamp(pow(1.0 - dot(vSunDirection, vec3(0.0, 1.0, 0.0)), 5.0), 0.0, 1.0));
                        
                        // Sun disc
                        float sunAngularDiameter = 0.00933; // radians
                        float sunDist = length(direction - vSunDirection);
                        float sundisk = smoothstep(sunAngularDiameter, sunAngularDiameter * 0.9, sunDist);
                        
                        vec3 L0 = vec3(0.1) * Fex;
                        L0 += sunE * 19000.0 * Fex * sundisk;
                        
                        // Final color with tone mapping
                        vec3 texColor = (Lin + L0) * 0.04;
                        texColor = pow(texColor, vec3(1.0 / 2.2)); // gamma
                        
                        // Add subtle blue at zenith
                        float horizonBlend = pow(1.0 - max(direction.y, 0.0), 3.0);
                        vec3 horizonColor = vec3(0.75, 0.82, 0.92);
                        texColor = mix(texColor, horizonColor, horizonBlend * 0.3);
                        
                        // Clamp and output
                        gl_FragColor = vec4(clamp(texColor * luminance, 0.0, 1.0), 1.0);
                    }
                `,
                side: THREE.BackSide,
                depthWrite: false
            });
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Photorealistic sun with proper glow
            const sunGroup = new THREE.Group();
            
            // Core sun disc
            const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffee
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunGroup.add(sunMesh);
            
            // Inner corona
            const corona1Geo = new THREE.SphereGeometry(35, 32, 32);
            const corona1Mat = new THREE.MeshBasicMaterial({ 
                color: 0xfffaf0, transparent: true, opacity: 0.4
            });
            sunGroup.add(new THREE.Mesh(corona1Geo, corona1Mat));
            
            // Outer corona
            const corona2Geo = new THREE.SphereGeometry(55, 32, 32);
            const corona2Mat = new THREE.MeshBasicMaterial({ 
                color: 0xffeedd, transparent: true, opacity: 0.15
            });
            sunGroup.add(new THREE.Mesh(corona2Geo, corona2Mat));
            
            // Atmospheric glow
            const glowGeo = new THREE.SphereGeometry(90, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffcc88, transparent: true, opacity: 0.08
            });
            sunGroup.add(new THREE.Mesh(glowGeo, glowMat));
            
            sunGroup.position.set(200, 100, -300);
            scene.add(sunGroup);

            // Photorealistic cumulus clouds
            createRealisticClouds();
        }
        
        function createRealisticClouds() {
            // Create layered cumulus cloud formations
            const cloudPositions = [
                { x: -400, y: 120, z: -500, scale: 1.2 },
                { x: 200, y: 140, z: -600, scale: 1.5 },
                { x: -200, y: 100, z: -400, scale: 0.9 },
                { x: 500, y: 130, z: -450, scale: 1.1 },
                { x: -600, y: 110, z: -550, scale: 1.3 },
                { x: 100, y: 150, z: -700, scale: 1.8 },
                { x: -350, y: 125, z: -650, scale: 1.0 },
                { x: 400, y: 115, z: -350, scale: 0.8 },
                { x: -100, y: 135, z: -500, scale: 1.4 },
                { x: 300, y: 145, z: -600, scale: 1.6 }
            ];
            
            for (let pos of cloudPositions) {
                createCumulusCloud(pos.x, pos.y, pos.z, pos.scale);
            }
        }
        
        function createCumulusCloud(x, y, z, scale) {
            const cloudGroup = new THREE.Group();
            
            // Multi-layered cloud for depth
            const layers = [
                { opacity: 0.9, color: 0xffffff, yOffset: 0, count: 12 },
                { opacity: 0.6, color: 0xf8f8ff, yOffset: 8, count: 8 },
                { opacity: 0.3, color: 0xf0f0f5, yOffset: 15, count: 5 }
            ];
            
            for (let layer of layers) {
                const material = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    flatShading: false,
                    depthWrite: false
                });
                
                for (let i = 0; i < layer.count; i++) {
                    const size = (15 + Math.random() * 25) * scale;
                    const geo = new THREE.SphereGeometry(size, 16, 16);
                    const puff = new THREE.Mesh(geo, material);
                    
                    puff.position.set(
                        (Math.random() - 0.5) * 80 * scale,
                        layer.yOffset + (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 80 * scale
                    );
                    puff.scale.y = 0.5 + Math.random() * 0.2;
                    puff.scale.x = 0.8 + Math.random() * 0.4;
                    cloudGroup.add(puff);
                }
            }
            
            // Subtle shadow on bottom
            const shadowMat = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true,
                opacity: 0.2,
                depthWrite: false
            });
            
            for (let i = 0; i < 6; i++) {
                const size = (20 + Math.random() * 20) * scale;
                const geo = new THREE.SphereGeometry(size, 12, 12);
                const shadow = new THREE.Mesh(geo, shadowMat);
                shadow.position.set(
                    (Math.random() - 0.5) * 60 * scale,
                    -10,
                    (Math.random() - 0.5) * 60 * scale
                );
                shadow.scale.y = 0.3;
                cloudGroup.add(shadow);
            }
            
            cloudGroup.position.set(x, y, z);
            cloudGroup.userData = { driftSpeed: 0.3 + Math.random() * 0.3, originalX: x };
            scene.add(cloudGroup);
        }

        function createOcean() {
            // Ocean with super small waves
            const waterGeometry = new THREE.PlaneGeometry(2000, 2000, 128, 128);
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    deepColor: { value: new THREE.Color(0x001020) },
                    midColor: { value: new THREE.Color(0x0a3d5c) },
                    shallowColor: { value: new THREE.Color(0x1a6e8e) },
                    sunDirection: { value: new THREE.Vector3(0.5, 0.8, -0.3).normalize() },
                    sunColor: { value: new THREE.Color(0xfffaf0) },
                    skyColorTop: { value: new THREE.Color(0x0055aa) },
                    skyColorHorizon: { value: new THREE.Color(0x88aacc) }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vHeight;
                    
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        
                        // Super small gentle waves
                        float wave1 = sin(pos.x * 0.05 + time * 0.5) * 0.3;
                        float wave2 = sin(pos.y * 0.07 + time * 0.4) * 0.2;
                        float wave3 = sin((pos.x + pos.y) * 0.03 + time * 0.3) * 0.15;
                        float waveHeight = wave1 + wave2 + wave3;
                        
                        vHeight = waveHeight;
                        
                        // Calculate normal from wave slope
                        float dx = cos(pos.x * 0.05 + time * 0.5) * 0.05 * 0.3 +
                                   cos((pos.x + pos.y) * 0.03 + time * 0.3) * 0.03 * 0.15;
                        float dy = cos(pos.y * 0.07 + time * 0.4) * 0.07 * 0.2 +
                                   cos((pos.x + pos.y) * 0.03 + time * 0.3) * 0.03 * 0.15;
                        vNormal = normalize(vec3(-dx, 1.0, -dy));
                        
                        vec4 worldPosition = modelMatrix * vec4(pos.x, pos.y, waveHeight, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 deepColor;
                    uniform vec3 midColor;
                    uniform vec3 shallowColor;
                    uniform vec3 sunDirection;
                    uniform vec3 sunColor;
                    uniform vec3 skyColorTop;
                    uniform vec3 skyColorHorizon;
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vHeight;
                    
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                        vec3 normal = normalize(vNormal);
                        
                        // Water color
                        vec3 waterColor = mix(deepColor, midColor, 0.5);
                        
                        // Fresnel
                        float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), 3.0);
                        
                        // Sky reflection
                        vec3 skyColor = mix(skyColorHorizon, skyColorTop, 0.3);
                        
                        // Specular
                        vec3 halfDir = normalize(sunDirection + viewDir);
                        float spec = pow(max(dot(normal, halfDir), 0.0), 256.0);
                        
                        vec3 finalColor = mix(waterColor, skyColor, fresnel * 0.6);
                        finalColor += sunColor * spec * 0.8;
                        
                        gl_FragColor = vec4(finalColor, 0.95);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0;
            scene.add(water);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createDetailedShip(color, isPlayer, team) {
            const group = new THREE.Group();
            const teamColor = new THREE.Color(team === 'red' ? 0x8b0000 : 0x1c3d5a);
            
            // Photorealistic naval ship materials
            const hullGray = new THREE.Color(0x4a5258);
            const darkGray = new THREE.Color(0x2d3236);
            const deckWood = new THREE.Color(0x6b4423);
            const metalDark = new THREE.Color(0x1a1c1e);
            const rust = new THREE.Color(0x5a3d2b);
            
            // PBR-like materials for realism
            const hullMaterial = new THREE.MeshPhongMaterial({ 
                color: hullGray, 
                shininess: 25,
                specular: 0x222222,
                flatShading: false
            });
            
            const armoredMaterial = new THREE.MeshPhongMaterial({ 
                color: darkGray, 
                shininess: 45,
                specular: 0x333333
            });
            
            const deckMaterial = new THREE.MeshPhongMaterial({ 
                color: deckWood, 
                shininess: 8,
                specular: 0x111111
            });
            
            const metalMaterial = new THREE.MeshPhongMaterial({ 
                color: metalDark, 
                shininess: 60,
                specular: 0x444444
            });

            // === MAIN HULL - Realistic warship shape ===
            // Lower hull (underwater portion - anti-fouling paint red/black)
            const lowerHullShape = new THREE.Shape();
            lowerHullShape.moveTo(-20, 0);
            lowerHullShape.quadraticCurveTo(-18, 3, -14, 4);
            lowerHullShape.lineTo(18, 4);
            lowerHullShape.quadraticCurveTo(24, 3, 28, 0);
            lowerHullShape.quadraticCurveTo(24, -3, 18, -4);
            lowerHullShape.lineTo(-14, -4);
            lowerHullShape.quadraticCurveTo(-18, -3, -20, 0);
            
            const lowerHullGeo = new THREE.ExtrudeGeometry(lowerHullShape, { 
                depth: 5, bevelEnabled: true, bevelThickness: 0.8, bevelSize: 0.8, bevelSegments: 3 
            });
            const lowerHullMat = new THREE.MeshPhongMaterial({ 
                color: 0x2a1515, shininess: 15, specular: 0x111111
            });
            const lowerHull = new THREE.Mesh(lowerHullGeo, lowerHullMat);
            lowerHull.rotation.x = Math.PI / 2;
            lowerHull.position.y = -2.5;
            lowerHull.castShadow = true;
            lowerHull.receiveShadow = true;
            group.add(lowerHull);

            // Upper hull 
            const upperHullShape = new THREE.Shape();
            upperHullShape.moveTo(-18, 0);
            upperHullShape.quadraticCurveTo(-16, 4.5, -12, 5);
            upperHullShape.lineTo(20, 5);
            upperHullShape.quadraticCurveTo(26, 4, 30, 0);
            upperHullShape.quadraticCurveTo(26, -4, 20, -5);
            upperHullShape.lineTo(-12, -5);
            upperHullShape.quadraticCurveTo(-16, -4.5, -18, 0);
            
            const upperHullGeo = new THREE.ExtrudeGeometry(upperHullShape, { 
                depth: 6, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 2 
            });
            const upperHull = new THREE.Mesh(upperHullGeo, hullMaterial);
            upperHull.rotation.x = Math.PI / 2;
            upperHull.position.y = 2.5;
            upperHull.castShadow = true;
            upperHull.receiveShadow = true;
            group.add(upperHull);

            // Hull plating lines (welded seams)
            for (let i = -16; i <= 24; i += 8) {
                const seamGeo = new THREE.BoxGeometry(0.15, 6, 10.5);
                const seamMat = new THREE.MeshPhongMaterial({ color: 0x252525, shininess: 10 });
                const seam = new THREE.Mesh(seamGeo, seamMat);
                seam.position.set(i, 2, 0);
                group.add(seam);
            }
            
            // Rust streaks (weathering detail)
            for (let i = 0; i < 8; i++) {
                const rustGeo = new THREE.PlaneGeometry(0.3, 2 + Math.random() * 3);
                const rustMat = new THREE.MeshBasicMaterial({ 
                    color: rust, 
                    transparent: true, 
                    opacity: 0.3 + Math.random() * 0.3,
                    side: THREE.DoubleSide
                });
                const rustStreak = new THREE.Mesh(rustGeo, rustMat);
                rustStreak.position.set(
                    -15 + Math.random() * 40,
                    1 + Math.random() * 3,
                    (Math.random() > 0.5 ? 5.1 : -5.1)
                );
                group.add(rustStreak);
            }

            // Waterline stripe
            const waterlineGeo = new THREE.BoxGeometry(52, 0.4, 10.2);
            const waterlineMat = new THREE.MeshPhongMaterial({ color: teamColor });
            const waterline = new THREE.Mesh(waterlineGeo, waterlineMat);
            waterline.position.set(4, 0, 0);
            group.add(waterline);

            // === BOW (Front) Details ===
            // Bow wave cutter
            const bowGeo = new THREE.ConeGeometry(2, 8, 4);
            const bowMat = new THREE.MeshPhongMaterial({ color: hullGray });
            const bow = new THREE.Mesh(bowGeo, bowMat);
            bow.rotation.z = -Math.PI / 2;
            bow.position.set(32, 2, 0);
            bow.castShadow = true;
            group.add(bow);

            // Anchor housings
            for (let z of [-3.5, 3.5]) {
                const anchorHouseGeo = new THREE.BoxGeometry(2, 3, 1.5);
                const anchorHouse = new THREE.Mesh(anchorHouseGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                anchorHouse.position.set(22, 4, z);
                group.add(anchorHouse);
                
                // Anchor chain holes
                const chainHoleGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 8);
                const chainHole = new THREE.Mesh(chainHoleGeo, new THREE.MeshPhongMaterial({ color: 0x000000 }));
                chainHole.rotation.x = Math.PI / 2;
                chainHole.position.set(22, 3.5, z > 0 ? z + 0.8 : z - 0.8);
                group.add(chainHole);
            }

            // === MAIN DECK ===
            const deckGeo = new THREE.BoxGeometry(48, 0.8, 9);
            const deckMat = new THREE.MeshPhongMaterial({ color: deckWood, shininess: 10 });
            const deck = new THREE.Mesh(deckGeo, deckMat);
            deck.position.set(4, 5.4, 0);
            deck.receiveShadow = true;
            group.add(deck);

            // Deck planking detail
            for (let i = -20; i <= 26; i += 1.5) {
                const plankGeo = new THREE.BoxGeometry(0.08, 0.1, 8.5);
                const plankMat = new THREE.MeshPhongMaterial({ color: 0x3d2817 });
                const plank = new THREE.Mesh(plankGeo, plankMat);
                plank.position.set(i, 5.9, 0);
                group.add(plank);
            }

            // === FORWARD MAIN TURRET (Triple 16-inch guns) ===
            // Turret barbette (armored base)
            const barbetteGeo = new THREE.CylinderGeometry(4.5, 5, 3, 16);
            const armorMat = new THREE.MeshPhongMaterial({ color: hullGray, shininess: 60 });
            const barbette1 = new THREE.Mesh(barbetteGeo, armorMat);
            barbette1.position.set(16, 7, 0);
            barbette1.castShadow = true;
            group.add(barbette1);

            // Turret housing
            const turretShape = new THREE.Shape();
            turretShape.moveTo(-3.5, -3);
            turretShape.lineTo(-3.5, 3);
            turretShape.quadraticCurveTo(4, 3.5, 5, 0);
            turretShape.quadraticCurveTo(4, -3.5, -3.5, -3);
            
            const turretGeo = new THREE.ExtrudeGeometry(turretShape, { 
                depth: 3.5, bevelEnabled: true, bevelThickness: 0.3, bevelSize: 0.3 
            });
            const turret1 = new THREE.Mesh(turretGeo, armorMat);
            turret1.rotation.x = Math.PI / 2;
            turret1.position.set(16, 9.5, 0);
            turret1.castShadow = true;
            group.add(turret1);

            // Main gun barrels (triple)
            for (let z of [-1.5, 0, 1.5]) {
                const barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 14, 12);
                const barrelMat = new THREE.MeshPhongMaterial({ color: metalDark, shininess: 80 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = -Math.PI / 2;
                barrel.position.set(26, 9.5, z);
                barrel.castShadow = true;
                group.add(barrel);
                
                // Barrel blast shields
                const shieldGeo = new THREE.CylinderGeometry(0.7, 0.8, 1, 12);
                const shield = new THREE.Mesh(shieldGeo, armorMat);
                shield.rotation.z = -Math.PI / 2;
                shield.position.set(20, 9.5, z);
                group.add(shield);
            }

            // === AFT MAIN TURRET ===
            const barbette2 = new THREE.Mesh(barbetteGeo.clone(), armorMat);
            barbette2.position.set(-8, 7, 0);
            barbette2.castShadow = true;
            group.add(barbette2);

            const turret2 = turret1.clone();
            turret2.position.set(-8, 9.5, 0);
            turret2.rotation.y = Math.PI;
            group.add(turret2);

            for (let z of [-1.5, 0, 1.5]) {
                const barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 14, 12);
                const barrel = new THREE.Mesh(barrelGeo, new THREE.MeshPhongMaterial({ color: metalDark, shininess: 80 }));
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(-18, 9.5, z);
                barrel.castShadow = true;
                group.add(barrel);
            }

            // === SUPERSTRUCTURE / BRIDGE ===
            // Main bridge structure
            const bridgeGeo1 = new THREE.BoxGeometry(10, 6, 7);
            const bridgeMat = new THREE.MeshPhongMaterial({ color: hullGray, shininess: 40 });
            const bridge = new THREE.Mesh(bridgeGeo1, bridgeMat);
            bridge.position.set(4, 9, 0);
            bridge.castShadow = true;
            group.add(bridge);

            // Bridge upper level
            const bridgeGeo2 = new THREE.BoxGeometry(7, 3, 5);
            const bridgeUpper = new THREE.Mesh(bridgeGeo2, bridgeMat);
            bridgeUpper.position.set(4, 13.5, 0);
            bridgeUpper.castShadow = true;
            group.add(bridgeUpper);

            // Bridge windows (armored slits)
            for (let i = -2; i <= 2; i++) {
                const windowGeo = new THREE.BoxGeometry(1.2, 0.4, 0.2);
                const windowMat = new THREE.MeshPhongMaterial({ 
                    color: 0x1a3050, emissive: 0x0a1525, emissiveIntensity: 0.5, shininess: 100 
                });
                const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                windowMesh.position.set(4 + i * 1.5, 14, 2.55);
                group.add(windowMesh);
            }

            // Fire control tower
            const towerGeo = new THREE.CylinderGeometry(1.5, 2, 8, 12);
            const tower = new THREE.Mesh(towerGeo, bridgeMat);
            tower.position.set(4, 19, 0);
            tower.castShadow = true;
            group.add(tower);

            // Rangefinder on top
            const rangefinderGeo = new THREE.BoxGeometry(8, 1.5, 1.5);
            const rangefinder = new THREE.Mesh(rangefinderGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
            rangefinder.position.set(4, 24, 0);
            group.add(rangefinder);

            // === FUNNELS (Smokestacks) ===
            const funnelGeo = new THREE.CylinderGeometry(1.8, 2.2, 10, 16);
            const funnelMat = new THREE.MeshPhongMaterial({ color: darkGray, shininess: 30 });
            
            const funnel1 = new THREE.Mesh(funnelGeo, funnelMat);
            funnel1.position.set(-1, 14, 0);
            funnel1.castShadow = true;
            group.add(funnel1);

            // Funnel cap
            const capGeo = new THREE.CylinderGeometry(2, 1.8, 1, 16);
            const cap1 = new THREE.Mesh(capGeo, funnelMat);
            cap1.position.set(-1, 19.5, 0);
            group.add(cap1);

            // Funnel band (team color)
            const bandGeo = new THREE.CylinderGeometry(2.0, 2.0, 1.5, 16);
            const bandMat = new THREE.MeshPhongMaterial({ color: teamColor });
            const band1 = new THREE.Mesh(bandGeo, bandMat);
            band1.position.set(-1, 17, 0);
            group.add(band1);

            // === SECONDARY ARMAMENT ===
            // 5-inch dual-purpose guns
            const positions = [
                { x: 10, z: 4.5 }, { x: 10, z: -4.5 },
                { x: 0, z: 4.5 }, { x: 0, z: -4.5 }
            ];
            
            for (let pos of positions) {
                // Gun mount
                const mountGeo = new THREE.CylinderGeometry(1.2, 1.4, 1.5, 12);
                const mount = new THREE.Mesh(mountGeo, armorMat);
                mount.position.set(pos.x, 6.5, pos.z);
                group.add(mount);
                
                // Gun shield
                const shieldGeo = new THREE.BoxGeometry(2, 1.5, 2.5);
                const shieldMesh = new THREE.Mesh(shieldGeo, armorMat);
                shieldMesh.position.set(pos.x + 0.5, 7.5, pos.z);
                group.add(shieldMesh);
                
                // Gun barrel
                const gunGeo = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
                const gun = new THREE.Mesh(gunGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
                gun.rotation.z = -Math.PI / 2;
                gun.position.set(pos.x + 4.5, 7.5, pos.z);
                group.add(gun);
            }

            // === ANTI-AIRCRAFT GUNS ===
            const aaPositions = [
                { x: 8, z: 3.5 }, { x: 8, z: -3.5 },
                { x: -4, z: 3.5 }, { x: -4, z: -3.5 }
            ];
            
            for (let pos of aaPositions) {
                // AA gun quad mount
                const aaMountGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.8, 8);
                const aaMount = new THREE.Mesh(aaMountGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                aaMount.position.set(pos.x, 12.5, pos.z);
                group.add(aaMount);
                
                // Quad barrels
                for (let dz of [-0.3, 0.3]) {
                    for (let dy of [-0.3, 0.3]) {
                        const aaGunGeo = new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6);
                        const aaGun = new THREE.Mesh(aaGunGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
                        aaGun.rotation.z = -Math.PI / 2 + 0.3;
                        aaGun.position.set(pos.x + 1.2, 12.8 + dy, pos.z + dz);
                        group.add(aaGun);
                    }
                }
            }

            // === MAST AND RADAR ===
            const mastGeo = new THREE.CylinderGeometry(0.25, 0.4, 18, 8);
            const mastMat = new THREE.MeshPhongMaterial({ color: darkGray });
            const mast = new THREE.Mesh(mastGeo, mastMat);
            mast.position.set(4, 32, 0);
            group.add(mast);

            // Radar array
            const radarGeo = new THREE.BoxGeometry(6, 0.4, 3);
            const radarMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const radar = new THREE.Mesh(radarGeo, radarMat);
            radar.position.set(4, 40, 0);
            group.add(radar);

            // Radar mesh
            const meshGeo = new THREE.PlaneGeometry(5.5, 2.5);
            const meshMat = new THREE.MeshBasicMaterial({ 
                color: 0x333333, side: THREE.DoubleSide, transparent: true, opacity: 0.7 
            });
            const radarMesh = new THREE.Mesh(meshGeo, meshMat);
            radarMesh.position.set(4, 40.3, 0);
            group.add(radarMesh);

            // Yardarms
            const yardGeo = new THREE.CylinderGeometry(0.1, 0.1, 10, 6);
            const yard = new THREE.Mesh(yardGeo, mastMat);
            yard.rotation.z = Math.PI / 2;
            yard.position.set(4, 35, 0);
            group.add(yard);

            // === NAVIGATION LIGHTS ===
            const lightGeo = new THREE.SphereGeometry(0.4, 8, 8);
            
            // Port (red) and starboard (green) lights
            const portColor = isPlayer ? 0x00ff88 : 0xff0000;
            const starboardColor = isPlayer ? 0x00ff88 : 0x00ff00;
            
            const portLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: portColor }));
            portLight.position.set(6, 13, -3.5);
            group.add(portLight);
            
            const starboardLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: starboardColor }));
            starboardLight.position.set(6, 13, 3.5);
            group.add(starboardLight);

            // Masthead light
            const mastheadLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            mastheadLight.position.set(4, 41, 0);
            group.add(mastheadLight);

            // === PLAYER INDICATOR ===
            if (isPlayer) {
                const glowGeo = new THREE.TorusGeometry(12, 0.6, 8, 32);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88, transparent: true, opacity: 0.5
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = Math.PI / 2;
                glow.position.y = 1;
                group.add(glow);

                const spotlight = new THREE.PointLight(0x00ff88, 1.5, 60);
                spotlight.position.set(0, 20, 0);
                group.add(spotlight);
            }

            // === TEAM FLAG ===
            const flagPoleGeo = new THREE.CylinderGeometry(0.08, 0.08, 6, 6);
            const flagPole = new THREE.Mesh(flagPoleGeo, mastMat);
            flagPole.position.set(-17, 8, 0);
            group.add(flagPole);

            const flagGeo = new THREE.PlaneGeometry(4, 2.5);
            const flagMat = new THREE.MeshPhongMaterial({ 
                color: team === 'red' ? 0xff3333 : 0x3366ff, side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(-17, 10.5, 2);
            group.add(flag);

            // === PROPELLER GUARDS (stern) ===
            for (let z of [-2.5, 2.5]) {
                const guardGeo = new THREE.BoxGeometry(3, 1.5, 0.3);
                const guard = new THREE.Mesh(guardGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                guard.position.set(-18, 0, z);
                group.add(guard);
            }

            // Rudder
            const rudderGeo = new THREE.BoxGeometry(0.5, 4, 2);
            const rudder = new THREE.Mesh(rudderGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
            rudder.position.set(-19, -1, 0);
            group.add(rudder);

            return group;
        }

        // Unique ship designs for every ship in the shop
        function createShipByDesign(color, isPlayer, team, shipData) {
            if (!shipData || !isPlayer) {
                return createDetailedShip(color, isPlayer, team);
            }
            
            const group = new THREE.Group();
            const shipId = shipData.id;
            
            // Generate unique colors based on ship ID hash
            function hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }
            
            const hash = hashCode(shipId);
            const hue1 = (hash % 360) / 360;
            const hue2 = ((hash * 7) % 360) / 360;
            const hue3 = ((hash * 13) % 360) / 360;
            
            // Create colors from hash
            const hullColor = new THREE.Color().setHSL(hue1, 0.4, 0.25);
            const accentColor = new THREE.Color().setHSL(hue2, 0.7, 0.5);
            const glowColor = new THREE.Color().setHSL(hue3, 0.9, 0.6);
            
            const hullMat = new THREE.MeshPhongMaterial({ color: hullColor, shininess: 30 });
            const accentMat = new THREE.MeshPhongMaterial({ color: accentColor, shininess: 60 });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 40 });
            const glowMat = new THREE.MeshBasicMaterial({ color: glowColor });
            
            // Ship parameters from stats
            const healthScale = 0.6 + (shipData.health / 150) * 0.8;
            const speedScale = 0.7 + shipData.speed * 0.3;
            const damageScale = 0.8 + (shipData.damage - 1) * 0.3;
            
            // Unique hull shape parameters based on hash
            const bowLength = 8 + (hash % 20);
            const hullWidth = 4 + (hash % 6);
            const sternWidth = 3 + ((hash >> 4) % 4);
            const hullCurve = 2 + ((hash >> 8) % 4);
            
            // Build unique hull
            const hullShape = new THREE.Shape();
            hullShape.moveTo(-20, 0);
            hullShape.quadraticCurveTo(-18, hullCurve, -12, hullWidth);
            hullShape.lineTo(bowLength, hullWidth * 0.9);
            hullShape.quadraticCurveTo(bowLength + 10, hullWidth * 0.5, bowLength + 15, 0);
            hullShape.quadraticCurveTo(bowLength + 10, -hullWidth * 0.5, bowLength, -hullWidth * 0.9);
            hullShape.lineTo(-12, -hullWidth);
            hullShape.quadraticCurveTo(-18, -hullCurve, -20, 0);
            
            const hullGeo = new THREE.ExtrudeGeometry(hullShape, { 
                depth: 5 * healthScale, 
                bevelEnabled: true, 
                bevelThickness: 0.5, 
                bevelSize: 0.5 
            });
            const hull = new THREE.Mesh(hullGeo, hullMat);
            hull.rotation.x = Math.PI / 2;
            hull.position.y = 2;
            group.add(hull);
            
            // Deck
            const deckGeo = new THREE.BoxGeometry(bowLength + 18, 0.5, hullWidth * 1.8);
            const deckMat = new THREE.MeshPhongMaterial({ color: 0x4a3a2a, shininess: 10 });
            const deck = new THREE.Mesh(deckGeo, deckMat);
            deck.position.set(bowLength/2 - 5, 5 * healthScale, 0);
            group.add(deck);
            
            // === SUPERSTRUCTURE - unique per ship ===
            const bridgeStyle = hash % 5;
            const bridgeHeight = 4 + ((hash >> 3) % 5);
            const bridgeWidth = 4 + ((hash >> 5) % 4);
            
            if (bridgeStyle === 0) {
                // Box bridge
                const bridgeGeo = new THREE.BoxGeometry(8, bridgeHeight, bridgeWidth);
                const bridge = new THREE.Mesh(bridgeGeo, accentMat);
                bridge.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                group.add(bridge);
            } else if (bridgeStyle === 1) {
                // Cylinder tower
                const towerGeo = new THREE.CylinderGeometry(bridgeWidth/2, bridgeWidth/2 + 1, bridgeHeight, 8);
                const tower = new THREE.Mesh(towerGeo, accentMat);
                tower.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                group.add(tower);
            } else if (bridgeStyle === 2) {
                // Stepped bridge
                for (let i = 0; i < 3; i++) {
                    const stepGeo = new THREE.BoxGeometry(8 - i*2, bridgeHeight/3, bridgeWidth - i);
                    const step = new THREE.Mesh(stepGeo, accentMat);
                    step.position.set(3, 5 * healthScale + bridgeHeight/3 * (i + 0.5), 0);
                    group.add(step);
                }
            } else if (bridgeStyle === 3) {
                // Angled bridge
                const bridgeGeo = new THREE.BoxGeometry(10, bridgeHeight, bridgeWidth);
                const bridge = new THREE.Mesh(bridgeGeo, accentMat);
                bridge.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                bridge.rotation.z = 0.15;
                group.add(bridge);
            } else {
                // Dome bridge
                const domeGeo = new THREE.SphereGeometry(bridgeWidth, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const dome = new THREE.Mesh(domeGeo, accentMat);
                dome.position.set(3, 5 * healthScale, 0);
                group.add(dome);
            }
            
            // === TURRETS - number based on damage stat ===
            const numTurrets = Math.max(1, Math.min(4, Math.floor(shipData.damage)));
            const turretPositions = [
                [bowLength - 2, 0],
                [-8, 0],
                [bowLength - 8, -3],
                [bowLength - 8, 3]
            ];
            
            const turretStyle = (hash >> 10) % 3;
            for (let i = 0; i < numTurrets; i++) {
                const [tx, tz] = turretPositions[i];
                
                if (turretStyle === 0) {
                    // Round turret
                    const turretGeo = new THREE.CylinderGeometry(2, 2.5, 2, 8);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                } else if (turretStyle === 1) {
                    // Square turret
                    const turretGeo = new THREE.BoxGeometry(3, 2, 3);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                } else {
                    // Hexagonal turret
                    const turretGeo = new THREE.CylinderGeometry(2, 2.3, 2, 6);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                }
                
                // Gun barrels - number varies
                const numBarrels = 1 + ((hash >> (12 + i)) % 3);
                const barrelSpacing = 1.2;
                const startZ = -(numBarrels - 1) * barrelSpacing / 2;
                
                for (let b = 0; b < numBarrels; b++) {
                    const barrelLen = 8 + damageScale * 4;
                    const barrelGeo = new THREE.CylinderGeometry(0.3 + damageScale * 0.2, 0.4 + damageScale * 0.2, barrelLen, 8);
                    const barrel = new THREE.Mesh(barrelGeo, accentMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.set(tx + barrelLen/2 + 2, 6 * healthScale, tz + startZ + b * barrelSpacing);
                    group.add(barrel);
                }
            }
            
            // === MAST/ANTENNA - unique styles ===
            const mastStyle = (hash >> 15) % 4;
            
            if (mastStyle === 0) {
                // Traditional mast
                const mastGeo = new THREE.CylinderGeometry(0.2, 0.3, 15, 6);
                const mast = new THREE.Mesh(mastGeo, darkMat);
                mast.position.set(0, 12 * healthScale, 0);
                group.add(mast);
                
                const radarGeo = new THREE.BoxGeometry(6, 0.3, 2);
                const radar = new THREE.Mesh(radarGeo, accentMat);
                radar.position.set(0, 18 * healthScale, 0);
                group.add(radar);
            } else if (mastStyle === 1) {
                // Antenna array
                for (let i = 0; i < 3; i++) {
                    const antGeo = new THREE.CylinderGeometry(0.1, 0.15, 8 + i * 3, 4);
                    const ant = new THREE.Mesh(antGeo, darkMat);
                    ant.position.set(-2 + i * 2, 10 * healthScale + (8 + i * 3)/2, 0);
                    group.add(ant);
                }
            } else if (mastStyle === 2) {
                // Dome radar
                const domeGeo = new THREE.SphereGeometry(2, 12, 12);
                const dome = new THREE.Mesh(domeGeo, accentMat);
                dome.position.set(0, 14 * healthScale, 0);
                group.add(dome);
                
                const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 6, 8);
                const pole = new THREE.Mesh(poleGeo, darkMat);
                pole.position.set(0, 10 * healthScale, 0);
                group.add(pole);
            } else {
                // Lattice tower
                for (let i = 0; i < 4; i++) {
                    const legGeo = new THREE.CylinderGeometry(0.15, 0.2, 12, 4);
                    const leg = new THREE.Mesh(legGeo, darkMat);
                    const angle = (i / 4) * Math.PI * 2;
                    leg.position.set(Math.cos(angle) * 1.5, 12 * healthScale, Math.sin(angle) * 1.5);
                    group.add(leg);
                }
            }
            
            // === DECORATIVE ELEMENTS based on category ===
            const category = shipData.category;
            
            if (category === 'speed') {
                // Speed fins
                for (let z of [-hullWidth - 1, hullWidth + 1]) {
                    const finGeo = new THREE.BoxGeometry(15, 0.3, 2);
                    const fin = new THREE.Mesh(finGeo, accentMat);
                    fin.position.set(-5, 3, z);
                    fin.rotation.z = z > 0 ? 0.1 : -0.1;
                    group.add(fin);
                }
                // Engine glows
                for (let z of [-2, 0, 2]) {
                    const engineGeo = new THREE.SphereGeometry(0.8, 8, 8);
                    const engine = new THREE.Mesh(engineGeo, glowMat);
                    engine.position.set(-22, 3, z);
                    group.add(engine);
                }
            } else if (category === 'tank') {
                // Armor plates
                for (let x = -10; x <= 15; x += 5) {
                    const plateGeo = new THREE.BoxGeometry(4, 3, hullWidth * 2 + 2);
                    const plateMat = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 20 });
                    const plate = new THREE.Mesh(plateGeo, plateMat);
                    plate.position.set(x, 6 * healthScale, 0);
                    group.add(plate);
                }
                // Shield generators
                for (let z of [-hullWidth - 2, hullWidth + 2]) {
                    const shieldGeo = new THREE.SphereGeometry(1.5, 10, 10);
                    const shield = new THREE.Mesh(shieldGeo, glowMat);
                    shield.position.set(5, 8 * healthScale, z);
                    group.add(shield);
                }
            } else if (category === 'damage') {
                // Weapon glow strips
                for (let z of [-hullWidth - 0.5, hullWidth + 0.5]) {
                    const stripGeo = new THREE.BoxGeometry(bowLength + 20, 0.4, 0.4);
                    const strip = new THREE.Mesh(stripGeo, glowMat);
                    strip.position.set(0, 4, z);
                    group.add(strip);
                }
                // Extra weapon pods
                for (let x of [-12, 15]) {
                    const podGeo = new THREE.BoxGeometry(3, 2, 2);
                    const pod = new THREE.Mesh(podGeo, accentMat);
                    pod.position.set(x, 5 * healthScale, hullWidth + 2);
                    group.add(pod);
                    const pod2 = pod.clone();
                    pod2.position.z = -hullWidth - 2;
                    group.add(pod2);
                }
            } else if (category === 'special') {
                // Unique rotating rings
                const ringGeo = new THREE.TorusGeometry(4, 0.3, 8, 24);
                const ring1 = new THREE.Mesh(ringGeo, glowMat);
                ring1.position.set(3, 12 * healthScale, 0);
                ring1.rotation.x = Math.PI / 4;
                group.add(ring1);
                
                const ring2 = new THREE.Mesh(ringGeo.clone(), glowMat);
                ring2.position.set(3, 12 * healthScale, 0);
                ring2.rotation.x = -Math.PI / 4;
                group.add(ring2);
                
                // Energy orbs
                for (let i = 0; i < 4; i++) {
                    const orbGeo = new THREE.SphereGeometry(1, 8, 8);
                    const orb = new THREE.Mesh(orbGeo, glowMat);
                    const angle = (i / 4) * Math.PI * 2 + (hash % 100) / 100;
                    orb.position.set(3 + Math.cos(angle) * 6, 8 * healthScale, Math.sin(angle) * 6);
                    group.add(orb);
                }
            } else {
                // Balanced - subtle enhancements
                const detailGeo = new THREE.BoxGeometry(2, 1, hullWidth * 2);
                const detail = new THREE.Mesh(detailGeo, accentMat);
                detail.position.set(-15, 5, 0);
                group.add(detail);
            }
            
            // === EXHAUST/PROPULSION unique to each ship ===
            const exhaustStyle = (hash >> 18) % 3;
            const numExhausts = 1 + ((hash >> 20) % 4);
            
            for (let i = 0; i < numExhausts; i++) {
                const zPos = (i - (numExhausts - 1) / 2) * 2;
                
                if (exhaustStyle === 0) {
                    const exGeo = new THREE.CylinderGeometry(0.6, 0.8, 2, 8);
                    const ex = new THREE.Mesh(exGeo, darkMat);
                    ex.rotation.z = Math.PI / 2;
                    ex.position.set(-21, 3, zPos);
                    group.add(ex);
                    
                    const glowGeo = new THREE.SphereGeometry(0.5, 6, 6);
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.position.set(-22, 3, zPos);
                    group.add(glow);
                } else if (exhaustStyle === 1) {
                    const exGeo = new THREE.BoxGeometry(2, 1.5, 1.5);
                    const ex = new THREE.Mesh(exGeo, darkMat);
                    ex.position.set(-21, 3, zPos);
                    group.add(ex);
                } else {
                    const exGeo = new THREE.ConeGeometry(0.8, 3, 6);
                    const ex = new THREE.Mesh(exGeo, glowMat);
                    ex.rotation.z = -Math.PI / 2;
                    ex.position.set(-22, 3, zPos);
                    group.add(ex);
                }
            }
            
            // === PLAYER INDICATOR (common) ===
            const lightGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const playerLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
            playerLight.position.set(bowLength, 8, 3);
            group.add(playerLight);
            
            const playerLight2 = new THREE.Mesh(lightGeo.clone(), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
            playerLight2.position.set(bowLength, 8, -3);
            group.add(playerLight2);
            
            // Player glow ring
            const glowRingGeo = new THREE.TorusGeometry(18, 0.5, 8, 32);
            const glowRingMat = new THREE.MeshBasicMaterial({ color: glowColor, transparent: true, opacity: 0.4 });
            const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 1;
            group.add(glowRing);
            
            // Player spotlight
            const spotlight = new THREE.PointLight(glowColor, 1.5, 60);
            spotlight.position.set(0, 15, 0);
            group.add(spotlight);
            
            // Team flag
            const flagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 6);
            const flagPole = new THREE.Mesh(flagPoleGeo, darkMat);
            flagPole.position.set(-18, 6, 0);
            group.add(flagPole);
            
            const flagGeo = new THREE.PlaneGeometry(4, 2.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: team === 'red' ? 0xff3333 : 0x3366ff, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(-18, 8, 2);
            group.add(flag);
            
            return group;
        }

        function createWake(ship) {
            const wakeGroup = new THREE.Group();
            
            // Realistic bow wave with foam spray
            const bowWaveMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.7 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec2 vUv;
                    
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    void main() {
                        float n = noise(vUv * 20.0 + time);
                        float fade = 1.0 - vUv.x;
                        float edge = smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.8, vUv.y);
                        float foam = smoothstep(0.3, 0.7, n) * fade * edge;
                        vec3 color = mix(vec3(0.7, 0.85, 0.9), vec3(1.0), foam);
                        gl_FragColor = vec4(color, opacity * fade * edge);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // V-shaped bow wake with spray
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < 12; i++) {
                    const width = 2 + i * 1.2;
                    const length = 4 + i * 0.5;
                    const geometry = new THREE.PlaneGeometry(length, width, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xeeffff,
                        transparent: true,
                        opacity: Math.max(0.05, 0.5 - i * 0.035),
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const wakePart = new THREE.Mesh(geometry, material);
                    wakePart.rotation.x = -Math.PI / 2;
                    wakePart.position.set(-18 - i * 5, 0.4, side * (3 + i * 2));
                    wakePart.rotation.z = side * (0.25 + i * 0.02);
                    wakeGroup.add(wakePart);
                }
            }
            
            // Stern turbulence with churning water
            for (let i = 0; i < 20; i++) {
                const size = 3 + i * 0.4;
                const geometry = new THREE.CircleGeometry(size, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: i < 5 ? 0xffffff : 0xd0e8f0,
                    transparent: true,
                    opacity: Math.max(0.02, 0.35 - i * 0.015),
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const foam = new THREE.Mesh(geometry, material);
                foam.rotation.x = -Math.PI / 2;
                foam.position.set(-22 - i * 6, 0.3, (Math.random() - 0.5) * (4 + i * 0.5));
                wakeGroup.add(foam);
            }
            
            // Propeller wash bubbles
            for (let i = 0; i < 8; i++) {
                const geo = new THREE.SphereGeometry(1 + Math.random(), 8, 8);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4 - i * 0.04
                });
                const bubble = new THREE.Mesh(geo, mat);
                bubble.position.set(-20 - i * 3, -0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 3);
                bubble.userData = { phase: Math.random() * Math.PI * 2 };
                wakeGroup.add(bubble);
            }

            return wakeGroup;
        }

        function createSmoke(x, y, z) {
            const particles = [];
            // Realistic billowing smoke with turbulence
            for (let i = 0; i < 8; i++) {
                const size = 1.0 + Math.random() * 1.5;
                const geometry = new THREE.SphereGeometry(size, 12, 12);
                
                // Varying smoke colors from dark to light gray
                const grayValue = 0.15 + Math.random() * 0.25;
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(grayValue, grayValue, grayValue),
                    transparent: true,
                    opacity: 0.6,
                    depthWrite: false
                });
                
                const particle = new THREE.Mesh(geometry, material);
                const angle = Math.random() * Math.PI * 2;
                const spread = Math.random() * 1.5;
                particle.position.set(
                    x + Math.cos(angle) * spread,
                    y + i * 1.5 + Math.random(),
                    z + Math.sin(angle) * spread
                );
                particle.userData = {
                    vx: (Math.random() - 0.5) * 0.15 + 0.08, // Wind drift
                    vy: 0.4 + Math.random() * 0.3,
                    vz: (Math.random() - 0.5) * 0.15,
                    life: 1,
                    turbulence: Math.random() * 0.1,
                    rotSpeed: (Math.random() - 0.5) * 0.02,
                    originalSize: size
                };
                scene.add(particle);
                particles.push(particle);
            }
            return particles;
        }

        class Ship {
            constructor(team, isPlayer = false, shipData = null) {
                this.team = team;
                this.isPlayer = isPlayer;
                this.shipData = shipData;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 0.15 + Math.random() * 0.1;
                this.turnSpeed = 0.02;
                this.fireRate = 90 + Math.random() * 60;
                this.fireCooldown = Math.random() * this.fireRate;
                this.velocity = { x: 0, z: 0 };
                this.rotation = 0;
                this.smokeTimer = 0;
                this.smokeParticles = [];
                this.recoilOffset = 0;
                this.accuracy = 0.05; // Default accuracy (can be overridden for AI)

                let color;
                if (team === 'red') {
                    color = 0x8B0000;
                    this.x = -WORLD_SIZE/2 + 30 + Math.random() * 60;
                    this.z = -WORLD_SIZE/2 + 50 + Math.random() * (WORLD_SIZE - 100);
                    this.rotation = 0;
                } else {
                    color = isPlayer ? 0x006644 : 0x000066;
                    this.x = WORLD_SIZE/2 - 30 - Math.random() * 60;
                    this.z = -WORLD_SIZE/2 + 50 + Math.random() * (WORLD_SIZE - 100);
                    this.rotation = Math.PI;
                }

                // Use category-specific design for player, standard for AI
                if (isPlayer && shipData) {
                    this.mesh = createShipByDesign(color, isPlayer, team, shipData);
                } else {
                    this.mesh = createDetailedShip(color, isPlayer, team);
                }
                this.mesh.position.set(this.x, 0, this.z);
                this.mesh.rotation.y = this.rotation;
                scene.add(this.mesh);

                this.wake = createWake(this);
                scene.add(this.wake);

                this.targetZ = this.z;
                this.targetRotation = this.rotation;
                this.bobOffset = Math.random() * Math.PI * 2;

                // Health bar
                const healthBarBg = new THREE.Mesh(
                    new THREE.PlaneGeometry(12, 1.5),
                    new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
                );
                healthBarBg.position.y = 25;
                healthBarBg.rotation.y = Math.PI / 2;
                this.mesh.add(healthBarBg);

                const healthBar = new THREE.Mesh(
                    new THREE.PlaneGeometry(11.5, 1.2),
                    new THREE.MeshBasicMaterial({ color: 0x44ff44, side: THREE.DoubleSide })
                );
                healthBar.position.y = 25;
                healthBar.position.x = 0.1;
                healthBar.rotation.y = Math.PI / 2;
                this.healthBar = healthBar;
                this.mesh.add(healthBar);
            }

            // Calculate wave height at a given position (matching shader Gerstner waves)
            calculateWaveHeight(x, z, time, windDir) {
                const gerstnerWave = (px, pz, steepness, wavelength, dirX, dirY, phase) => {
                    const k = 6.28318 / wavelength;
                    const c = Math.sqrt(9.81 / k);
                    const len = Math.sqrt(dirX * dirX + dirY * dirY);
                    const dx = dirX / len, dy = dirY / len;
                    const f = k * (dx * px + dy * pz - c * time * 0.4 + phase);
                    const a = steepness / k;
                    return a * Math.sin(f);
                };
                
                let height = 0;
                height += gerstnerWave(x, z, 0.25, 120.0, windDir.x, windDir.y, 0.0);
                height += gerstnerWave(x, z, 0.18, 80.0, windDir.x * 1.05 + 0.1, windDir.y - 0.05, 0.8);
                height += gerstnerWave(x, z, 0.12, 50.0, -windDir.y * 0.9, windDir.x * 0.9, 1.6);
                height += gerstnerWave(x, z, 0.08, 28.0, windDir.x * 0.95 - 0.1, windDir.y + 0.15, 2.4);
                height += gerstnerWave(x, z, 0.06, 18.0, -windDir.x * 0.8, -windDir.y * 0.8, 3.2);
                
                return height;
            }

            update(delta) {
                if (this.isPlayer) {
                    this.updatePlayer(delta);
                } else {
                    this.updateAI(delta);
                }

                // Update smoke
                this.smokeTimer += delta;
                if (this.smokeTimer > 0.3 && this.speed > 0 && this.smokeParticles.length < MAX_SMOKE_PARTICLES) {
                    const worldPos = new THREE.Vector3(-6, 13, 0);
                    worldPos.applyMatrix4(this.mesh.matrixWorld);
                    this.smokeParticles.push(...createSmoke(worldPos.x, worldPos.y, worldPos.z));
                    this.smokeTimer = 0;
                }

                // Update smoke particles
                this.smokeParticles = this.smokeParticles.filter(p => {
                    p.position.x += p.userData.vx;
                    p.position.y += p.userData.vy;
                    p.position.z += p.userData.vz;
                    p.userData.life -= delta * 0.5;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.setScalar(1 + (1 - p.userData.life) * 2);
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });
                
                // Fire effects when damaged
                if (this.onFire) {
                    if (!this.fireParticles) this.fireParticles = [];
                    if (Math.random() > 0.7) {
                        const firePos = new THREE.Vector3(
                            (Math.random() - 0.5) * 15,
                            5 + Math.random() * 5,
                            (Math.random() - 0.5) * 4
                        );
                        firePos.applyMatrix4(this.mesh.matrixWorld);
                        
                        const fireGeo = new THREE.SphereGeometry(0.4 + Math.random() * 0.4, 6, 6);
                        const fireMat = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xff4400 : 0xff8800,
                            transparent: true,
                            opacity: 0.9
                        });
                        const fire = new THREE.Mesh(fireGeo, fireMat);
                        fire.position.copy(firePos);
                        fire.userData = { vy: 1 + Math.random() * 2, life: 0.6 + Math.random() * 0.4 };
                        scene.add(fire);
                        this.fireParticles.push(fire);
                    }
                    
                    // Update fire particles
                    this.fireParticles = this.fireParticles.filter(f => {
                        f.position.y += f.userData.vy * delta * 3;
                        f.userData.life -= delta * 2;
                        f.material.opacity = f.userData.life;
                        f.scale.multiplyScalar(0.98);
                        if (f.userData.life <= 0) {
                            disposeMesh(f);
                            return false;
                        }
                        return true;
                    });
                }

                // Update wake
                this.wake.position.copy(this.mesh.position);
                this.wake.rotation.y = this.mesh.rotation.y;

                // Ocean bobbing with realistic wave interaction
                this.bobOffset += delta * 2;
                const time = clock.getElapsedTime();
                
                // Calculate wave height at ship position (matching the shader's Gerstner waves)
                const windDir = { x: 0.7, y: 0.3 };
                const waveHeight = this.calculateWaveHeight(this.x, this.z, time, windDir);
                
                // Smooth transition to wave height
                this.currentWaveHeight = this.currentWaveHeight || 0;
                this.currentWaveHeight += (waveHeight - this.currentWaveHeight) * 0.1;
                
                // Calculate wave slope for realistic pitch and roll
                const sampleDist = 5;
                const heightFront = this.calculateWaveHeight(this.x + Math.cos(this.rotation) * sampleDist, 
                                                             this.z - Math.sin(this.rotation) * sampleDist, time, windDir);
                const heightBack = this.calculateWaveHeight(this.x - Math.cos(this.rotation) * sampleDist, 
                                                            this.z + Math.sin(this.rotation) * sampleDist, time, windDir);
                const heightLeft = this.calculateWaveHeight(this.x + Math.sin(this.rotation) * sampleDist, 
                                                            this.z + Math.cos(this.rotation) * sampleDist, time, windDir);
                const heightRight = this.calculateWaveHeight(this.x - Math.sin(this.rotation) * sampleDist, 
                                                             this.z - Math.cos(this.rotation) * sampleDist, time, windDir);
                
                const pitchAngle = Math.atan2(heightFront - heightBack, sampleDist * 2) * 0.5;
                let rollAngle = Math.atan2(heightRight - heightLeft, sampleDist * 2) * 0.5;
                
                // Add listing when critically damaged
                if (this.listing) {
                    rollAngle += this.listAngle;
                }

                // No turn heel - keep ships stable
                
                this.mesh.position.set(this.x, this.currentWaveHeight + 1, this.z);
                this.mesh.rotation.set(pitchAngle, this.rotation, rollAngle);
                
                // Scale wake based on speed
                const currentSpeed = Math.hypot(this.velocity?.x || 0, this.velocity?.z || 0);
                const wakeScale = 0.3 + currentSpeed * 1.5;
                this.wake.scale.set(wakeScale, 1, wakeScale);
                this.wake.visible = currentSpeed > 0.02;
            }

            updatePlayer(delta) {
                // Player ship - instant response controls (no momentum)
                const moveSpeed = 0.5 * this.speed;
                const turnSpeed = 0.03;

                // Movement - only when keys pressed
                let moving = false;
                if (keys['w'] || keys['arrowup']) {
                    this.x += Math.cos(this.rotation) * moveSpeed;
                    this.z -= Math.sin(this.rotation) * moveSpeed;
                    moving = true;
                }
                if (keys['s'] || keys['arrowdown']) {
                    this.x -= Math.cos(this.rotation) * moveSpeed * 0.5;
                    this.z += Math.sin(this.rotation) * moveSpeed * 0.5;
                    moving = true;
                }

                // Turning - instant response
                if (keys['q'] || keys['a'] || keys['arrowleft']) {
                    this.rotation += turnSpeed;
                }
                if (keys['e'] || keys['d'] || keys['arrowright']) {
                    this.rotation -= turnSpeed;
                }

                // Keep in bounds
                if (this.x < -WORLD_SIZE/2 + 20) { this.x = -WORLD_SIZE/2 + 20; }
                if (this.x > WORLD_SIZE/2 - 20) { this.x = WORLD_SIZE/2 - 20; }
                if (this.z < -WORLD_SIZE/2 + 20) { this.z = -WORLD_SIZE/2 + 20; }
                if (this.z > WORLD_SIZE/2 - 20) { this.z = WORLD_SIZE/2 - 20; }

                // Manual fire with realistic reload
                this.fireCooldown -= delta * 60;
                if (keys[' '] && this.fireCooldown <= 0) {
                    this.fire();
                    this.fireCooldown = this.fireRate;
                }
            }

            updateAI(delta) {
                // Find target
                const target = this.findTarget();
                
                if (target) {
                    // Calculate angle to target
                    const dx = target.x - this.x;
                    const dz = target.z - this.z;
                    const targetAngle = Math.atan2(-dz, dx);
                    
                    // Rotate towards target instantly
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    const turnRate = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), this.turnSpeed);
                    this.rotation += turnRate;
                }

                // Move forward at speed (no momentum)
                const moveSpeed = this.speed * 0.8;
                this.x += Math.cos(this.rotation) * moveSpeed;
                this.z -= Math.sin(this.rotation) * moveSpeed;

                // Keep in bounds
                this.x = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.x));
                this.z = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.z));

                // Fire
                this.fireCooldown -= delta * 60;
                if (this.fireCooldown <= 0 && target) {
                    const dist = Math.hypot(target.x - this.x, target.z - this.z);
                    if (dist < 150) {
                        this.fire();
                        this.fireCooldown = this.fireRate;
                    }
                }
            }

            fire() {
                // Fire straight forward based on ship rotation
                const angle = -this.rotation;
                
                // Fire from center barrel
                const gunPos = new THREE.Vector3(33, 9.5, 0);
                gunPos.applyMatrix4(this.mesh.matrixWorld);
                
                const damage = 25 * (this.damageMultiplier || 1);
                bullets.push(new Bullet(gunPos.x, gunPos.z, angle, this.team, this.accuracy, damage));
                if (this.isPlayer) updateQuestProgress('shotsFired', 1);
                this.createMuzzleFlash(gunPos);
                this.createMuzzleSmoke(gunPos);
            }

            createMuzzleFlash(pos) {
                // Bright initial flash
                const flashGeometry = new THREE.SphereGeometry(3, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff44,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.set(pos.x, pos.y, pos.z);
                scene.add(flash);
                
                // Outer fireball
                const fireballGeo = new THREE.SphereGeometry(5, 8, 8);
                const fireballMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const fireball = new THREE.Mesh(fireballGeo, fireballMat);
                fireball.position.set(pos.x, pos.y, pos.z);
                scene.add(fireball);
                
                // Animate flash
                let flashLife = 1.0;
                const animateFlash = () => {
                    flashLife -= 0.15;
                    flash.scale.setScalar(1 + (1 - flashLife) * 2);
                    flash.material.opacity = flashLife;
                    fireball.scale.setScalar(1 + (1 - flashLife) * 3);
                    fireball.material.opacity = flashLife * 0.6;
                    if (flashLife > 0) {
                        requestAnimationFrame(animateFlash);
                    } else {
                        disposeMesh(flash);
                        disposeMesh(fireball);
                    }
                };
                animateFlash();
            }
            
            createMuzzleSmoke(pos) {
                // Smoke ring expanding outward
                for (let i = 0; i < 12; i++) {
                    const smokeGeo = new THREE.SphereGeometry(1 + Math.random(), 6, 6);
                    const smokeMat = new THREE.MeshBasicMaterial({
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.6
                    });
                    const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                    smoke.position.set(pos.x, pos.y, pos.z);
                    
                    const spreadAngle = Math.random() * Math.PI * 2;
                    const spreadSpeed = 0.3 + Math.random() * 0.4;
                    smoke.userData = {
                        vx: Math.cos(spreadAngle) * spreadSpeed + Math.cos(-this.rotation) * 0.5,
                        vy: 0.2 + Math.random() * 0.3,
                        vz: Math.sin(spreadAngle) * spreadSpeed + Math.sin(-this.rotation) * 0.5,
                        life: 1.5 + Math.random() * 0.5
                    };
                    scene.add(smoke);
                    
                    const animateSmoke = () => {
                        smoke.userData.life -= 0.02;
                        smoke.userData.vy *= 0.98;
                        smoke.position.x += smoke.userData.vx;
                        smoke.position.y += smoke.userData.vy;
                        smoke.position.z += smoke.userData.vz;
                        smoke.userData.vx *= 0.96;
                        smoke.userData.vz *= 0.96;
                        smoke.scale.multiplyScalar(1.03);
                        smoke.material.opacity = smoke.userData.life * 0.4;
                        if (smoke.userData.life > 0) {
                            requestAnimationFrame(animateSmoke);
                        } else {
                            disposeMesh(smoke);
                        }
                    };
                    animateSmoke();
                }
            }

            findTarget() {
                let closest = null;
                let closestDist = Infinity;
                for (const ship of ships) {
                    if (ship.team !== this.team && ship.health > 0) {
                        const dist = Math.hypot(ship.x - this.x, ship.z - this.z);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = ship;
                        }
                    }
                }
                return closest;
            }

            takeDamage(amount) {
                this.health -= amount;
                const healthPercent = Math.max(0, this.health / this.maxHealth);
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.z = -5.75 * (1 - healthPercent);
                
                // Color changes based on damage
                if (this.health > 60) {
                    this.healthBar.material.color.setHex(0x44ff44);
                } else if (this.health > 30) {
                    this.healthBar.material.color.setHex(0xffaa00);
                } else {
                    this.healthBar.material.color.setHex(0xff4444);
                }
                
                // Start fires when heavily damaged
                if (this.health < 50 && !this.onFire) {
                    this.onFire = true;
                    this.fireParticles = [];
                }
                
                // Ship listing when critically damaged
                if (this.health < 30 && !this.listing) {
                    this.listing = true;
                    this.listAngle = (Math.random() > 0.5 ? 1 : -1) * 0.15;
                }

                if (this.health <= 0) {
                    explosions.push(new Explosion(this.x, this.z));
                    scene.remove(this.mesh);
                    scene.remove(this.wake);
                    for (const p of this.smokeParticles) {
                        scene.remove(p);
                    }
                    if (this.fireParticles) {
                        for (const p of this.fireParticles) {
                            scene.remove(p);
                        }
                    }
                    if (this.team === 'red') {
                        blueScore++;
                        document.getElementById('blueScore').textContent = blueScore;
                    } else {
                        redScore++;
                        document.getElementById('redScore').textContent = redScore;
                    }
                }
            }
        }

        class Bullet {
            constructor(x, z, angle, team, accuracy = 0.05, damage = 25) {
                this.x = x;
                this.z = z;
                this.y = 8;
                this.team = team;
                this.damage = damage;
                
                // Realistic ballistics with accuracy spread (lower = more accurate)
                const spread = (Math.random() - 0.5) * accuracy;
                this.angle = angle + spread;
                
                // Shell velocity components (realistic arc)
                const muzzleVelocity = 2.5;
                const elevationAngle = 0.15 + Math.random() * 0.05; // Gun elevation
                this.speed = muzzleVelocity * Math.cos(elevationAngle);
                this.vy = muzzleVelocity * Math.sin(elevationAngle) * 8;
                this.gravity = -0.12;
                
                // Wind effect
                this.windX = (Math.random() - 0.5) * 0.02;
                this.windZ = (Math.random() - 0.5) * 0.02;
                
                // Air resistance
                this.dragCoeff = 0.998;

                // Shell mesh - large naval artillery shell
                const geometry = new THREE.CylinderGeometry(0.8, 0.8, 5.0, 12);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x554433,
                    emissive: team === 'red' ? 0xff2200 : 0x0033ff,
                    emissiveIntensity: 0.5,
                    shininess: 80
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.z = Math.PI / 2;
                this.mesh.rotation.y = -this.angle;
                this.mesh.position.set(x, this.y, z);
                scene.add(this.mesh);

                // Smoke trail
                this.trailParticles = [];
                this.trailTimer = 0;
            }

            update(delta) {
                // Add trail particles
                this.trailTimer += delta;
                if (this.trailTimer > 0.03 && this.y > 2 && this.trailParticles.length < MAX_TRAIL_PARTICLES) {
                    const trailGeo = new THREE.SphereGeometry(0.15, 4, 4);
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.4
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.position.set(this.x, this.y, this.z);
                    trail.userData = { life: 1.0 };
                    scene.add(trail);
                    this.trailParticles.push(trail);
                    this.trailTimer = 0;
                }
                
                // Fade trail particles
                this.trailParticles = this.trailParticles.filter(p => {
                    p.userData.life -= delta * 2;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.multiplyScalar(1.02);
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });

                // Physics with air resistance and wind
                this.vy += this.gravity;
                this.speed *= this.dragCoeff;
                
                this.y += this.vy;
                this.x += Math.cos(this.angle) * this.speed + this.windX;
                this.z += Math.sin(this.angle) * this.speed + this.windZ;

                // Update shell orientation to follow trajectory
                const velocityAngle = Math.atan2(this.vy, this.speed);
                this.mesh.rotation.x = velocityAngle;
                this.mesh.position.set(this.x, Math.max(0.5, this.y), this.z);

                // Hit water - create realistic splash
                if (this.y < 0) {
                    this.createSplash();
                    this.hit = true;
                }
            }

            createSplash() {
                // Water column
                const columnGeo = new THREE.CylinderGeometry(0.5, 2, 8, 8);
                const columnMat = new THREE.MeshBasicMaterial({
                    color: 0xaaddff,
                    transparent: true,
                    opacity: 0.7
                });
                const column = new THREE.Mesh(columnGeo, columnMat);
                column.position.set(this.x, 4, this.z);
                scene.add(column);
                
                // Animate water column
                let columnLife = 1.0;
                const animateColumn = () => {
                    columnLife -= 0.03;
                    column.scale.y = 1 + (1 - columnLife) * 2;
                    column.position.y = 4 + (1 - columnLife) * 4;
                    column.material.opacity = columnLife * 0.7;
                    if (columnLife > 0) {
                        requestAnimationFrame(animateColumn);
                    } else {
                        disposeMesh(column);
                    }
                };
                animateColumn();
                
                // Spray particles (reduced count)
                for (let i = 0; i < 8; i++) {
                    const geometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xcceeFF,
                        transparent: true,
                        opacity: 0.8
                    });
                    const splash = new THREE.Mesh(geometry, material);
                    splash.position.set(this.x, 0.5, this.z);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    splash.userData = {
                        vx: Math.cos(angle) * speed,
                        vy: 2 + Math.random() * 4,
                        vz: Math.sin(angle) * speed,
                        life: 1
                    };
                    scene.add(splash);
                    
                    const animateSplash = () => {
                        splash.position.x += splash.userData.vx * 0.1;
                        splash.position.y += splash.userData.vy * 0.1;
                        splash.position.z += splash.userData.vz * 0.1;
                        splash.userData.vy -= 0.2;
                        splash.userData.life -= 0.025;
                        splash.material.opacity = splash.userData.life * 0.8;
                        
                        if (splash.userData.life > 0 && splash.position.y > 0) {
                            requestAnimationFrame(animateSplash);
                        } else {
                            disposeMesh(splash);
                        }
                    };
                    animateSplash();
                }
                
                // Ripple ring
                const ringGeo = new THREE.RingGeometry(1, 2, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(this.x, 0.2, this.z);
                scene.add(ring);
                
                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.3;
                    ring.scale.set(ringScale, ringScale, 1);
                    ring.material.opacity -= 0.02;
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        disposeMesh(ring);
                    }
                };
                animateRing();
            }

            isOffScreen() {
                return Math.abs(this.x) > WORLD_SIZE || Math.abs(this.z) > WORLD_SIZE || this.y < -10;
            }

            remove() {
                disposeMesh(this.mesh);
                for (const p of this.trailParticles) {
                    disposeMesh(p);
                }
            }
        }

        class Explosion {
            constructor(x, z) {
                this.particles = [];
                this.fires = [];
                this.shockwaves = [];
                this.x = x;
                this.z = z;
                
                // Multiple dynamic lights for realistic illumination
                const primaryLight = new THREE.PointLight(0xffaa33, 15, 200);
                primaryLight.position.set(x, 20, z);
                scene.add(primaryLight);
                
                const secondaryLight = new THREE.PointLight(0xff6600, 8, 100);
                secondaryLight.position.set(x, 10, z);
                scene.add(secondaryLight);
                
                // Animate lights
                let lightLife = 1.0;
                const fadeLight = () => {
                    lightLife -= 0.03;
                    primaryLight.intensity = 15 * Math.pow(lightLife, 2);
                    secondaryLight.intensity = 8 * lightLife;
                    if (lightLife > 0) {
                        requestAnimationFrame(fadeLight);
                    } else {
                        scene.remove(primaryLight);
                        scene.remove(secondaryLight);
                    }
                };
                fadeLight();
                
                // Multi-stage blast (inner hot core, outer fireball)
                // Inner white-hot core
                const coreGeo = new THREE.SphereGeometry(3, 16, 16);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0xffffee,
                    transparent: true,
                    opacity: 1.0
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                core.position.set(x, 10, z);
                scene.add(core);
                this.particles.push(core);
                core.userData = { life: 1, isCore: true, expandRate: 2.5 };
                
                // Orange fireball layer
                const fireballGeo = new THREE.SphereGeometry(6, 20, 20);
                const fireballMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.85
                });
                const fireball = new THREE.Mesh(fireballGeo, fireballMat);
                fireball.position.set(x, 10, z);
                scene.add(fireball);
                this.particles.push(fireball);
                fireball.userData = { life: 1, isBlast: true, expandRate: 1.8 };
                
                // Outer red layer
                const outerGeo = new THREE.SphereGeometry(8, 16, 16);
                const outerMat = new THREE.MeshBasicMaterial({
                    color: 0xcc3300,
                    transparent: true,
                    opacity: 0.6
                });
                const outer = new THREE.Mesh(outerGeo, outerMat);
                outer.position.set(x, 10, z);
                scene.add(outer);
                this.particles.push(outer);
                outer.userData = { life: 1, isBlast: true, expandRate: 1.5 };
                
                // Volumetric fire particles
                for (let i = 0; i < 35; i++) {
                    const size = 1.0 + Math.random() * 2.5;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const isDebris = Math.random() > 0.7;
                    
                    let color;
                    if (isDebris) {
                        const gray = 0.1 + Math.random() * 0.2;
                        color = new THREE.Color(gray, gray, gray);
                    } else {
                        // Fire gradient from white to red
                        const t = Math.random();
                        if (t < 0.2) color = new THREE.Color(1.0, 1.0, 0.9);
                        else if (t < 0.4) color = new THREE.Color(1.0, 0.9, 0.4);
                        else if (t < 0.6) color = new THREE.Color(1.0, 0.6, 0.1);
                        else if (t < 0.8) color = new THREE.Color(1.0, 0.3, 0.0);
                        else color = new THREE.Color(0.8, 0.1, 0.0);
                    }
                    
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = Math.random() * Math.PI * 0.5;
                    const speed = 3 + Math.random() * 8;
                    
                    particle.position.set(
                        x + Math.cos(angle) * Math.random() * 4,
                        8 + Math.random() * 6,
                        z + Math.sin(angle) * Math.random() * 4
                    );
                    particle.userData = {
                        vx: Math.cos(angle) * Math.cos(elevation) * speed,
                        vy: Math.sin(elevation) * speed + 2,
                        vz: Math.sin(angle) * Math.cos(elevation) * speed,
                        life: 0.7 + Math.random() * 0.5,
                        rotSpeed: (Math.random() - 0.5) * 0.5,
                        isDebris: isDebris,
                        drag: 0.96 + Math.random() * 0.03,
                        originalSize: size
                    };
                    scene.add(particle);
                    this.particles.push(particle);
                }
                
                // Flying debris (metal shards)
                for (let i = 0; i < 12; i++) {
                    const geo = new THREE.BoxGeometry(
                        0.3 + Math.random() * 0.5,
                        0.1 + Math.random() * 0.2,
                        0.5 + Math.random() * 1.0
                    );
                    const mat = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        shininess: 60
                    });
                    const debris = new THREE.Mesh(geo, mat);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 8 + Math.random() * 15;
                    debris.position.set(x, 8 + Math.random() * 5, z);
                    debris.userData = {
                        vx: Math.cos(angle) * speed,
                        vy: 5 + Math.random() * 10,
                        vz: Math.sin(angle) * speed,
                        life: 2,
                        rotX: (Math.random() - 0.5) * 0.3,
                        rotY: (Math.random() - 0.5) * 0.3,
                        rotZ: (Math.random() - 0.5) * 0.3,
                        isDebris: true,
                        isMetal: true,
                        drag: 0.99
                    };
                    scene.add(debris);
                    this.particles.push(debris);
                }

                // Smoke column
                this.smokeTimer = 0;
                this.smokeDuration = 4;
                this.smokeActive = true;
                
                // Secondary explosions with delays
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        if (!this.smokeActive) return;
                        const secX = x + (Math.random() - 0.5) * 20;
                        const secZ = z + (Math.random() - 0.5) * 20;
                        
                        // Secondary fireball
                        const secGeo = new THREE.SphereGeometry(4, 12, 12);
                        const secMat = new THREE.MeshBasicMaterial({
                            color: 0xff8844,
                            transparent: true,
                            opacity: 0.9
                        });
                        const secondary = new THREE.Mesh(secGeo, secMat);
                        secondary.position.set(secX, 6 + Math.random() * 6, secZ);
                        secondary.userData = { life: 0.6, isBlast: true, expandRate: 1.3 };
                        scene.add(secondary);
                        this.particles.push(secondary);
                        
                        // Secondary light flash
                        const secLight = new THREE.PointLight(0xff6600, 8, 60);
                        secLight.position.set(secX, 10, secZ);
                        scene.add(secLight);
                        setTimeout(() => scene.remove(secLight), 200);
                    }, 150 + i * 250 + Math.random() * 150);
                }
                
                // Persistent fires
                for (let i = 0; i < 6; i++) {
                    const fireX = x + (Math.random() - 0.5) * 12;
                    const fireZ = z + (Math.random() - 0.5) * 12;
                    this.fires.push({ x: fireX, z: fireZ, life: 2.5 + Math.random() * 2.5 });
                }

                // Shockwave ring
                const ringGeo = new THREE.RingGeometry(3, 5, 48);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(x, 0.5, z);
                scene.add(ring);
                
                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.8;
                    ring.scale.set(ringScale, ringScale, 1);
                    ring.material.opacity -= 0.02;
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        disposeMesh(ring);
                    }
                };
                animateRing();
                
                // Water splash column
                for (let i = 0; i < 15; i++) {
                    const splashGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.8, 8, 8);
                    const splashMat = new THREE.MeshBasicMaterial({
                        color: 0xaaccdd,
                        transparent: true,
                        opacity: 0.7
                    });
                    const splash = new THREE.Mesh(splashGeo, splashMat);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 3 + Math.random() * 8;
                    splash.position.set(x + Math.cos(angle) * dist, 1, z + Math.sin(angle) * dist);
                    splash.userData = {
                        vx: Math.cos(angle) * 2,
                        vy: 8 + Math.random() * 12,
                        vz: Math.sin(angle) * 2,
                        life: 1,
                        drag: 0.98,
                        isSplash: true
                    };
                    scene.add(splash);
                    this.particles.push(splash);
                }
            }

            update(delta) {
                // Update all particles
                for (const p of this.particles) {
                    if (p.userData.isCore) {
                        // White hot core expands and fades quickly
                        p.scale.multiplyScalar(1 + p.userData.expandRate * delta);
                        p.userData.life -= delta * 4;
                        p.material.opacity = Math.max(0, p.userData.life);
                    } else if (p.userData.isBlast) {
                        // Fireball expansion
                        const expand = 1 + (p.userData.expandRate || 1.5) * delta;
                        p.scale.multiplyScalar(expand);
                        p.userData.life -= delta * 2.5;
                        p.material.opacity = Math.max(0, p.userData.life * 0.9);
                    } else if (p.userData.vx !== undefined) {
                        // Physics-based particles
                        p.position.x += p.userData.vx * delta * 6;
                        p.position.y += p.userData.vy * delta * 6;
                        p.position.z += p.userData.vz * delta * 6;
                        
                        // Gravity
                        p.userData.vy -= delta * 18;
                        
                        // Drag
                        p.userData.vx *= p.userData.drag;
                        p.userData.vz *= p.userData.drag;
                        
                        // Rotation
                        if (p.userData.isMetal) {
                            p.rotation.x += p.userData.rotX;
                            p.rotation.y += p.userData.rotY;
                            p.rotation.z += p.userData.rotZ;
                        } else if (p.userData.rotSpeed) {
                            p.rotation.x += p.userData.rotSpeed;
                            p.rotation.y += p.userData.rotSpeed * 0.7;
                        }
                        
                        // Fade
                        const fadeRate = p.userData.isDebris ? 0.3 : (p.userData.isSplash ? 1.5 : 1.0);
                        p.userData.life -= delta * fadeRate;
                        if (p.material.opacity !== undefined) {
                            p.material.opacity = Math.max(0, p.userData.life);
                        }
                        
                        // Water collision
                        if (p.position.y < 0.5 && !p.userData.hitWater) {
                            p.userData.hitWater = true;
                            p.userData.vy *= -0.3;
                            p.userData.vx *= 0.3;
                            p.userData.vz *= 0.3;
                            p.position.y = 0.5;
                            
                            // Water splash effect for debris
                            if (p.userData.isDebris && !p.userData.isSplash) {
                                p.userData.life = Math.min(p.userData.life, 0.5);
                            }
                        }
                        
                        // Fire particles shrink
                        if (!p.userData.isDebris && !p.userData.isSplash && p.userData.life < 0.5) {
                            p.scale.multiplyScalar(0.97);
                        }
                    } else {
                        // Rising smoke
                        p.position.y += (p.userData.vy || 1) * delta;
                        if (p.userData.vy) p.userData.vy *= 0.99;
                        p.scale.multiplyScalar(1.008);
                        p.userData.life -= delta * 0.25;
                        p.material.opacity = Math.max(0, p.userData.life * 0.5);
                    }
                }
                
                // Generate smoke column
                this.smokeTimer += delta;
                if (this.smokeActive && this.smokeDuration > 0 && this.particles.length < MAX_EXPLOSION_PARTICLES) {
                    this.smokeDuration -= delta;
                    if (this.smokeTimer > 0.08) {
                        const size = 2.5 + Math.random() * 3;
                        const smokeGeo = new THREE.SphereGeometry(size, 8, 8);
                        const gray = 0.08 + Math.random() * 0.15;
                        const smokeMat = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(gray, gray, gray),
                            transparent: true,
                            opacity: 0.6,
                            depthWrite: false
                        });
                        const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                        smoke.position.set(
                            this.x + (Math.random() - 0.5) * 10,
                            6 + Math.random() * 12,
                            this.z + (Math.random() - 0.5) * 10
                        );
                        smoke.userData = {
                            vy: 2 + Math.random() * 2,
                            life: 1
                        };
                        scene.add(smoke);
                        this.particles.push(smoke);
                        this.smokeTimer = 0;
                    }
                }
                
                // Cleanup dead particles
                this.particles = this.particles.filter(p => {
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });
                
                // Update fires (create fire particles - with limit)
                for (const fire of this.fires) {
                    fire.life -= delta;
                    if (fire.life > 0 && Math.random() > 0.8 && this.particles.length < MAX_EXPLOSION_PARTICLES) {
                        const flameGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 4, 4);
                        const flameMat = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xff4400 : 0xff8800,
                            transparent: true,
                            opacity: 0.8
                        });
                        const flame = new THREE.Mesh(flameGeo, flameMat);
                        flame.position.set(
                            fire.x + (Math.random() - 0.5) * 2,
                            0.5 + Math.random() * 2,
                            fire.z + (Math.random() - 0.5) * 2
                        );
                        flame.userData = { vy: 2 + Math.random() * 2, life: 0.5 };
                        scene.add(flame);
                        this.particles.push(flame);
                    }
                }
            }

            isDone() {
                return this.particles.every(p => p.userData.life <= 0) && this.fires.every(f => f.life <= 0);
            }

            remove() {
                this.smokeActive = false;
                for (const p of this.particles) {
                    disposeMesh(p);
                }
                this.particles = [];
            }
        }

        function spawnShips() {
            // Difficulty settings: 5v5 for all, harder = better AI (faster fire, speed, accuracy)
            const difficultySettings = {
                1: { enemies: 5, allies: 4, fireRateMult: 1.5, speedMult: 0.7, accuracy: 0.08, playerHealth: 150 },  // Easy
                2: { enemies: 5, allies: 4, fireRateMult: 1.2, speedMult: 0.85, accuracy: 0.06, playerHealth: 120 },  // Medium
                3: { enemies: 5, allies: 4, fireRateMult: 1.0, speedMult: 1.0, accuracy: 0.04, playerHealth: 100 },  // Hard
                4: { enemies: 5, allies: 4, fireRateMult: 0.7, speedMult: 1.2, accuracy: 0.025, playerHealth: 80 },  // Extreme
                5: { enemies: 5, allies: 4, fireRateMult: 0.5, speedMult: 1.4, accuracy: 0.015, playerHealth: 60 }   // Nightmare
            };
            
            const settings = difficultySettings[difficulty];
            
            for (let i = 0; i < settings.enemies; i++) {
                const ship = new Ship('red');
                ship.fireRate *= settings.fireRateMult;
                ship.speed *= settings.speedMult;
                ship.accuracy = settings.accuracy;
                ships.push(ship);
            }
            for (let i = 0; i < settings.allies; i++) {
                ships.push(new Ship('blue'));
            }
            
            // Apply selected ship stats to player
            const shipStats = getSelectedShipStats();
            playerShip = new Ship('blue', true, shipStats);
            const baseHealth = settings.playerHealth * (shipStats.health / 100);
            playerShip.health = baseHealth;
            playerShip.maxHealth = baseHealth;
            playerShip.speed *= shipStats.speed;
            playerShip.fireRate /= shipStats.fireRate; // Lower = faster
            playerShip.damageMultiplier = shipStats.damage;
            playerShip.accuracy = 0.05 / shipStats.accuracy; // Lower = more accurate
            ships.push(playerShip);
        }

        function checkCollisions() {
            // Bullet-ship collisions
            for (const bullet of bullets) {
                if (bullet.hit) continue;
                for (const ship of ships) {
                    if (bullet.team !== ship.team && ship.health > 0) {
                        const dist = Math.hypot(bullet.x - ship.x, bullet.z - ship.z);
                        if (dist < 12 && bullet.y < 15 && bullet.y > 0) {
                            const wasAlive = ship.health > 0;
                            ship.takeDamage(bullet.damage);
                            bullet.hit = true;
                            
                            // Track quest progress for player hits
                            if (bullet.team === 'blue' && playerShip) {
                                updateQuestProgress('shotsHit', 1);
                                updateQuestProgress('damageDealt', Math.round(bullet.damage));
                                if (wasAlive && ship.health <= 0) {
                                    updateQuestProgress('kills', 1);
                                }
                            }
                            
                            // Hit effect
                            const hitFlash = new THREE.PointLight(0xffaa00, 3, 30);
                            hitFlash.position.set(bullet.x, bullet.y, bullet.z);
                            scene.add(hitFlash);
                            setTimeout(() => scene.remove(hitFlash), 100);
                        }
                    }
                }
            }
            
            // Ship-ship collisions disabled - ships can pass through each other
        }

        let gameOver = false;
        let winner = null;

        function checkGameOver() {
            if (gameOver) return;
            
            const redAlive = ships.filter(s => s.team === 'red' && s.health > 0).length;
            const blueAlive = ships.filter(s => s.team === 'blue' && s.health > 0).length;
            
            if (redAlive === 0 && blueAlive > 0) {
                gameOver = true;
                winner = 'BLUE';
                if (playerShip && playerShip.health > 0) {
                    updateQuestProgress('survived', 1);
                }
                showVictoryScreen('BLUE TEAM WINS!', '#5599ff');
            } else if (blueAlive === 0 && redAlive > 0) {
                gameOver = true;
                winner = 'RED';
                showVictoryScreen('RED TEAM WINS!', '#ff5555');
            }
        }
        
        function showVictoryScreen(message, color) {
            const overlay = document.createElement('div');
            overlay.id = 'victoryOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            overlay.innerHTML = `
                <h1 style="color: ${color}; font-size: 4em; text-shadow: 0 0 30px ${color}; margin-bottom: 20px;">${message}</h1>
                <p style="color: #fff; font-size: 1.5em; margin-bottom: 30px;">Final Score - RED: ${redScore} | BLUE: ${blueScore}</p>
                <div style="display: flex; gap: 20px;">
                    <button onclick="restartGame()" style="
                        background: linear-gradient(180deg, #00d4ff, #0088aa);
                        border: none;
                        padding: 15px 40px;
                        font-size: 1.3em;
                        color: #fff;
                        border-radius: 25px;
                        cursor: pointer;
                    ">üîÑ PLAY AGAIN</button>
                    <button onclick="goToHomeScreen()" style="
                        background: linear-gradient(180deg, #ff9900, #cc6600);
                        border: none;
                        padding: 15px 40px;
                        font-size: 1.3em;
                        color: #fff;
                        border-radius: 25px;
                        cursor: pointer;
                    ">üè† HOME</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }
        
        function restartGame() {
            const overlay = document.getElementById('victoryOverlay');
            if (overlay) overlay.remove();
            gameOver = false;
            winner = null;
            resetGame();
        }
        
        function goToHomeScreen() {
            const overlay = document.getElementById('victoryOverlay');
            if (overlay) overlay.remove();
            gameOver = false;
            winner = null;
            gameStarted = false;
            paused = true;
            
            // Clean up current game
            for (const ship of ships) {
                scene.remove(ship.mesh);
                scene.remove(ship.wake);
                for (const p of ship.smokeParticles) scene.remove(p);
            }
            for (const bullet of bullets) bullet.remove();
            for (const exp of explosions) exp.remove();
            ships = [];
            bullets = [];
            explosions = [];
            redScore = 0;
            blueScore = 0;
            document.getElementById('redScore').textContent = '0';
            document.getElementById('blueScore').textContent = '0';
            
            // Show home screen
            document.getElementById('homeScreen').style.display = 'flex';
            document.getElementById('money').textContent = money.toLocaleString();
            initQuests();
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            const delta = Math.min(clock.getDelta(), 0.1);

            if (!paused) {
                // Update water
                water.material.uniforms.time.value += delta;

                // Update ships
                for (const ship of ships) {
                    if (ship.health > 0) {
                        ship.update(delta);
                    }
                }

                // Update bullets
                for (const bullet of bullets) {
                    bullet.update(delta);
                }

                // Update explosions
                for (const exp of explosions) {
                    exp.update(delta);
                }

                checkCollisions();

                // Clean up bullets
                const aliveBullets = [];
                for (const b of bullets) {
                    if (b.isOffScreen() || b.hit) {
                        b.remove();
                    } else {
                        aliveBullets.push(b);
                    }
                }
                bullets = aliveBullets;

                // Clean up ships
                ships = ships.filter(s => s.health > 0);

                // Clean up explosions
                const aliveExplosions = [];
                for (const e of explosions) {
                    if (e.isDone()) {
                        e.remove();
                    } else {
                        aliveExplosions.push(e);
                    }
                }
                explosions = aliveExplosions;

                checkGameOver();

                // Camera follows player
                if (playerShip && playerShip.health > 0) {
                    const targetCamX = playerShip.x - Math.cos(playerShip.rotation) * 60;
                    const targetCamZ = playerShip.z + Math.sin(playerShip.rotation) * 60 + 80;
                    
                    camera.position.x += (targetCamX - camera.position.x) * 0.05;
                    camera.position.z += (targetCamZ - camera.position.z) * 0.05;
                    camera.position.y = 50;
                    
                    // Apply recoil camera shake
                    if (playerShip.recoilOffset > 0) {
                        camera.position.x += (Math.random() - 0.5) * playerShip.recoilOffset;
                        camera.position.y += (Math.random() - 0.5) * playerShip.recoilOffset * 0.5;
                        camera.position.z += (Math.random() - 0.5) * playerShip.recoilOffset;
                        playerShip.recoilOffset *= 0.85;
                        if (playerShip.recoilOffset < 0.1) playerShip.recoilOffset = 0;
                    }
                    
                    camera.lookAt(playerShip.x, 5, playerShip.z);
                }
            }

            renderer.render(scene, camera);
        }

        function resetGame() {
            for (const ship of ships) {
                scene.remove(ship.mesh);
                scene.remove(ship.wake);
                for (const p of ship.smokeParticles) scene.remove(p);
            }
            for (const bullet of bullets) bullet.remove();
            for (const exp of explosions) exp.remove();

            ships = [];
            bullets = [];
            explosions = [];
            redScore = 0;
            blueScore = 0;
            document.getElementById('redScore').textContent = '0';
            document.getElementById('blueScore').textContent = '0';
            spawnShips();
        }

        function togglePause() {
            paused = !paused;
        }
        
        function setDifficulty(level) {
            difficulty = level;
            // Update button styles
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            const diffNames = ['', 'easy', 'medium', 'hard', 'extreme', 'nightmare'];
            document.querySelector(`.diff-btn.${diffNames[level]}`).classList.add('selected');
        }
        
        let gameStarted = false;
        
        function startGame() {
            document.getElementById('homeScreen').style.display = 'none';
            if (!gameStarted) {
                gameStarted = true;
                initQuests();
                updateQuestProgress('gamesPlayed', 1);
                spawnShips();
            }
            paused = false;
        }
        
        function showControls() {
            alert('CONTROLS:\\n\\nW / ‚Üë - Increase throttle\\nS / ‚Üì - Reverse throttle\\nA / ‚Üê - Turn left\\nD / ‚Üí - Turn right\\nSPACE - Fire main guns\\n\\nYour ship has GREEN navigation lights!');
        }

        init();
        gameLoop();
    </script>
</body>
</html>
