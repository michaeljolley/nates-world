<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAR SHIPS 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        h1 {
            color: #fff;
            text-shadow: 0 0 20px #00d4ff, 0 0 40px #00d4ff;
            margin: 20px 0;
            font-size: 2.5em;
            letter-spacing: 8px;
        }
        #scoreboard {
            display: flex;
            gap: 50px;
            margin: 10px 0;
            font-size: 1.5em;
        }
        .score {
            padding: 10px 30px;
            border-radius: 10px;
            font-weight: bold;
        }
        .red-score {
            background: rgba(255, 50, 50, 0.3);
            color: #ff5555;
            border: 2px solid #ff5555;
        }
        .blue-score {
            background: rgba(50, 150, 255, 0.3);
            color: #5599ff;
            border: 2px solid #5599ff;
        }
        #money-display {
            position: relative;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 10px 20px;
            color: #ffd700;
            font-size: 1.5em;
            font-weight: bold;
            margin: 10px auto;
        }
        #shop-btn, #quests-btn {
            background: linear-gradient(180deg, #ff9900, #cc6600);
            border: 2px solid #ffaa00;
            padding: 8px 20px;
            font-size: 1em;
            color: #fff;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
            pointer-events: auto;
        }
        #quests-btn {
            background: linear-gradient(180deg, #00d4ff, #0088aa);
            border-color: #00d4ff;
        }
        .top-left-buttons {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        .bottom-left-buttons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }
        .bottom-left-buttons button {
            background: linear-gradient(180deg, #cc3300, #990000);
            border: 2px solid #ff6600;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            color: white;
            border-radius: 8px;
        }
        .bottom-left-buttons button:hover {
            background: linear-gradient(180deg, #ff4400, #cc2200);
        }
        #shop-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #ff9900;
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            z-index: 2000;
            width: 90%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }
        #shop-panel h2 {
            color: #ff9900;
            text-align: center;
            margin-bottom: 10px;
        }
        .shop-tabs {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .shop-tab {
            background: rgba(255,255,255,0.1);
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            color: #aaa;
        }
        .shop-tab.active {
            background: #ff9900;
            border-color: #ff9900;
            color: #000;
        }
        .ship-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
        }
        .ship-card {
            background: rgba(255,255,255,0.05);
            border: 2px solid #444;
            border-radius: 10px;
            padding: 10px;
            text-align: center;
        }
        .ship-card.owned {
            border-color: #00ff66;
            background: rgba(0,255,100,0.1);
        }
        .ship-card.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 15px #00d4ff;
        }
        .ship-card .ship-name {
            font-weight: bold;
            color: #fff;
            font-size: 1.1em;
        }
        .ship-card .ship-price {
            color: #ffd700;
            margin: 5px 0;
        }
        .ship-card .ship-stats {
            font-size: 0.8em;
            color: #aaa;
            text-align: left;
        }
        .ship-card .buff {
            color: #00ff66;
        }
        .ship-card .debuff {
            color: #ff4444;
        }
        .ship-card button {
            margin-top: 8px;
            padding: 5px 15px;
            font-size: 0.9em;
        }
        .close-shop {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            cursor: pointer;
            color: #ff4444;
        }
        
        /* Team Panel Styles */
        #team-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 40, 0.95);
            border: 3px solid #44ddaa;
            border-radius: 15px;
            padding: 20px;
            color: #fff;
            z-index: 2000;
            width: 90%;
            max-width: 950px;
            max-height: 85vh;
            overflow-y: auto;
        }
        #team-panel h2 {
            color: #44ddaa;
            text-align: center;
            margin-bottom: 5px;
        }
        .team-subtitle {
            text-align: center;
            color: #88aacc;
            margin-bottom: 15px;
        }
        .close-team {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            cursor: pointer;
            color: #ff4444;
        }
        #team-members-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        .team-member-card {
            background: rgba(0, 50, 100, 0.4);
            border: 2px solid #446688;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .team-member-card:hover {
            border-color: #00d4ff;
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.2);
        }
        .team-member-card .member-role {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .team-member-card .member-name {
            color: #fff;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .team-member-card .member-personality {
            color: #88aacc;
            font-size: 0.85em;
            font-style: italic;
            margin-bottom: 12px;
            min-height: 2.5em;
        }
        .team-member-card .assigned-ship {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .team-member-card .ship-emoji {
            font-size: 1.8em;
        }
        .team-member-card .ship-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .team-member-card .assign-btn {
            background: linear-gradient(180deg, #0088ff, #0066cc);
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
        }
        .team-member-card .assign-btn:hover {
            background: linear-gradient(180deg, #00aaff, #0088ff);
        }
        #team-ship-selection {
            background: rgba(0, 30, 60, 0.5);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #335577;
        }
        #team-ship-selection h3 {
            color: #00d4ff;
            margin: 0 0 10px 0;
        }
        .back-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #446688;
            border-radius: 6px;
            padding: 6px 12px;
            color: #88aacc;
            cursor: pointer;
            margin-bottom: 15px;
        }
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        #team-ship-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 12px;
        }
        .team-ship-card {
            background: rgba(0, 50, 100, 0.4);
            border: 2px solid #446688;
            border-radius: 10px;
            padding: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        .team-ship-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.3);
        }
        .team-ship-card.assigned {
            border-color: #00ff88;
            background: rgba(0, 100, 50, 0.4);
        }
        .team-ship-card .ship-emoji-lg {
            font-size: 2em;
            margin-bottom: 5px;
        }
        @media (max-width: 800px) {
            #team-members-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .current-ship {
            text-align: center;
            color: #00d4ff;
            margin: 10px 0;
            font-size: 1.1em;
        }
        #quest-panel {
            display: none;
            position: absolute;
            top: 160px;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            padding: 15px;
            color: #fff;
            font-size: 0.9em;
            min-width: 220px;
            max-width: 260px;
            overflow-y: auto;
            z-index: 100;
        }
        #quest-panel h3 {
            color: #00d4ff;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #00d4ff;
            padding-bottom: 5px;
        }
        .quest-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 8px;
            margin-bottom: 8px;
        }
        .quest-item.completed {
            background: rgba(0, 255, 100, 0.2);
            border: 1px solid #00ff66;
        }
        .quest-name {
            font-weight: bold;
            color: #fff;
        }
        .quest-progress {
            color: #aaa;
            font-size: 0.85em;
            margin-top: 3px;
        }
        .quest-reward {
            color: #ffd700;
            font-size: 0.85em;
            margin-top: 3px;
        }
        @keyframes fadeOut {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        #controls {
            margin-top: 10px;
            pointer-events: auto;
        }
        button {
            background: linear-gradient(180deg, #00d4ff, #0088aa);
            border: none;
            padding: 10px 25px;
            font-size: 1em;
            color: #fff;
            border-radius: 20px;
            cursor: pointer;
            margin: 5px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.7);
        }
        #info {
            color: #aaa;
            font-size: 0.9em;
            margin-top: 5px;
        }
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, #0a1628 0%, #1a3a5c 50%, #0d2840 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #homeScreen h1 {
            font-size: 4em;
            color: #fff;
            text-shadow: 0 0 30px #00d4ff, 0 0 60px #00d4ff, 0 0 90px #0088ff;
            margin-bottom: 20px;
            letter-spacing: 12px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 30px #00d4ff, 0 0 60px #00d4ff; }
            to { text-shadow: 0 0 40px #00ffff, 0 0 80px #00ffff, 0 0 120px #0088ff; }
        }
        #homeScreen .subtitle {
            font-size: 1.5em;
            color: #88ccff;
            margin-bottom: 50px;
            letter-spacing: 4px;
        }
        #homeScreen .menu-btn {
            background: linear-gradient(180deg, #00d4ff, #0066aa);
            border: 2px solid #00ffff;
            padding: 20px 60px;
            font-size: 1.5em;
            color: #fff;
            border-radius: 30px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        #homeScreen .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.8);
            background: linear-gradient(180deg, #00ffff, #0088cc);
        }
        #homeScreen .menu-btn.secondary {
            background: transparent;
            border: 2px solid #5599ff;
            padding: 12px 40px;
            font-size: 1em;
        }
        #homeScreen .menu-btn.secondary:hover {
            background: rgba(85, 153, 255, 0.2);
            box-shadow: 0 0 20px rgba(85, 153, 255, 0.5);
        }
        #homeScreen .ship-silhouette {
            font-size: 8em;
            margin-bottom: 30px;
            filter: drop-shadow(0 0 20px #00d4ff);
        }
        #homeScreen .controls-info {
            position: absolute;
            bottom: 40px;
            color: #668899;
            font-size: 0.9em;
            text-align: center;
        }
        #homeScreen .controls-info span {
            color: #00d4ff;
            font-weight: bold;
        }
        #homeScreen .version {
            position: absolute;
            bottom: 15px;
            right: 20px;
            color: #445566;
            font-size: 0.8em;
        }
        #homeScreen .difficulty-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }
        #homeScreen .difficulty-label {
            color: #88ccff;
            font-size: 1.1em;
            margin-bottom: 15px;
            letter-spacing: 2px;
        }
        #homeScreen .difficulty-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        #homeScreen .diff-btn {
            background: rgba(0, 100, 150, 0.3);
            border: 2px solid #446688;
            padding: 10px 20px;
            font-size: 0.9em;
            color: #88aacc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        #homeScreen .diff-btn:hover {
            background: rgba(0, 150, 200, 0.4);
            border-color: #00d4ff;
            color: #fff;
        }
        #homeScreen .diff-btn.selected {
            background: linear-gradient(180deg, #00d4ff, #0066aa);
            border-color: #00ffff;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }
        #homeScreen .diff-btn.easy { border-color: #44aa44; }
        #homeScreen .diff-btn.easy.selected { background: linear-gradient(180deg, #44dd44, #228822); border-color: #66ff66; }
        #homeScreen .diff-btn.medium { border-color: #aaaa44; }
        #homeScreen .diff-btn.medium.selected { background: linear-gradient(180deg, #dddd44, #888822); border-color: #ffff66; }
        #homeScreen .diff-btn.hard { border-color: #dd8844; }
        #homeScreen .diff-btn.hard.selected { background: linear-gradient(180deg, #ff8844, #884422); border-color: #ffaa66; }
        #homeScreen .diff-btn.extreme { border-color: #dd4444; }
        #homeScreen .diff-btn.extreme.selected { background: linear-gradient(180deg, #ff4444, #882222); border-color: #ff6666; }
        #homeScreen .diff-btn.nightmare { border-color: #aa44aa; }
        #homeScreen .diff-btn.nightmare.selected { background: linear-gradient(180deg, #dd44dd, #662266); border-color: #ff66ff; }
        
        /* Cinematic vignette overlay */
        .vignette-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9999;
            background: radial-gradient(ellipse at center, transparent 35%, rgba(0,0,0,0.5) 100%);
        }
        
        /* Film grain effect - static for performance */
        .film-grain {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9998;
            opacity: 0.02;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
        
        /* Chromatic aberration overlay */
        .chromatic-aberration {
            display: none;
        }
        
        /* Lens dirt overlay */
        .lens-dirt {
            display: none;
        }
        
        /* Bloom glow effect */
        .bloom-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9995;
            mix-blend-mode: screen;
            opacity: 0.1;
            filter: blur(20px);
            background: radial-gradient(ellipse at 70% 20%, rgba(255,240,220,0.4) 0%, transparent 40%);
        }
        
        /* Atmospheric haze */
        .atmospheric-haze {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 9994;
            opacity: 0.08;
            background: linear-gradient(180deg, 
                rgba(135,180,220,0.3) 0%, 
                transparent 30%, 
                transparent 70%, 
                rgba(100,140,180,0.2) 100%);
        }
    </style>
</head>
<body>
    <div class="vignette-overlay"></div>
    <div class="film-grain"></div>
    <div class="chromatic-aberration"></div>
    <div class="lens-dirt"></div>
    <div class="bloom-overlay"></div>
    <div class="atmospheric-haze"></div>
    <div id="ui">
        <h1>‚öì WAR SHIPS ‚öì</h1>
        <div id="scoreboard">
            <div class="score red-score">üî¥ RED: <span id="redScore">0</span></div>
            <div class="score blue-score">üîµ BLUE: <span id="blueScore">0</span></div>
        </div>
        <div id="controls">
            <button onclick="resetGame()">üîÑ RESTART</button>
            <button onclick="togglePause()">‚è∏Ô∏è PAUSE</button>
        </div>
        <div id="info">W/S throttle | A/D or Q/E to steer | SPACE to fire | Your ship has GREEN lights</div>
    </div>
    
    <div id="homeScreen">
        <div class="top-left-buttons">
            <button id="shop-btn" onclick="toggleShop()">üö¢ SHIP SHOP</button>
            <button id="team-btn" onclick="toggleTeam()">üë• FLEET</button>
            <button id="quests-btn" onclick="toggleQuests()">üìú QUESTS</button>
        </div>
        
        <div class="bottom-left-buttons">
            <button onclick="resetAllProgress()">üîÑ RESTART</button>
        </div>
        
        <div class="ship-silhouette">üö¢</div>
        <h1>‚öì WAR SHIPS ‚öì</h1>
        <div class="subtitle">NAVAL COMBAT SIMULATOR</div>
        
        <div id="money-display">üí∞ $<span id="money">0</span></div>
        
        <div class="current-ship">Current Ship: <span id="current-ship-name">Starter Vessel</span></div>
        
        <div id="quest-panel">
            <h3>üìú QUESTS</h3>
            <div id="quest-list"></div>
        </div>
        
        <div class="difficulty-container">
            <div class="difficulty-label">SELECT DIFFICULTY</div>
            <div class="difficulty-buttons">
                <button class="diff-btn easy" onclick="setDifficulty(1)">EASY</button>
                <button class="diff-btn medium selected" onclick="setDifficulty(2)">MEDIUM</button>
                <button class="diff-btn hard" onclick="setDifficulty(3)">HARD</button>
                <button class="diff-btn extreme" onclick="setDifficulty(4)">EXTREME</button>
                <button class="diff-btn nightmare" onclick="setDifficulty(5)">NIGHTMARE</button>
            </div>
        </div>
        <button class="menu-btn" onclick="startGame()">‚ñ∂ START BATTLE</button>
        <button class="menu-btn secondary" onclick="showControls()">‚å® CONTROLS</button>
        <div class="controls-info">
            <span>W/S</span> Throttle &nbsp;|&nbsp; 
            <span>A/D</span> Steer &nbsp;|&nbsp; 
            <span>SPACE</span> Fire Main Guns
        </div>
        <div class="version">v1.0</div>
    </div>
    
    <div id="shop-panel">
        <span class="close-shop" onclick="toggleShop()">‚úï</span>
        <h2>üö¢ SHIP SHOP</h2>
        <div class="shop-tabs">
            <button class="shop-tab active" onclick="showShopCategory('all')">All</button>
            <button class="shop-tab" onclick="showShopCategory('speed')">Speed</button>
            <button class="shop-tab" onclick="showShopCategory('tank')">Tank</button>
            <button class="shop-tab" onclick="showShopCategory('damage')">Damage</button>
            <button class="shop-tab" onclick="showShopCategory('balanced')">Balanced</button>
            <button class="shop-tab" onclick="showShopCategory('special')">Special</button>
        </div>
        <div id="ship-grid" class="ship-grid"></div>
    </div>
    
    <div id="team-panel">
        <span class="close-team" onclick="toggleTeam()">‚úï</span>
        <h2>üë• FLEET COMMAND</h2>
        <p class="team-subtitle">Assign ships to your crew members</p>
        <div id="team-members-grid"></div>
        <div id="team-ship-selection" style="display:none;">
            <h3 id="team-selection-title">Select Ship</h3>
            <button class="back-btn" onclick="closeTeamShipSelection()">‚Üê Back</button>
            <div id="team-ship-grid"></div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, water, sun, sky;
        let ships = [];
        let bullets = [];
        let explosions = [];
        let wakes = [];
        let redScore = 0;
        let blueScore = 0;
        let paused = true;
        let difficulty = 2; // 1=Easy, 2=Medium, 3=Hard, 4=Extreme, 5=Nightmare
        let keys = {};
        let playerShip = null;
        let clock = new THREE.Clock();
        const WORLD_SIZE = 1200;
        let islands = [];
        
        // ============ BACKGROUND MUSIC SYSTEM ============
        let audioContext = null;
        let musicPlaying = false;
        let musicGain = null;
        let musicNodes = [];
        
        function initBackgroundMusic() {
            if (audioContext) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            musicGain = audioContext.createGain();
            musicGain.gain.value = 0.3;
            musicGain.connect(audioContext.destination);
        }
        
        function startBackgroundMusic() {
            if (musicPlaying) return;
            initBackgroundMusic();
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            musicPlaying = true;
            playSeaBattleSong();
        }
        
        function playSeaBattleSong() {
            // Epic sea battle music - procedurally generated
            const bpm = 100;
            const beatDuration = 60 / bpm;
            const barDuration = beatDuration * 4;
            const loopDuration = barDuration * 16; // 16 bars loop
            
            // Musical scales and notes (D minor - dramatic naval feel)
            const baseFreq = 146.83; // D3
            const scale = [1, 1.0595, 1.1225, 1.1892, 1.2599, 1.3348, 1.4142, 1.4983, 1.5874, 1.6818, 1.7818, 1.8877, 2]; // Chromatic
            const minorScale = [0, 2, 3, 5, 7, 8, 10, 12]; // Minor scale intervals
            
            function getFreq(octave, scaleIndex) {
                return baseFreq * Math.pow(2, octave) * scale[minorScale[scaleIndex % minorScale.length] % 12];
            }
            
            function scheduleLoop(startTime) {
                if (!musicPlaying) return;
                
                // Deep drums - war drums feel
                for (let bar = 0; bar < 16; bar++) {
                    for (let beat = 0; beat < 4; beat++) {
                        const time = startTime + bar * barDuration + beat * beatDuration;
                        
                        // Kick drum on 1 and 3
                        if (beat === 0 || beat === 2) {
                            playDrum(time, 60, 0.15, 0.6);
                        }
                        // Snare-like hit on 2 and 4
                        if (beat === 1 || beat === 3) {
                            playDrum(time, 150, 0.08, 0.3);
                        }
                        // Fast hi-hat for urgency
                        playHiHat(time, 0.1);
                        playHiHat(time + beatDuration * 0.5, 0.05);
                    }
                }
                
                // Bass line - ominous low notes
                const bassPattern = [0, 0, 3, 2, 0, 0, 4, 3, 0, 0, 5, 4, 3, 2, 1, 0];
                for (let bar = 0; bar < 16; bar++) {
                    const time = startTime + bar * barDuration;
                    playBass(time, getFreq(-1, bassPattern[bar]), barDuration * 0.9);
                }
                
                // Melody - heroic brass-like synth
                const melodyPattern = [
                    [0, 2, 4, 5], [4, 5, 7, 5], [4, 2, 0, 2], [4, 5, 4, 2],
                    [0, 2, 4, 5], [7, 5, 4, 2], [4, 5, 7, 9], [7, 5, 4, 2],
                    [5, 7, 9, 7], [5, 4, 2, 4], [5, 7, 9, 10], [9, 7, 5, 4],
                    [7, 5, 4, 2], [0, 2, 4, 5], [4, 2, 0, 2], [4, 2, 0, -1]
                ];
                for (let bar = 0; bar < 16; bar++) {
                    for (let note = 0; note < 4; note++) {
                        const time = startTime + bar * barDuration + note * beatDuration;
                        const noteIndex = melodyPattern[bar][note];
                        if (noteIndex >= 0) {
                            playMelody(time, getFreq(1, noteIndex), beatDuration * 0.8);
                        }
                    }
                }
                
                // Strings/pad for atmosphere
                for (let bar = 0; bar < 16; bar += 2) {
                    const time = startTime + bar * barDuration;
                    const chordRoot = bassPattern[bar];
                    playPad(time, getFreq(0, chordRoot), barDuration * 2);
                    playPad(time, getFreq(0, chordRoot + 2), barDuration * 2);
                    playPad(time, getFreq(0, chordRoot + 4), barDuration * 2);
                }
                
                // Schedule next loop
                setTimeout(() => {
                    if (musicPlaying) {
                        scheduleLoop(startTime + loopDuration);
                    }
                }, (loopDuration - 1) * 1000);
            }
            
            function playDrum(time, freq, duration, volume) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, time);
                osc.frequency.exponentialRampToValueAtTime(30, time + duration);
                gain.gain.setValueAtTime(volume, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                osc.connect(gain);
                gain.connect(musicGain);
                osc.start(time);
                osc.stop(time + duration);
            }
            
            function playHiHat(time, volume) {
                const bufferSize = audioContext.sampleRate * 0.05;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
                }
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 7000;
                gain.gain.value = volume;
                source.connect(filter);
                filter.connect(gain);
                gain.connect(musicGain);
                source.start(time);
            }
            
            function playBass(time, freq, duration) {
                const osc = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.value = freq;
                osc2.frequency.value = freq * 0.5;
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                gain.gain.setValueAtTime(0.001, time);
                gain.gain.exponentialRampToValueAtTime(0.4, time + 0.05);
                gain.gain.setValueAtTime(0.4, time + duration - 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                osc.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(musicGain);
                osc.start(time);
                osc2.start(time);
                osc.stop(time + duration);
                osc2.stop(time + duration);
            }
            
            function playMelody(time, freq, duration) {
                const osc = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.type = 'sawtooth';
                osc2.type = 'square';
                osc.frequency.value = freq;
                osc2.frequency.value = freq * 1.005; // Slight detune for richness
                gain.gain.setValueAtTime(0.001, time);
                gain.gain.exponentialRampToValueAtTime(0.15, time + 0.05);
                gain.gain.setValueAtTime(0.12, time + duration - 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(musicGain);
                osc.start(time);
                osc2.start(time);
                osc.stop(time + duration);
                osc2.stop(time + duration);
            }
            
            function playPad(time, freq, duration) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                const filter = audioContext.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.value = freq;
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                gain.gain.setValueAtTime(0.001, time);
                gain.gain.exponentialRampToValueAtTime(0.08, time + 0.5);
                gain.gain.setValueAtTime(0.08, time + duration - 0.5);
                gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(musicGain);
                osc.start(time);
                osc.stop(time + duration);
            }
            
            scheduleLoop(audioContext.currentTime + 0.1);
        }
        
        function stopBackgroundMusic() {
            musicPlaying = false;
        }
        
        // Money and Quest System - persistent with localStorage
        let money = parseInt(localStorage.getItem('warships_money') || '0');
        let totalMoneyEarned = parseInt(localStorage.getItem('warships_totalEarned') || '0');
        let quests = [];
        
        // Load persistent stats from localStorage
        let questStats = JSON.parse(localStorage.getItem('warships_stats') || '{}');
        questStats = {
            kills: questStats.kills || 0,
            shotsFired: questStats.shotsFired || 0,
            shotsHit: questStats.shotsHit || 0,
            damageDealt: questStats.damageDealt || 0,
            survived: questStats.survived || 0,
            gamesPlayed: questStats.gamesPlayed || 0,
            moneyEarned: totalMoneyEarned
        };
        
        const questTemplates = [
            // Kill quests (15)
            { id: 'kill1', name: 'First Blood', desc: 'Destroy 1 enemy ship', type: 'kills', target: 1, reward: 100 },
            { id: 'kill3', name: 'Triple Threat', desc: 'Destroy 3 enemy ships', type: 'kills', target: 3, reward: 300 },
            { id: 'kill5', name: 'Ace Captain', desc: 'Destroy 5 enemy ships', type: 'kills', target: 5, reward: 500 },
            { id: 'kill10', name: 'Fleet Destroyer', desc: 'Destroy 10 enemy ships', type: 'kills', target: 10, reward: 1000 },
            { id: 'kill15', name: 'Naval Terror', desc: 'Destroy 15 enemy ships', type: 'kills', target: 15, reward: 1500 },
            { id: 'kill25', name: 'Sea Wolf', desc: 'Destroy 25 enemy ships', type: 'kills', target: 25, reward: 2500 },
            { id: 'kill50', name: 'Admiral of Death', desc: 'Destroy 50 enemy ships', type: 'kills', target: 50, reward: 5000 },
            { id: 'kill75', name: 'Ocean Reaper', desc: 'Destroy 75 enemy ships', type: 'kills', target: 75, reward: 7500 },
            { id: 'kill100', name: 'Legendary Captain', desc: 'Destroy 100 enemy ships', type: 'kills', target: 100, reward: 10000 },
            { id: 'kill150', name: 'Fleet Annihilator', desc: 'Destroy 150 enemy ships', type: 'kills', target: 150, reward: 15000 },
            { id: 'kill200', name: 'Dreadnought', desc: 'Destroy 200 enemy ships', type: 'kills', target: 200, reward: 20000 },
            { id: 'kill300', name: 'Kraken', desc: 'Destroy 300 enemy ships', type: 'kills', target: 300, reward: 30000 },
            { id: 'kill500', name: 'Poseidon\'s Wrath', desc: 'Destroy 500 enemy ships', type: 'kills', target: 500, reward: 50000 },
            { id: 'kill750', name: 'God of War', desc: 'Destroy 750 enemy ships', type: 'kills', target: 750, reward: 75000 },
            { id: 'kill1000', name: 'Immortal Admiral', desc: 'Destroy 1000 enemy ships', type: 'kills', target: 1000, reward: 100000 },
            
            // Shots fired quests (15)
            { id: 'shots10', name: 'Trigger Happy', desc: 'Fire 10 shots', type: 'shotsFired', target: 10, reward: 50 },
            { id: 'shots50', name: 'Artillery Barrage', desc: 'Fire 50 shots', type: 'shotsFired', target: 50, reward: 200 },
            { id: 'shots100', name: 'Gunner', desc: 'Fire 100 shots', type: 'shotsFired', target: 100, reward: 400 },
            { id: 'shots250', name: 'Heavy Artillery', desc: 'Fire 250 shots', type: 'shotsFired', target: 250, reward: 800 },
            { id: 'shots500', name: 'Bombardment', desc: 'Fire 500 shots', type: 'shotsFired', target: 500, reward: 1500 },
            { id: 'shots1000', name: 'Shell Storm', desc: 'Fire 1000 shots', type: 'shotsFired', target: 1000, reward: 3000 },
            { id: 'shots2000', name: 'Endless Barrage', desc: 'Fire 2000 shots', type: 'shotsFired', target: 2000, reward: 5000 },
            { id: 'shots3500', name: 'Lead Rain', desc: 'Fire 3500 shots', type: 'shotsFired', target: 3500, reward: 8000 },
            { id: 'shots5000', name: 'Arsenal Master', desc: 'Fire 5000 shots', type: 'shotsFired', target: 5000, reward: 12000 },
            { id: 'shots7500', name: 'Cannon King', desc: 'Fire 7500 shots', type: 'shotsFired', target: 7500, reward: 18000 },
            { id: 'shots10000', name: 'Thunder God', desc: 'Fire 10000 shots', type: 'shotsFired', target: 10000, reward: 25000 },
            { id: 'shots15000', name: 'Infinite Ammo', desc: 'Fire 15000 shots', type: 'shotsFired', target: 15000, reward: 35000 },
            { id: 'shots20000', name: 'Bullet Hell', desc: 'Fire 20000 shots', type: 'shotsFired', target: 20000, reward: 50000 },
            { id: 'shots30000', name: 'Apocalypse', desc: 'Fire 30000 shots', type: 'shotsFired', target: 30000, reward: 75000 },
            { id: 'shots50000', name: 'Armageddon', desc: 'Fire 50000 shots', type: 'shotsFired', target: 50000, reward: 100000 },
            
            // Accuracy quests (15)
            { id: 'hit5', name: 'Sharpshooter', desc: 'Hit enemies 5 times', type: 'shotsHit', target: 5, reward: 150 },
            { id: 'hit20', name: 'Master Gunner', desc: 'Hit enemies 20 times', type: 'shotsHit', target: 20, reward: 400 },
            { id: 'hit50', name: 'Sniper', desc: 'Hit enemies 50 times', type: 'shotsHit', target: 50, reward: 800 },
            { id: 'hit100', name: 'Deadshot', desc: 'Hit enemies 100 times', type: 'shotsHit', target: 100, reward: 1500 },
            { id: 'hit200', name: 'Eagle Eye', desc: 'Hit enemies 200 times', type: 'shotsHit', target: 200, reward: 2500 },
            { id: 'hit350', name: 'Precision Master', desc: 'Hit enemies 350 times', type: 'shotsHit', target: 350, reward: 4000 },
            { id: 'hit500', name: 'Perfect Aim', desc: 'Hit enemies 500 times', type: 'shotsHit', target: 500, reward: 6000 },
            { id: 'hit750', name: 'Bullseye', desc: 'Hit enemies 750 times', type: 'shotsHit', target: 750, reward: 9000 },
            { id: 'hit1000', name: 'Hawkeye', desc: 'Hit enemies 1000 times', type: 'shotsHit', target: 1000, reward: 12000 },
            { id: 'hit1500', name: 'Marksman Elite', desc: 'Hit enemies 1500 times', type: 'shotsHit', target: 1500, reward: 18000 },
            { id: 'hit2000', name: 'Legendary Aim', desc: 'Hit enemies 2000 times', type: 'shotsHit', target: 2000, reward: 25000 },
            { id: 'hit3000', name: 'Aimbot', desc: 'Hit enemies 3000 times', type: 'shotsHit', target: 3000, reward: 35000 },
            { id: 'hit5000', name: 'Inhuman Accuracy', desc: 'Hit enemies 5000 times', type: 'shotsHit', target: 5000, reward: 50000 },
            { id: 'hit7500', name: 'Godlike Precision', desc: 'Hit enemies 7500 times', type: 'shotsHit', target: 7500, reward: 75000 },
            { id: 'hit10000', name: 'Omniscient Gunner', desc: 'Hit enemies 10000 times', type: 'shotsHit', target: 10000, reward: 100000 },
            
            // Damage quests (15)
            { id: 'damage500', name: 'Heavy Hitter', desc: 'Deal 500 damage', type: 'damageDealt', target: 500, reward: 250 },
            { id: 'damage1000', name: 'Pain Dealer', desc: 'Deal 1000 damage', type: 'damageDealt', target: 1000, reward: 500 },
            { id: 'damage2500', name: 'Hull Breaker', desc: 'Deal 2500 damage', type: 'damageDealt', target: 2500, reward: 1000 },
            { id: 'damage5000', name: 'Destroyer', desc: 'Deal 5000 damage', type: 'damageDealt', target: 5000, reward: 2000 },
            { id: 'damage10000', name: 'Devastator', desc: 'Deal 10000 damage', type: 'damageDealt', target: 10000, reward: 4000 },
            { id: 'damage20000', name: 'Annihilator', desc: 'Deal 20000 damage', type: 'damageDealt', target: 20000, reward: 7000 },
            { id: 'damage35000', name: 'Obliterator', desc: 'Deal 35000 damage', type: 'damageDealt', target: 35000, reward: 11000 },
            { id: 'damage50000', name: 'Decimator', desc: 'Deal 50000 damage', type: 'damageDealt', target: 50000, reward: 16000 },
            { id: 'damage75000', name: 'Eradicator', desc: 'Deal 75000 damage', type: 'damageDealt', target: 75000, reward: 22000 },
            { id: 'damage100000', name: 'Exterminator', desc: 'Deal 100000 damage', type: 'damageDealt', target: 100000, reward: 30000 },
            { id: 'damage150000', name: 'Cataclysm', desc: 'Deal 150000 damage', type: 'damageDealt', target: 150000, reward: 40000 },
            { id: 'damage200000', name: 'Ragnarok', desc: 'Deal 200000 damage', type: 'damageDealt', target: 200000, reward: 55000 },
            { id: 'damage300000', name: 'Apocalypse Bringer', desc: 'Deal 300000 damage', type: 'damageDealt', target: 300000, reward: 75000 },
            { id: 'damage500000', name: 'World Ender', desc: 'Deal 500000 damage', type: 'damageDealt', target: 500000, reward: 100000 },
            { id: 'damage1000000', name: 'Universe Destroyer', desc: 'Deal 1000000 damage', type: 'damageDealt', target: 1000000, reward: 200000 },
            
            // Survival quests (15)
            { id: 'survive1', name: 'Survivor', desc: 'Win 1 battle', type: 'survived', target: 1, reward: 500 },
            { id: 'survive3', name: 'Victor', desc: 'Win 3 battles', type: 'survived', target: 3, reward: 1200 },
            { id: 'survive5', name: 'Champion', desc: 'Win 5 battles', type: 'survived', target: 5, reward: 2000 },
            { id: 'survive10', name: 'Veteran', desc: 'Win 10 battles', type: 'survived', target: 10, reward: 4000 },
            { id: 'survive15', name: 'War Hero', desc: 'Win 15 battles', type: 'survived', target: 15, reward: 6000 },
            { id: 'survive25', name: 'Battle Master', desc: 'Win 25 battles', type: 'survived', target: 25, reward: 10000 },
            { id: 'survive40', name: 'Unbreakable', desc: 'Win 40 battles', type: 'survived', target: 40, reward: 15000 },
            { id: 'survive60', name: 'Invincible', desc: 'Win 60 battles', type: 'survived', target: 60, reward: 22000 },
            { id: 'survive80', name: 'Unstoppable', desc: 'Win 80 battles', type: 'survived', target: 80, reward: 30000 },
            { id: 'survive100', name: 'Legendary Victor', desc: 'Win 100 battles', type: 'survived', target: 100, reward: 40000 },
            { id: 'survive150', name: 'Eternal Champion', desc: 'Win 150 battles', type: 'survived', target: 150, reward: 55000 },
            { id: 'survive200', name: 'Mythic Admiral', desc: 'Win 200 battles', type: 'survived', target: 200, reward: 75000 },
            { id: 'survive300', name: 'Godlike Captain', desc: 'Win 300 battles', type: 'survived', target: 300, reward: 100000 },
            { id: 'survive500', name: 'Immortal Legend', desc: 'Win 500 battles', type: 'survived', target: 500, reward: 150000 },
            { id: 'survive1000', name: 'Eternal God', desc: 'Win 1000 battles', type: 'survived', target: 1000, reward: 300000 },
            
            // Games played quests (15)
            { id: 'games1', name: 'Rookie', desc: 'Play 1 game', type: 'gamesPlayed', target: 1, reward: 50 },
            { id: 'games5', name: 'Enlisted', desc: 'Play 5 games', type: 'gamesPlayed', target: 5, reward: 200 },
            { id: 'games10', name: 'Sailor', desc: 'Play 10 games', type: 'gamesPlayed', target: 10, reward: 400 },
            { id: 'games25', name: 'Seaman', desc: 'Play 25 games', type: 'gamesPlayed', target: 25, reward: 800 },
            { id: 'games50', name: 'Officer', desc: 'Play 50 games', type: 'gamesPlayed', target: 50, reward: 1500 },
            { id: 'games75', name: 'Lieutenant', desc: 'Play 75 games', type: 'gamesPlayed', target: 75, reward: 2500 },
            { id: 'games100', name: 'Commander', desc: 'Play 100 games', type: 'gamesPlayed', target: 100, reward: 4000 },
            { id: 'games150', name: 'Captain', desc: 'Play 150 games', type: 'gamesPlayed', target: 150, reward: 6000 },
            { id: 'games200', name: 'Rear Admiral', desc: 'Play 200 games', type: 'gamesPlayed', target: 200, reward: 8000 },
            { id: 'games300', name: 'Vice Admiral', desc: 'Play 300 games', type: 'gamesPlayed', target: 300, reward: 12000 },
            { id: 'games400', name: 'Admiral', desc: 'Play 400 games', type: 'gamesPlayed', target: 400, reward: 16000 },
            { id: 'games500', name: 'Fleet Admiral', desc: 'Play 500 games', type: 'gamesPlayed', target: 500, reward: 22000 },
            { id: 'games750', name: 'Grand Admiral', desc: 'Play 750 games', type: 'gamesPlayed', target: 750, reward: 35000 },
            { id: 'games1000', name: 'Supreme Admiral', desc: 'Play 1000 games', type: 'gamesPlayed', target: 1000, reward: 50000 },
            { id: 'games2000', name: 'Eternal Mariner', desc: 'Play 2000 games', type: 'gamesPlayed', target: 2000, reward: 100000 },
            
            // Money earned quests (14)
            { id: 'earn1000', name: 'Penny Pincher', desc: 'Earn $1,000 total', type: 'moneyEarned', target: 1000, reward: 200 },
            { id: 'earn5000', name: 'Coin Collector', desc: 'Earn $5,000 total', type: 'moneyEarned', target: 5000, reward: 500 },
            { id: 'earn10000', name: 'Wealthy Sailor', desc: 'Earn $10,000 total', type: 'moneyEarned', target: 10000, reward: 1000 },
            { id: 'earn25000', name: 'Rich Captain', desc: 'Earn $25,000 total', type: 'moneyEarned', target: 25000, reward: 2500 },
            { id: 'earn50000', name: 'Treasure Hunter', desc: 'Earn $50,000 total', type: 'moneyEarned', target: 50000, reward: 5000 },
            { id: 'earn100000', name: 'Fortune Seeker', desc: 'Earn $100,000 total', type: 'moneyEarned', target: 100000, reward: 10000 },
            { id: 'earn250000', name: 'Wealthy Admiral', desc: 'Earn $250,000 total', type: 'moneyEarned', target: 250000, reward: 25000 },
            { id: 'earn500000', name: 'Naval Tycoon', desc: 'Earn $500,000 total', type: 'moneyEarned', target: 500000, reward: 50000 },
            { id: 'earn1000000', name: 'Millionaire', desc: 'Earn $1,000,000 total', type: 'moneyEarned', target: 1000000, reward: 100000 },
            { id: 'earn2500000', name: 'Multi-Millionaire', desc: 'Earn $2,500,000 total', type: 'moneyEarned', target: 2500000, reward: 200000 },
            { id: 'earn5000000', name: 'Billionaire', desc: 'Earn $5,000,000 total', type: 'moneyEarned', target: 5000000, reward: 400000 },
            { id: 'earn10000000', name: 'Naval Empire', desc: 'Earn $10,000,000 total', type: 'moneyEarned', target: 10000000, reward: 750000 },
            { id: 'earn25000000', name: 'Ocean Mogul', desc: 'Earn $25,000,000 total', type: 'moneyEarned', target: 25000000, reward: 1500000 },
            { id: 'earn50000000', name: 'Infinite Wealth', desc: 'Earn $50,000,000 total', type: 'moneyEarned', target: 50000000, reward: 3000000 }
        ];
        
        function saveStats() {
            localStorage.setItem('warships_money', money.toString());
            localStorage.setItem('warships_totalEarned', totalMoneyEarned.toString());
            localStorage.setItem('warships_stats', JSON.stringify(questStats));
        }
        
        function loadCompletedQuests() {
            const completed = JSON.parse(localStorage.getItem('warships_completedQuests') || '[]');
            return completed;
        }
        
        function saveCompletedQuests() {
            const completed = quests.filter(q => q.claimed).map(q => q.id);
            localStorage.setItem('warships_completedQuests', JSON.stringify(completed));
        }
        
        function initQuests() {
            const completedIds = loadCompletedQuests();
            quests = questTemplates.map(t => {
                const wasCompleted = completedIds.includes(t.id);
                return { 
                    ...t, 
                    progress: wasCompleted ? t.target : Math.min(questStats[t.type] || 0, t.target), 
                    completed: wasCompleted, 
                    claimed: wasCompleted 
                };
            });
            document.getElementById('money').textContent = money.toLocaleString();
            updateQuestUI();
        }
        
        function updateQuestProgress(type, amount = 1) {
            questStats[type] += amount;
            saveStats();
            quests.forEach(quest => {
                if (quest.type === type && !quest.completed) {
                    quest.progress = Math.min(questStats[type], quest.target);
                    if (quest.progress >= quest.target) {
                        quest.completed = true;
                        claimQuest(quest);
                    }
                }
            });
            updateQuestUI();
        }
        
        function claimQuest(quest) {
            if (!quest.claimed) {
                quest.claimed = true;
                // Difficulty multiplier: Easy=1x, Medium=1.5x, Hard=2x, Extreme=3x, Nightmare=5x
                const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
                const multiplier = difficultyMultipliers[difficulty] || 1;
                const reward = Math.round(quest.reward * multiplier);
                money += reward;
                totalMoneyEarned += reward;
                questStats.moneyEarned = totalMoneyEarned;
                saveStats();
                saveCompletedQuests();
                document.getElementById('money').textContent = money.toLocaleString();
                showQuestComplete(quest, reward);
                // Check money earned quests
                checkMoneyQuests();
            }
        }
        
        function checkMoneyQuests() {
            quests.forEach(quest => {
                if (quest.type === 'moneyEarned' && !quest.completed) {
                    quest.progress = Math.min(totalMoneyEarned, quest.target);
                    if (quest.progress >= quest.target) {
                        quest.completed = true;
                        claimQuest(quest);
                    }
                }
            });
            updateQuestUI();
        }
        
        function showQuestComplete(quest, reward) {
            const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
            const multiplier = difficultyMultipliers[difficulty] || 1;
            const diffNames = ['', 'Easy', 'Medium', 'Hard', 'Extreme', 'Nightmare'];
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,50,0,0.9);border:3px solid #00ff66;border-radius:15px;padding:20px 40px;color:#fff;text-align:center;z-index:1000;animation:fadeOut 2s forwards;';
            popup.innerHTML = `<div style="color:#00ff66;font-size:1.5em;">‚úì QUEST COMPLETE!</div><div style="margin:10px 0;">${quest.name}</div><div style="color:#ffd700;font-size:1.3em;">+$${reward.toLocaleString()}</div>${multiplier > 1 ? `<div style="color:#00d4ff;font-size:0.9em;">(${diffNames[difficulty]} ${multiplier}x bonus!)</div>` : ''}`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
        }
        
        function getRewardMultiplier() {
            const difficultyMultipliers = { 1: 1, 2: 1.5, 3: 2, 4: 3, 5: 5 };
            return difficultyMultipliers[difficulty] || 1;
        }
        
        function updateQuestUI() {
            const list = document.getElementById('quest-list');
            if (!list) return;
            const multiplier = getRewardMultiplier();
            // Sort: incomplete first, then by target
            const sortedQuests = [...quests].sort((a, b) => {
                if (a.completed !== b.completed) return a.completed ? 1 : -1;
                return a.target - b.target;
            });
            list.innerHTML = sortedQuests.map(q => {
                const displayReward = q.completed ? q.reward : Math.round(q.reward * multiplier);
                return `
                <div class="quest-item ${q.completed ? 'completed' : ''}">
                    <div class="quest-name">${q.completed ? '‚úì ' : ''}${q.name}</div>
                    <div class="quest-progress">${q.desc} (${q.progress.toLocaleString()}/${q.target.toLocaleString()})</div>
                    <div class="quest-reward">üí∞ $${displayReward.toLocaleString()}${!q.completed && multiplier > 1 ? ` <span style="color:#00d4ff">(${multiplier}x)</span>` : ''}</div>
                </div>
            `}).join('');
        }
        
        // Initialize money display on page load
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('money').textContent = money.toLocaleString();
            initQuests();
            initShop();
        });
        
        // ============ SHIP SHOP SYSTEM ============
        let selectedShipId = localStorage.getItem('warships_selectedShip') || 'starter';
        let ownedShips = JSON.parse(localStorage.getItem('warships_ownedShips') || '["starter"]');
        
        // ============ TEAM MEMBERS SYSTEM ============
        const DEFAULT_TEAM_MEMBERS = [
            { id: 'first-mate', name: 'First Mate Rodriguez', role: 'Flanker', assignedShipId: null, personality: 'aggressive' },
            { id: 'gunner', name: 'Chief Gunner Chen', role: 'Support', assignedShipId: null, personality: 'cautious' },
            { id: 'navigator', name: 'Navigator Williams', role: 'Scout', assignedShipId: null, personality: 'balanced' }
        ];
        let teamMembers = JSON.parse(localStorage.getItem('warships_teamMembers') || JSON.stringify(DEFAULT_TEAM_MEMBERS));
        
        // Get ship stats for a team member (returns starter if none assigned)
        function getTeamMemberShipStats(memberId) {
            const member = teamMembers.find(m => m.id === memberId);
            if (!member || !member.assignedShipId) {
                return shipTemplates.find(s => s.id === 'starter');
            }
            return shipTemplates.find(s => s.id === member.assignedShipId) || shipTemplates.find(s => s.id === 'starter');
        }
        
        // Get emoji for a ship based on category
        function getShipEmoji(ship) {
            if (ship.emoji) return ship.emoji;
            const categoryEmojis = {
                'speed': '‚ö°',
                'tank': 'üõ°Ô∏è',
                'damage': 'üí•',
                'balanced': '‚≠ê',
                'special': 'üîÆ'
            };
            return categoryEmojis[ship.category] || 'üö¢';
        }
        
        const shipTemplates = [
            // STARTER (free)
            { id: 'starter', name: 'Starter Vessel', category: 'balanced', price: 0, health: 100, speed: 1.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['Free ship'], debuffs: ['Basic stats'] },
            
            // SPEED SHIPS (20)
            { id: 'swift1', name: 'Swift Runner', category: 'speed', price: 500, health: 80, speed: 1.3, fireRate: 1.0, damage: 0.9, accuracy: 1.0, buffs: ['+30% Speed'], debuffs: ['-20% Health', '-10% Damage'] },
            { id: 'swift2', name: 'Sea Dart', category: 'speed', price: 1200, health: 75, speed: 1.4, fireRate: 1.1, damage: 0.85, accuracy: 1.0, buffs: ['+40% Speed', '+10% Fire Rate'], debuffs: ['-25% Health', '-15% Damage'] },
            { id: 'swift3', name: 'Velocity', category: 'speed', price: 2500, health: 70, speed: 1.5, fireRate: 1.0, damage: 0.9, accuracy: 1.1, buffs: ['+50% Speed', '+10% Accuracy'], debuffs: ['-30% Health'] },
            { id: 'swift4', name: 'Lightning Bolt', category: 'speed', price: 5000, health: 65, speed: 1.6, fireRate: 1.2, damage: 0.85, accuracy: 1.0, buffs: ['+60% Speed', '+20% Fire Rate'], debuffs: ['-35% Health', '-15% Damage'] },
            { id: 'swift5', name: 'Tempest', category: 'speed', price: 8000, health: 70, speed: 1.7, fireRate: 1.0, damage: 1.0, accuracy: 0.9, buffs: ['+70% Speed'], debuffs: ['-30% Health', '-10% Accuracy'] },
            { id: 'swift6', name: 'Zephyr', category: 'speed', price: 12000, health: 60, speed: 1.8, fireRate: 1.1, damage: 0.9, accuracy: 1.1, buffs: ['+80% Speed', '+10% Fire Rate', '+10% Accuracy'], debuffs: ['-40% Health', '-10% Damage'] },
            { id: 'swift7', name: 'Hurricane', category: 'speed', price: 18000, health: 65, speed: 1.9, fireRate: 1.2, damage: 0.85, accuracy: 1.0, buffs: ['+90% Speed', '+20% Fire Rate'], debuffs: ['-35% Health', '-15% Damage'] },
            { id: 'swift8', name: 'Sonic Wave', category: 'speed', price: 25000, health: 55, speed: 2.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+100% Speed'], debuffs: ['-45% Health'] },
            { id: 'swift9', name: 'Phantom', category: 'speed', price: 35000, health: 50, speed: 2.1, fireRate: 1.3, damage: 0.8, accuracy: 1.2, buffs: ['+110% Speed', '+30% Fire Rate', '+20% Accuracy'], debuffs: ['-50% Health', '-20% Damage'] },
            { id: 'swift10', name: 'Blur', category: 'speed', price: 50000, health: 60, speed: 2.2, fireRate: 1.1, damage: 0.9, accuracy: 1.0, buffs: ['+120% Speed', '+10% Fire Rate'], debuffs: ['-40% Health', '-10% Damage'] },
            { id: 'swift11', name: 'Supersonic', category: 'speed', price: 70000, health: 55, speed: 2.3, fireRate: 1.2, damage: 0.85, accuracy: 1.1, buffs: ['+130% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-45% Health', '-15% Damage'] },
            { id: 'swift12', name: 'Hyperdrive', category: 'speed', price: 100000, health: 50, speed: 2.4, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+140% Speed'], debuffs: ['-50% Health'] },
            { id: 'swift13', name: 'Light Speed', category: 'speed', price: 150000, health: 45, speed: 2.5, fireRate: 1.4, damage: 0.8, accuracy: 1.2, buffs: ['+150% Speed', '+40% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-20% Damage'] },
            { id: 'swift14', name: 'Warp Runner', category: 'speed', price: 200000, health: 55, speed: 2.6, fireRate: 1.2, damage: 0.9, accuracy: 1.1, buffs: ['+160% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-45% Health', '-10% Damage'] },
            { id: 'swift15', name: 'Quantum', category: 'speed', price: 300000, health: 50, speed: 2.7, fireRate: 1.3, damage: 0.85, accuracy: 1.2, buffs: ['+170% Speed', '+30% Fire Rate', '+20% Accuracy'], debuffs: ['-50% Health', '-15% Damage'] },
            { id: 'swift16', name: 'Teleporter', category: 'speed', price: 400000, health: 45, speed: 2.8, fireRate: 1.1, damage: 1.0, accuracy: 1.0, buffs: ['+180% Speed', '+10% Fire Rate'], debuffs: ['-55% Health'] },
            { id: 'swift17', name: 'Flash', category: 'speed', price: 550000, health: 40, speed: 2.9, fireRate: 1.5, damage: 0.75, accuracy: 1.3, buffs: ['+190% Speed', '+50% Fire Rate', '+30% Accuracy'], debuffs: ['-60% Health', '-25% Damage'] },
            { id: 'swift18', name: 'Comet', category: 'speed', price: 750000, health: 50, speed: 3.0, fireRate: 1.2, damage: 0.9, accuracy: 1.1, buffs: ['+200% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-50% Health', '-10% Damage'] },
            { id: 'swift19', name: 'Meteor', category: 'speed', price: 1000000, health: 45, speed: 3.2, fireRate: 1.4, damage: 0.85, accuracy: 1.2, buffs: ['+220% Speed', '+40% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-15% Damage'] },
            { id: 'swift20', name: 'Speed Demon', category: 'speed', price: 2000000, health: 40, speed: 3.5, fireRate: 1.5, damage: 0.8, accuracy: 1.3, buffs: ['+250% Speed', '+50% Fire Rate', '+30% Accuracy'], debuffs: ['-60% Health', '-20% Damage'] },
            
            // TANK SHIPS (20)
            { id: 'tank1', name: 'Iron Hull', category: 'tank', price: 500, health: 140, speed: 0.8, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+40% Health'], debuffs: ['-20% Speed'] },
            { id: 'tank2', name: 'Steel Wall', category: 'tank', price: 1200, health: 160, speed: 0.75, fireRate: 0.9, damage: 1.1, accuracy: 0.95, buffs: ['+60% Health', '+10% Damage'], debuffs: ['-25% Speed', '-10% Fire Rate'] },
            { id: 'tank3', name: 'Fortress', category: 'tank', price: 2500, health: 180, speed: 0.7, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+80% Health'], debuffs: ['-30% Speed'] },
            { id: 'tank4', name: 'Juggernaut', category: 'tank', price: 5000, health: 200, speed: 0.65, fireRate: 0.85, damage: 1.2, accuracy: 0.9, buffs: ['+100% Health', '+20% Damage'], debuffs: ['-35% Speed', '-15% Fire Rate', '-10% Accuracy'] },
            { id: 'tank5', name: 'Behemoth', category: 'tank', price: 8000, health: 220, speed: 0.7, fireRate: 0.9, damage: 1.1, accuracy: 1.0, buffs: ['+120% Health', '+10% Damage'], debuffs: ['-30% Speed', '-10% Fire Rate'] },
            { id: 'tank6', name: 'Titan', category: 'tank', price: 12000, health: 240, speed: 0.6, fireRate: 0.85, damage: 1.15, accuracy: 0.95, buffs: ['+140% Health', '+15% Damage'], debuffs: ['-40% Speed', '-15% Fire Rate'] },
            { id: 'tank7', name: 'Colossus', category: 'tank', price: 18000, health: 260, speed: 0.65, fireRate: 0.9, damage: 1.2, accuracy: 0.9, buffs: ['+160% Health', '+20% Damage'], debuffs: ['-35% Speed', '-10% Fire Rate', '-10% Accuracy'] },
            { id: 'tank8', name: 'Leviathan', category: 'tank', price: 25000, health: 280, speed: 0.55, fireRate: 0.8, damage: 1.25, accuracy: 0.95, buffs: ['+180% Health', '+25% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank9', name: 'Mountain', category: 'tank', price: 35000, health: 300, speed: 0.6, fireRate: 0.85, damage: 1.2, accuracy: 1.0, buffs: ['+200% Health', '+20% Damage'], debuffs: ['-40% Speed', '-15% Fire Rate'] },
            { id: 'tank10', name: 'Dreadnought', category: 'tank', price: 50000, health: 320, speed: 0.5, fireRate: 0.75, damage: 1.3, accuracy: 0.9, buffs: ['+220% Health', '+30% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank11', name: 'Ironclad', category: 'tank', price: 70000, health: 340, speed: 0.55, fireRate: 0.8, damage: 1.25, accuracy: 0.95, buffs: ['+240% Health', '+25% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank12', name: 'Mammoth', category: 'tank', price: 100000, health: 360, speed: 0.5, fireRate: 0.75, damage: 1.35, accuracy: 0.9, buffs: ['+260% Health', '+35% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank13', name: 'Bulwark', category: 'tank', price: 150000, health: 380, speed: 0.55, fireRate: 0.8, damage: 1.3, accuracy: 0.95, buffs: ['+280% Health', '+30% Damage'], debuffs: ['-45% Speed', '-20% Fire Rate'] },
            { id: 'tank14', name: 'Citadel', category: 'tank', price: 200000, health: 400, speed: 0.45, fireRate: 0.7, damage: 1.4, accuracy: 0.85, buffs: ['+300% Health', '+40% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate', '-15% Accuracy'] },
            { id: 'tank15', name: 'Bastion', category: 'tank', price: 300000, health: 420, speed: 0.5, fireRate: 0.75, damage: 1.35, accuracy: 0.9, buffs: ['+320% Health', '+35% Damage'], debuffs: ['-50% Speed', '-25% Fire Rate', '-10% Accuracy'] },
            { id: 'tank16', name: 'Rampart', category: 'tank', price: 400000, health: 450, speed: 0.45, fireRate: 0.7, damage: 1.4, accuracy: 0.9, buffs: ['+350% Health', '+40% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate'] },
            { id: 'tank17', name: 'Goliath', category: 'tank', price: 550000, health: 480, speed: 0.4, fireRate: 0.65, damage: 1.5, accuracy: 0.85, buffs: ['+380% Health', '+50% Damage'], debuffs: ['-60% Speed', '-35% Fire Rate', '-15% Accuracy'] },
            { id: 'tank18', name: 'Monolith', category: 'tank', price: 750000, health: 500, speed: 0.45, fireRate: 0.7, damage: 1.45, accuracy: 0.9, buffs: ['+400% Health', '+45% Damage'], debuffs: ['-55% Speed', '-30% Fire Rate', '-10% Accuracy'] },
            { id: 'tank19', name: 'Eternal', category: 'tank', price: 1000000, health: 550, speed: 0.4, fireRate: 0.65, damage: 1.5, accuracy: 0.85, buffs: ['+450% Health', '+50% Damage'], debuffs: ['-60% Speed', '-35% Fire Rate', '-15% Accuracy'] },
            { id: 'tank20', name: 'Immortal', category: 'tank', price: 2000000, health: 600, speed: 0.35, fireRate: 0.6, damage: 1.6, accuracy: 0.8, buffs: ['+500% Health', '+60% Damage'], debuffs: ['-65% Speed', '-40% Fire Rate', '-20% Accuracy'] },
            
            // DAMAGE SHIPS (20)
            { id: 'dmg1', name: 'Striker', category: 'damage', price: 500, health: 85, speed: 0.95, fireRate: 1.0, damage: 1.25, accuracy: 1.0, buffs: ['+25% Damage'], debuffs: ['-15% Health'] },
            { id: 'dmg2', name: 'Punisher', category: 'damage', price: 1200, health: 80, speed: 0.9, fireRate: 1.1, damage: 1.35, accuracy: 0.95, buffs: ['+35% Damage', '+10% Fire Rate'], debuffs: ['-20% Health', '-10% Speed'] },
            { id: 'dmg3', name: 'Destroyer', category: 'damage', price: 2500, health: 90, speed: 1.0, fireRate: 0.9, damage: 1.45, accuracy: 1.0, buffs: ['+45% Damage'], debuffs: ['-10% Health', '-10% Fire Rate'] },
            { id: 'dmg4', name: 'Annihilator', category: 'damage', price: 5000, health: 75, speed: 0.85, fireRate: 1.15, damage: 1.55, accuracy: 0.9, buffs: ['+55% Damage', '+15% Fire Rate'], debuffs: ['-25% Health', '-15% Speed', '-10% Accuracy'] },
            { id: 'dmg5', name: 'Executioner', category: 'damage', price: 8000, health: 85, speed: 0.95, fireRate: 1.0, damage: 1.6, accuracy: 1.0, buffs: ['+60% Damage'], debuffs: ['-15% Health'] },
            { id: 'dmg6', name: 'Obliterator', category: 'damage', price: 12000, health: 70, speed: 0.9, fireRate: 1.2, damage: 1.7, accuracy: 0.95, buffs: ['+70% Damage', '+20% Fire Rate'], debuffs: ['-30% Health', '-10% Speed'] },
            { id: 'dmg7', name: 'Devastator', category: 'damage', price: 18000, health: 80, speed: 0.95, fireRate: 1.1, damage: 1.75, accuracy: 0.9, buffs: ['+75% Damage', '+10% Fire Rate'], debuffs: ['-20% Health', '-10% Accuracy'] },
            { id: 'dmg8', name: 'Ravager', category: 'damage', price: 25000, health: 65, speed: 0.85, fireRate: 1.25, damage: 1.85, accuracy: 0.95, buffs: ['+85% Damage', '+25% Fire Rate'], debuffs: ['-35% Health', '-15% Speed'] },
            { id: 'dmg9', name: 'Eliminator', category: 'damage', price: 35000, health: 75, speed: 0.9, fireRate: 1.15, damage: 1.9, accuracy: 1.0, buffs: ['+90% Damage', '+15% Fire Rate'], debuffs: ['-25% Health', '-10% Speed'] },
            { id: 'dmg10', name: 'Terminator', category: 'damage', price: 50000, health: 60, speed: 0.8, fireRate: 1.3, damage: 2.0, accuracy: 0.9, buffs: ['+100% Damage', '+30% Fire Rate'], debuffs: ['-40% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg11', name: 'Eradicator', category: 'damage', price: 70000, health: 70, speed: 0.9, fireRate: 1.2, damage: 2.1, accuracy: 0.95, buffs: ['+110% Damage', '+20% Fire Rate'], debuffs: ['-30% Health', '-10% Speed'] },
            { id: 'dmg12', name: 'Decimator', category: 'damage', price: 100000, health: 55, speed: 0.8, fireRate: 1.35, damage: 2.2, accuracy: 0.9, buffs: ['+120% Damage', '+35% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg13', name: 'Slayer', category: 'damage', price: 150000, health: 65, speed: 0.85, fireRate: 1.25, damage: 2.3, accuracy: 0.95, buffs: ['+130% Damage', '+25% Fire Rate'], debuffs: ['-35% Health', '-15% Speed'] },
            { id: 'dmg14', name: 'Reaper', category: 'damage', price: 200000, health: 50, speed: 0.75, fireRate: 1.4, damage: 2.5, accuracy: 0.85, buffs: ['+150% Damage', '+40% Fire Rate'], debuffs: ['-50% Health', '-25% Speed', '-15% Accuracy'] },
            { id: 'dmg15', name: 'Destroyer X', category: 'damage', price: 300000, health: 60, speed: 0.85, fireRate: 1.3, damage: 2.6, accuracy: 0.9, buffs: ['+160% Damage', '+30% Fire Rate'], debuffs: ['-40% Health', '-15% Speed', '-10% Accuracy'] },
            { id: 'dmg16', name: 'Omega Strike', category: 'damage', price: 400000, health: 55, speed: 0.8, fireRate: 1.4, damage: 2.75, accuracy: 0.9, buffs: ['+175% Damage', '+40% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg17', name: 'Death Dealer', category: 'damage', price: 550000, health: 45, speed: 0.7, fireRate: 1.5, damage: 3.0, accuracy: 0.85, buffs: ['+200% Damage', '+50% Fire Rate'], debuffs: ['-55% Health', '-30% Speed', '-15% Accuracy'] },
            { id: 'dmg18', name: 'Armageddon', category: 'damage', price: 750000, health: 55, speed: 0.8, fireRate: 1.4, damage: 3.2, accuracy: 0.9, buffs: ['+220% Damage', '+40% Fire Rate'], debuffs: ['-45% Health', '-20% Speed', '-10% Accuracy'] },
            { id: 'dmg19', name: 'Apocalypse', category: 'damage', price: 1000000, health: 50, speed: 0.75, fireRate: 1.5, damage: 3.5, accuracy: 0.85, buffs: ['+250% Damage', '+50% Fire Rate'], debuffs: ['-50% Health', '-25% Speed', '-15% Accuracy'] },
            { id: 'dmg20', name: 'World Ender', category: 'damage', price: 2000000, health: 40, speed: 0.65, fireRate: 1.6, damage: 4.0, accuracy: 0.8, buffs: ['+300% Damage', '+60% Fire Rate'], debuffs: ['-60% Health', '-35% Speed', '-20% Accuracy'] },
            
            // BALANCED SHIPS (20)
            { id: 'bal1', name: 'Voyager', category: 'balanced', price: 800, health: 110, speed: 1.1, fireRate: 1.05, damage: 1.05, accuracy: 1.05, buffs: ['+10% All Stats'], debuffs: [] },
            { id: 'bal2', name: 'Explorer', category: 'balanced', price: 1500, health: 115, speed: 1.1, fireRate: 1.1, damage: 1.05, accuracy: 1.05, buffs: ['+15% Health', '+10% Speed/Fire Rate'], debuffs: [] },
            { id: 'bal3', name: 'Navigator', category: 'balanced', price: 3000, health: 120, speed: 1.15, fireRate: 1.1, damage: 1.1, accuracy: 1.05, buffs: ['+20% Health', '+15% Speed', '+10% Damage'], debuffs: [] },
            { id: 'bal4', name: 'Pathfinder', category: 'balanced', price: 6000, health: 125, speed: 1.15, fireRate: 1.15, damage: 1.1, accuracy: 1.1, buffs: ['+25% Health', '+15% All Offense'], debuffs: [] },
            { id: 'bal5', name: 'Crusader', category: 'balanced', price: 10000, health: 130, speed: 1.2, fireRate: 1.15, damage: 1.15, accuracy: 1.1, buffs: ['+30% Health', '+20% Speed', '+15% Damage'], debuffs: [] },
            { id: 'bal6', name: 'Guardian', category: 'balanced', price: 15000, health: 140, speed: 1.15, fireRate: 1.2, damage: 1.15, accuracy: 1.15, buffs: ['+40% Health', '+15% Speed', '+20% Fire Rate'], debuffs: [] },
            { id: 'bal7', name: 'Sentinel', category: 'balanced', price: 22000, health: 145, speed: 1.2, fireRate: 1.2, damage: 1.2, accuracy: 1.15, buffs: ['+45% Health', '+20% All Offense'], debuffs: [] },
            { id: 'bal8', name: 'Protector', category: 'balanced', price: 30000, health: 150, speed: 1.25, fireRate: 1.2, damage: 1.2, accuracy: 1.2, buffs: ['+50% Health', '+25% Speed', '+20% Damage'], debuffs: [] },
            { id: 'bal9', name: 'Champion', category: 'balanced', price: 42000, health: 155, speed: 1.25, fireRate: 1.25, damage: 1.25, accuracy: 1.2, buffs: ['+55% Health', '+25% All Offense'], debuffs: [] },
            { id: 'bal10', name: 'Vindicator', category: 'balanced', price: 55000, health: 160, speed: 1.3, fireRate: 1.25, damage: 1.25, accuracy: 1.25, buffs: ['+60% Health', '+30% Speed', '+25% Offense'], debuffs: [] },
            { id: 'bal11', name: 'Conqueror', category: 'balanced', price: 75000, health: 170, speed: 1.3, fireRate: 1.3, damage: 1.3, accuracy: 1.25, buffs: ['+70% Health', '+30% All Offense'], debuffs: [] },
            { id: 'bal12', name: 'Overlord', category: 'balanced', price: 100000, health: 180, speed: 1.35, fireRate: 1.3, damage: 1.3, accuracy: 1.3, buffs: ['+80% Health', '+35% Speed', '+30% Offense'], debuffs: [] },
            { id: 'bal13', name: 'Sovereign', category: 'balanced', price: 140000, health: 190, speed: 1.35, fireRate: 1.35, damage: 1.35, accuracy: 1.3, buffs: ['+90% Health', '+35% All Offense'], debuffs: [] },
            { id: 'bal14', name: 'Emperor', category: 'balanced', price: 180000, health: 200, speed: 1.4, fireRate: 1.35, damage: 1.35, accuracy: 1.35, buffs: ['+100% Health', '+40% Speed', '+35% Offense'], debuffs: [] },
            { id: 'bal15', name: 'Warlord', category: 'balanced', price: 250000, health: 210, speed: 1.4, fireRate: 1.4, damage: 1.4, accuracy: 1.35, buffs: ['+110% Health', '+40% All Offense'], debuffs: [] },
            { id: 'bal16', name: 'Dominator', category: 'balanced', price: 350000, health: 220, speed: 1.45, fireRate: 1.4, damage: 1.4, accuracy: 1.4, buffs: ['+120% Health', '+45% Speed', '+40% Offense'], debuffs: [] },
            { id: 'bal17', name: 'Supremacy', category: 'balanced', price: 500000, health: 240, speed: 1.45, fireRate: 1.45, damage: 1.45, accuracy: 1.4, buffs: ['+140% Health', '+45% All Offense'], debuffs: [] },
            { id: 'bal18', name: 'Infinity', category: 'balanced', price: 700000, health: 260, speed: 1.5, fireRate: 1.5, damage: 1.5, accuracy: 1.45, buffs: ['+160% Health', '+50% All Offense'], debuffs: [] },
            { id: 'bal19', name: 'Omega', category: 'balanced', price: 1000000, health: 280, speed: 1.55, fireRate: 1.55, damage: 1.55, accuracy: 1.5, buffs: ['+180% Health', '+55% All Offense'], debuffs: [] },
            { id: 'bal20', name: 'Perfection', category: 'balanced', price: 2000000, health: 300, speed: 1.6, fireRate: 1.6, damage: 1.6, accuracy: 1.6, buffs: ['+200% Health', '+60% All Stats'], debuffs: [] },
            
            // SPECIAL SHIPS (19)
            { id: 'spec1', name: 'Glass Cannon', category: 'special', price: 3000, health: 40, speed: 1.2, fireRate: 1.5, damage: 2.5, accuracy: 1.2, buffs: ['+150% Damage', '+50% Fire Rate', '+20% Accuracy'], debuffs: ['-60% Health'] },
            { id: 'spec2', name: 'Sniper', category: 'special', price: 5000, health: 70, speed: 0.7, fireRate: 0.5, damage: 3.0, accuracy: 1.5, buffs: ['+200% Damage', '+50% Accuracy'], debuffs: ['-30% Health', '-30% Speed', '-50% Fire Rate'] },
            { id: 'spec3', name: 'Berserker', category: 'special', price: 8000, health: 60, speed: 1.5, fireRate: 2.0, damage: 0.7, accuracy: 0.7, buffs: ['+50% Speed', '+100% Fire Rate'], debuffs: ['-40% Health', '-30% Damage', '-30% Accuracy'] },
            { id: 'spec4', name: 'Vampire', category: 'special', price: 15000, health: 80, speed: 1.1, fireRate: 1.2, damage: 1.3, accuracy: 1.0, buffs: ['+30% Damage', '+20% Fire Rate', 'Lifesteal'], debuffs: ['-20% Health'] },
            { id: 'spec5', name: 'Ninja', category: 'special', price: 20000, health: 50, speed: 2.0, fireRate: 1.8, damage: 1.2, accuracy: 0.8, buffs: ['+100% Speed', '+80% Fire Rate'], debuffs: ['-50% Health', '-20% Accuracy'] },
            { id: 'spec6', name: 'Turtle', category: 'special', price: 25000, health: 400, speed: 0.3, fireRate: 0.5, damage: 2.0, accuracy: 1.0, buffs: ['+300% Health', '+100% Damage'], debuffs: ['-70% Speed', '-50% Fire Rate'] },
            { id: 'spec7', name: 'Gambler', category: 'special', price: 30000, health: 100, speed: 1.0, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['Random +50% to one stat each game'], debuffs: ['Random -25% to one stat each game'] },
            { id: 'spec8', name: 'Assassin', category: 'special', price: 40000, health: 45, speed: 1.8, fireRate: 0.8, damage: 4.0, accuracy: 1.4, buffs: ['+300% Damage', '+40% Accuracy', '+80% Speed'], debuffs: ['-55% Health', '-20% Fire Rate'] },
            { id: 'spec9', name: 'Tank Destroyer', category: 'special', price: 50000, health: 120, speed: 0.6, fireRate: 0.4, damage: 5.0, accuracy: 1.3, buffs: ['+400% Damage', '+30% Accuracy'], debuffs: ['-40% Speed', '-60% Fire Rate'] },
            { id: 'spec10', name: 'Swarm', category: 'special', price: 60000, health: 35, speed: 1.6, fireRate: 3.0, damage: 0.4, accuracy: 0.6, buffs: ['+60% Speed', '+200% Fire Rate'], debuffs: ['-65% Health', '-60% Damage', '-40% Accuracy'] },
            { id: 'spec11', name: 'Fortress', category: 'special', price: 80000, health: 500, speed: 0.2, fireRate: 0.7, damage: 1.5, accuracy: 1.2, buffs: ['+400% Health', '+50% Damage', '+20% Accuracy'], debuffs: ['-80% Speed'] },
            { id: 'spec12', name: 'Phantom Strike', category: 'special', price: 100000, health: 60, speed: 2.2, fireRate: 1.4, damage: 2.0, accuracy: 1.0, buffs: ['+120% Speed', '+40% Fire Rate', '+100% Damage'], debuffs: ['-40% Health'] },
            { id: 'spec13', name: 'Juggernaut X', category: 'special', price: 150000, health: 350, speed: 0.5, fireRate: 1.0, damage: 2.0, accuracy: 1.0, buffs: ['+250% Health', '+100% Damage'], debuffs: ['-50% Speed'] },
            { id: 'spec14', name: 'Precision', category: 'special', price: 200000, health: 80, speed: 1.0, fireRate: 0.7, damage: 2.5, accuracy: 2.0, buffs: ['+150% Damage', '+100% Accuracy'], debuffs: ['-20% Health', '-30% Fire Rate'] },
            { id: 'spec15', name: 'Rapid Fire', category: 'special', price: 300000, health: 70, speed: 1.3, fireRate: 3.5, damage: 0.5, accuracy: 0.9, buffs: ['+30% Speed', '+250% Fire Rate'], debuffs: ['-30% Health', '-50% Damage', '-10% Accuracy'] },
            { id: 'spec16', name: 'Destroyer Elite', category: 'special', price: 500000, health: 150, speed: 1.3, fireRate: 1.5, damage: 2.5, accuracy: 1.3, buffs: ['+50% Health', '+30% Speed', '+50% Fire Rate', '+150% Damage'], debuffs: [] },
            { id: 'spec17', name: 'Legendary', category: 'special', price: 750000, health: 200, speed: 1.5, fireRate: 1.5, damage: 2.0, accuracy: 1.5, buffs: ['+100% Health', '+50% Speed', '+50% Fire/Damage/Accuracy'], debuffs: [] },
            { id: 'spec18', name: 'Mythic', category: 'special', price: 1500000, health: 250, speed: 1.7, fireRate: 1.8, damage: 2.5, accuracy: 1.6, buffs: ['+150% Health', '+70% Speed', '+80% Fire Rate', '+150% Damage'], debuffs: [] },
            { id: 'spec19', name: 'Divine', category: 'special', price: 3000000, health: 350, speed: 2.0, fireRate: 2.0, damage: 3.0, accuracy: 1.8, buffs: ['+250% Health', '+100% Speed', '+100% Fire Rate', '+200% Damage'], debuffs: [] },
            
            // EXTENDED SPEED SHIPS (60 more)
            { id: 'spd21', name: 'Wind Rider', category: 'speed', price: 650, health: 82, speed: 1.25, fireRate: 0.95, damage: 0.92, accuracy: 1.05, buffs: ['+25% Speed', '+5% Accuracy'], debuffs: ['-18% Health', '-8% Damage'] },
            { id: 'spd22', name: 'Gale Force', category: 'speed', price: 900, health: 78, speed: 1.35, fireRate: 1.05, damage: 0.88, accuracy: 0.98, buffs: ['+35% Speed', '+5% Fire Rate'], debuffs: ['-22% Health', '-12% Damage'] },
            { id: 'spd23', name: 'Breeze', category: 'speed', price: 1500, health: 85, speed: 1.28, fireRate: 1.0, damage: 0.95, accuracy: 1.1, buffs: ['+28% Speed', '+10% Accuracy'], debuffs: ['-15% Health'] },
            { id: 'spd24', name: 'Tailwind', category: 'speed', price: 1800, health: 72, speed: 1.42, fireRate: 1.08, damage: 0.82, accuracy: 1.02, buffs: ['+42% Speed', '+8% Fire Rate'], debuffs: ['-28% Health', '-18% Damage'] },
            { id: 'spd25', name: 'Cyclone', category: 'speed', price: 2800, health: 68, speed: 1.55, fireRate: 0.92, damage: 1.05, accuracy: 0.88, buffs: ['+55% Speed', '+5% Damage'], debuffs: ['-32% Health', '-12% Accuracy'] },
            { id: 'spd26', name: 'Tornado', category: 'speed', price: 3500, health: 75, speed: 1.48, fireRate: 1.12, damage: 0.88, accuracy: 0.95, buffs: ['+48% Speed', '+12% Fire Rate'], debuffs: ['-25% Health', '-12% Damage'] },
            { id: 'spd27', name: 'Whirlwind', category: 'speed', price: 4200, health: 62, speed: 1.62, fireRate: 1.0, damage: 0.92, accuracy: 1.08, buffs: ['+62% Speed', '+8% Accuracy'], debuffs: ['-38% Health'] },
            { id: 'spd28', name: 'Monsoon', category: 'speed', price: 6000, health: 70, speed: 1.58, fireRate: 1.18, damage: 0.85, accuracy: 1.0, buffs: ['+58% Speed', '+18% Fire Rate'], debuffs: ['-30% Health', '-15% Damage'] },
            { id: 'spd29', name: 'Squall', category: 'speed', price: 7000, health: 58, speed: 1.72, fireRate: 0.95, damage: 1.1, accuracy: 0.85, buffs: ['+72% Speed', '+10% Damage'], debuffs: ['-42% Health', '-15% Accuracy'] },
            { id: 'spd30', name: 'Draft', category: 'speed', price: 9000, health: 65, speed: 1.75, fireRate: 1.08, damage: 0.9, accuracy: 1.05, buffs: ['+75% Speed', '+8% Fire Rate', '+5% Accuracy'], debuffs: ['-35% Health', '-10% Damage'] },
            { id: 'spd31', name: 'Gust', category: 'speed', price: 10500, health: 55, speed: 1.85, fireRate: 1.0, damage: 0.98, accuracy: 0.92, buffs: ['+85% Speed'], debuffs: ['-45% Health', '-8% Accuracy'] },
            { id: 'spd32', name: 'Sirocco', category: 'speed', price: 13000, health: 68, speed: 1.78, fireRate: 1.22, damage: 0.82, accuracy: 1.12, buffs: ['+78% Speed', '+22% Fire Rate', '+12% Accuracy'], debuffs: ['-32% Health', '-18% Damage'] },
            { id: 'spd33', name: 'Mistral', category: 'speed', price: 15000, health: 52, speed: 1.92, fireRate: 1.05, damage: 1.02, accuracy: 0.88, buffs: ['+92% Speed', '+5% Fire Rate'], debuffs: ['-48% Health', '-12% Accuracy'] },
            { id: 'spd34', name: 'Chinook', category: 'speed', price: 20000, health: 62, speed: 1.88, fireRate: 1.15, damage: 0.88, accuracy: 1.08, buffs: ['+88% Speed', '+15% Fire Rate', '+8% Accuracy'], debuffs: ['-38% Health', '-12% Damage'] },
            { id: 'spd35', name: 'Zonda', category: 'speed', price: 22000, health: 48, speed: 2.05, fireRate: 0.9, damage: 1.15, accuracy: 0.82, buffs: ['+105% Speed', '+15% Damage'], debuffs: ['-52% Health', '-18% Accuracy'] },
            { id: 'spd36', name: 'Tramontane', category: 'speed', price: 28000, health: 58, speed: 1.95, fireRate: 1.25, damage: 0.8, accuracy: 1.15, buffs: ['+95% Speed', '+25% Fire Rate', '+15% Accuracy'], debuffs: ['-42% Health', '-20% Damage'] },
            { id: 'spd37', name: 'Bora', category: 'speed', price: 32000, health: 52, speed: 2.08, fireRate: 1.1, damage: 0.92, accuracy: 1.0, buffs: ['+108% Speed', '+10% Fire Rate'], debuffs: ['-48% Health', '-8% Damage'] },
            { id: 'spd38', name: 'Foehn', category: 'speed', price: 38000, health: 60, speed: 2.0, fireRate: 1.2, damage: 0.85, accuracy: 1.1, buffs: ['+100% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-40% Health', '-15% Damage'] },
            { id: 'spd39', name: 'Khamsin', category: 'speed', price: 42000, health: 45, speed: 2.18, fireRate: 0.95, damage: 1.2, accuracy: 0.78, buffs: ['+118% Speed', '+20% Damage'], debuffs: ['-55% Health', '-22% Accuracy'] },
            { id: 'spd40', name: 'Harmattan', category: 'speed', price: 48000, health: 55, speed: 2.12, fireRate: 1.28, damage: 0.78, accuracy: 1.18, buffs: ['+112% Speed', '+28% Fire Rate', '+18% Accuracy'], debuffs: ['-45% Health', '-22% Damage'] },
            { id: 'spd41', name: 'Levanter', category: 'speed', price: 55000, health: 58, speed: 2.15, fireRate: 1.12, damage: 0.9, accuracy: 1.05, buffs: ['+115% Speed', '+12% Fire Rate', '+5% Accuracy'], debuffs: ['-42% Health', '-10% Damage'] },
            { id: 'spd42', name: 'Shamal', category: 'speed', price: 62000, health: 48, speed: 2.25, fireRate: 1.0, damage: 1.0, accuracy: 0.95, buffs: ['+125% Speed'], debuffs: ['-52% Health', '-5% Accuracy'] },
            { id: 'spd43', name: 'Etesian', category: 'speed', price: 72000, health: 52, speed: 2.28, fireRate: 1.18, damage: 0.85, accuracy: 1.12, buffs: ['+128% Speed', '+18% Fire Rate', '+12% Accuracy'], debuffs: ['-48% Health', '-15% Damage'] },
            { id: 'spd44', name: 'Pampero', category: 'speed', price: 82000, health: 42, speed: 2.38, fireRate: 0.92, damage: 1.25, accuracy: 0.75, buffs: ['+138% Speed', '+25% Damage'], debuffs: ['-58% Health', '-25% Accuracy'] },
            { id: 'spd45', name: 'Williwaw', category: 'speed', price: 95000, health: 55, speed: 2.32, fireRate: 1.25, damage: 0.82, accuracy: 1.15, buffs: ['+132% Speed', '+25% Fire Rate', '+15% Accuracy'], debuffs: ['-45% Health', '-18% Damage'] },
            { id: 'spd46', name: 'Derecho', category: 'speed', price: 110000, health: 48, speed: 2.42, fireRate: 1.1, damage: 0.95, accuracy: 1.02, buffs: ['+142% Speed', '+10% Fire Rate'], debuffs: ['-52% Health', '-5% Damage'] },
            { id: 'spd47', name: 'Haboob', category: 'speed', price: 125000, health: 52, speed: 2.45, fireRate: 1.2, damage: 0.88, accuracy: 1.1, buffs: ['+145% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-48% Health', '-12% Damage'] },
            { id: 'spd48', name: 'Nor Easter', category: 'speed', price: 140000, health: 45, speed: 2.55, fireRate: 1.0, damage: 1.05, accuracy: 0.9, buffs: ['+155% Speed', '+5% Damage'], debuffs: ['-55% Health', '-10% Accuracy'] },
            { id: 'spd49', name: 'Southeaster', category: 'speed', price: 160000, health: 50, speed: 2.52, fireRate: 1.28, damage: 0.8, accuracy: 1.2, buffs: ['+152% Speed', '+28% Fire Rate', '+20% Accuracy'], debuffs: ['-50% Health', '-20% Damage'] },
            { id: 'spd50', name: 'Westerly', category: 'speed', price: 180000, health: 55, speed: 2.48, fireRate: 1.15, damage: 0.92, accuracy: 1.08, buffs: ['+148% Speed', '+15% Fire Rate', '+8% Accuracy'], debuffs: ['-45% Health', '-8% Damage'] },
            { id: 'spd51', name: 'Norther', category: 'speed', price: 220000, health: 42, speed: 2.65, fireRate: 1.02, damage: 1.1, accuracy: 0.85, buffs: ['+165% Speed', '+10% Damage'], debuffs: ['-58% Health', '-15% Accuracy'] },
            { id: 'spd52', name: 'Easterly', category: 'speed', price: 250000, health: 48, speed: 2.62, fireRate: 1.22, damage: 0.85, accuracy: 1.15, buffs: ['+162% Speed', '+22% Fire Rate', '+15% Accuracy'], debuffs: ['-52% Health', '-15% Damage'] },
            { id: 'spd53', name: 'Jet Stream', category: 'speed', price: 280000, health: 52, speed: 2.68, fireRate: 1.12, damage: 0.9, accuracy: 1.05, buffs: ['+168% Speed', '+12% Fire Rate', '+5% Accuracy'], debuffs: ['-48% Health', '-10% Damage'] },
            { id: 'spd54', name: 'Trade Wind', category: 'speed', price: 320000, health: 45, speed: 2.75, fireRate: 1.0, damage: 1.0, accuracy: 1.0, buffs: ['+175% Speed'], debuffs: ['-55% Health'] },
            { id: 'spd55', name: 'Polar Vortex', category: 'speed', price: 360000, health: 38, speed: 2.85, fireRate: 1.32, damage: 0.75, accuracy: 1.22, buffs: ['+185% Speed', '+32% Fire Rate', '+22% Accuracy'], debuffs: ['-62% Health', '-25% Damage'] },
            { id: 'spd56', name: 'Convergence', category: 'speed', price: 420000, health: 50, speed: 2.78, fireRate: 1.18, damage: 0.88, accuracy: 1.1, buffs: ['+178% Speed', '+18% Fire Rate', '+10% Accuracy'], debuffs: ['-50% Health', '-12% Damage'] },
            { id: 'spd57', name: 'Front Runner', category: 'speed', price: 480000, health: 42, speed: 2.88, fireRate: 1.08, damage: 0.98, accuracy: 0.95, buffs: ['+188% Speed', '+8% Fire Rate'], debuffs: ['-58% Health', '-5% Accuracy'] },
            { id: 'spd58', name: 'Pressure Drop', category: 'speed', price: 550000, health: 48, speed: 2.82, fireRate: 1.25, damage: 0.82, accuracy: 1.18, buffs: ['+182% Speed', '+25% Fire Rate', '+18% Accuracy'], debuffs: ['-52% Health', '-18% Damage'] },
            { id: 'spd59', name: 'Storm Chaser', category: 'speed', price: 620000, health: 45, speed: 2.92, fireRate: 1.15, damage: 0.92, accuracy: 1.05, buffs: ['+192% Speed', '+15% Fire Rate', '+5% Accuracy'], debuffs: ['-55% Health', '-8% Damage'] },
            { id: 'spd60', name: 'Air Current', category: 'speed', price: 700000, health: 52, speed: 2.95, fireRate: 1.2, damage: 0.88, accuracy: 1.12, buffs: ['+195% Speed', '+20% Fire Rate', '+12% Accuracy'], debuffs: ['-48% Health', '-12% Damage'] },
            { id: 'spd61', name: 'Velocity Max', category: 'speed', price: 800000, health: 40, speed: 3.1, fireRate: 1.0, damage: 1.0, accuracy: 0.9, buffs: ['+210% Speed'], debuffs: ['-60% Health', '-10% Accuracy'] },
            { id: 'spd62', name: 'Mach One', category: 'speed', price: 900000, health: 45, speed: 3.08, fireRate: 1.28, damage: 0.8, accuracy: 1.2, buffs: ['+208% Speed', '+28% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-20% Damage'] },
            { id: 'spd63', name: 'Afterburner', category: 'speed', price: 1100000, health: 38, speed: 3.25, fireRate: 1.12, damage: 0.95, accuracy: 1.0, buffs: ['+225% Speed', '+12% Fire Rate'], debuffs: ['-62% Health', '-5% Damage'] },
            { id: 'spd64', name: 'Rocket Sled', category: 'speed', price: 1300000, health: 42, speed: 3.3, fireRate: 1.35, damage: 0.78, accuracy: 1.22, buffs: ['+230% Speed', '+35% Fire Rate', '+22% Accuracy'], debuffs: ['-58% Health', '-22% Damage'] },
            { id: 'spd65', name: 'Warp Drive', category: 'speed', price: 1500000, health: 48, speed: 3.35, fireRate: 1.2, damage: 0.88, accuracy: 1.1, buffs: ['+235% Speed', '+20% Fire Rate', '+10% Accuracy'], debuffs: ['-52% Health', '-12% Damage'] },
            { id: 'spd66', name: 'Light Skipper', category: 'speed', price: 1800000, health: 35, speed: 3.45, fireRate: 1.42, damage: 0.72, accuracy: 1.28, buffs: ['+245% Speed', '+42% Fire Rate', '+28% Accuracy'], debuffs: ['-65% Health', '-28% Damage'] },
            { id: 'spd67', name: 'Event Horizon', category: 'speed', price: 2200000, health: 42, speed: 3.55, fireRate: 1.25, damage: 0.85, accuracy: 1.15, buffs: ['+255% Speed', '+25% Fire Rate', '+15% Accuracy'], debuffs: ['-58% Health', '-15% Damage'] },
            { id: 'spd68', name: 'Tachyon', category: 'speed', price: 2500000, health: 38, speed: 3.65, fireRate: 1.1, damage: 0.95, accuracy: 1.02, buffs: ['+265% Speed', '+10% Fire Rate'], debuffs: ['-62% Health', '-5% Damage'] },
            { id: 'spd69', name: 'Neutrino', category: 'speed', price: 3000000, health: 45, speed: 3.72, fireRate: 1.32, damage: 0.82, accuracy: 1.2, buffs: ['+272% Speed', '+32% Fire Rate', '+20% Accuracy'], debuffs: ['-55% Health', '-18% Damage'] },
            { id: 'spd70', name: 'Photon Rush', category: 'speed', price: 3500000, health: 35, speed: 3.85, fireRate: 1.45, damage: 0.75, accuracy: 1.32, buffs: ['+285% Speed', '+45% Fire Rate', '+32% Accuracy'], debuffs: ['-65% Health', '-25% Damage'] },
            { id: 'spd71', name: 'Quasar', category: 'speed', price: 4000000, health: 40, speed: 3.9, fireRate: 1.22, damage: 0.9, accuracy: 1.12, buffs: ['+290% Speed', '+22% Fire Rate', '+12% Accuracy'], debuffs: ['-60% Health', '-10% Damage'] },
            { id: 'spd72', name: 'Pulsar', category: 'speed', price: 4500000, health: 38, speed: 4.0, fireRate: 1.35, damage: 0.82, accuracy: 1.22, buffs: ['+300% Speed', '+35% Fire Rate', '+22% Accuracy'], debuffs: ['-62% Health', '-18% Damage'] },
            { id: 'spd73', name: 'Blazar', category: 'speed', price: 5000000, health: 42, speed: 4.1, fireRate: 1.18, damage: 0.92, accuracy: 1.08, buffs: ['+310% Speed', '+18% Fire Rate', '+8% Accuracy'], debuffs: ['-58% Health', '-8% Damage'] },
            { id: 'spd74', name: 'Magnetar', category: 'speed', price: 6000000, health: 35, speed: 4.25, fireRate: 1.5, damage: 0.72, accuracy: 1.35, buffs: ['+325% Speed', '+50% Fire Rate', '+35% Accuracy'], debuffs: ['-65% Health', '-28% Damage'] },
            { id: 'spd75', name: 'Gamma Ray', category: 'speed', price: 7000000, health: 40, speed: 4.35, fireRate: 1.28, damage: 0.85, accuracy: 1.18, buffs: ['+335% Speed', '+28% Fire Rate', '+18% Accuracy'], debuffs: ['-60% Health', '-15% Damage'] },
            { id: 'spd76', name: 'X-Ray', category: 'speed', price: 8000000, health: 38, speed: 4.5, fireRate: 1.4, damage: 0.78, accuracy: 1.28, buffs: ['+350% Speed', '+40% Fire Rate', '+28% Accuracy'], debuffs: ['-62% Health', '-22% Damage'] },
            { id: 'spd77', name: 'Cosmic Ray', category: 'speed', price: 9000000, health: 42, speed: 4.6, fireRate: 1.25, damage: 0.88, accuracy: 1.15, buffs: ['+360% Speed', '+25% Fire Rate', '+15% Accuracy'], debuffs: ['-58% Health', '-12% Damage'] },
            { id: 'spd78', name: 'Solar Wind', category: 'speed', price: 10000000, health: 35, speed: 4.8, fireRate: 1.55, damage: 0.7, accuracy: 1.4, buffs: ['+380% Speed', '+55% Fire Rate', '+40% Accuracy'], debuffs: ['-65% Health', '-30% Damage'] },
            { id: 'spd79', name: 'Stellar Stream', category: 'speed', price: 12000000, health: 40, speed: 4.9, fireRate: 1.35, damage: 0.82, accuracy: 1.25, buffs: ['+390% Speed', '+35% Fire Rate', '+25% Accuracy'], debuffs: ['-60% Health', '-18% Damage'] },
            { id: 'spd80', name: 'Infinity Speed', category: 'speed', price: 15000000, health: 32, speed: 5.0, fireRate: 1.6, damage: 0.65, accuracy: 1.45, buffs: ['+400% Speed', '+60% Fire Rate', '+45% Accuracy'], debuffs: ['-68% Health', '-35% Damage'] },
            
            // EXTENDED TANK SHIPS (60 more)
            { id: 'tnk21', name: 'Plated Hull', category: 'tank', price: 650, health: 135, speed: 0.82, fireRate: 1.02, damage: 0.98, accuracy: 1.0, buffs: ['+35% Health'], debuffs: ['-18% Speed'] },
            { id: 'tnk22', name: 'Reinforced', category: 'tank', price: 900, health: 150, speed: 0.78, fireRate: 0.95, damage: 1.05, accuracy: 0.98, buffs: ['+50% Health', '+5% Damage'], debuffs: ['-22% Speed', '-5% Fire Rate'] },
            { id: 'tnk23', name: 'Bulwark', category: 'tank', price: 1500, health: 165, speed: 0.72, fireRate: 1.0, damage: 1.02, accuracy: 0.95, buffs: ['+65% Health'], debuffs: ['-28% Speed', '-5% Accuracy'] },
            { id: 'tnk24', name: 'Bastion', category: 'tank', price: 1800, health: 175, speed: 0.68, fireRate: 0.88, damage: 1.15, accuracy: 0.92, buffs: ['+75% Health', '+15% Damage'], debuffs: ['-32% Speed', '-12% Fire Rate'] },
            { id: 'tnk25', name: 'Rampart', category: 'tank', price: 2800, health: 190, speed: 0.72, fireRate: 0.92, damage: 1.08, accuracy: 1.0, buffs: ['+90% Health', '+8% Damage'], debuffs: ['-28% Speed', '-8% Fire Rate'] },
            { id: 'tnk26', name: 'Citadel', category: 'tank', price: 3500, health: 210, speed: 0.62, fireRate: 0.85, damage: 1.25, accuracy: 0.88, buffs: ['+110% Health', '+25% Damage'], debuffs: ['-38% Speed', '-15% Fire Rate', '-12% Accuracy'] },
            { id: 'tnk27', name: 'Stronghold', category: 'tank', price: 4200, health: 195, speed: 0.75, fireRate: 0.98, damage: 1.05, accuracy: 0.95, buffs: ['+95% Health', '+5% Damage'], debuffs: ['-25% Speed'] },
            { id: 'tnk28', name: 'Keep', category: 'tank', price: 6000, health: 225, speed: 0.58, fireRate: 0.82, damage: 1.32, accuracy: 0.85, buffs: ['+125% Health', '+32% Damage'], debuffs: ['-42% Speed', '-18% Fire Rate', '-15% Accuracy'] },
            { id: 'tnk29', name: 'Redoubt', category: 'tank', price: 7000, health: 205, speed: 0.72, fireRate: 0.95, damage: 1.12, accuracy: 0.98, buffs: ['+105% Health', '+12% Damage'], debuffs: ['-28% Speed', '-5% Fire Rate'] },
            { id: 'tnk30', name: 'Parapet', category: 'tank', price: 9000, health: 240, speed: 0.55, fireRate: 0.78, damage: 1.4, accuracy: 0.82, buffs: ['+140% Health', '+40% Damage'], debuffs: ['-45% Speed', '-22% Fire Rate', '-18% Accuracy'] },
            { id: 'tnk31', name: 'Battlement', category: 'tank', price: 10500, health: 220, speed: 0.68, fireRate: 0.92, damage: 1.18, accuracy: 0.95, buffs: ['+120% Health', '+18% Damage'], debuffs: ['-32% Speed', '-8% Fire Rate'] },
            { id: 'tnk32', name: 'Tower', category: 'tank', price: 13000, health: 260, speed: 0.52, fireRate: 0.75, damage: 1.48, accuracy: 0.78, buffs: ['+160% Health', '+48% Damage'], debuffs: ['-48% Speed', '-25% Fire Rate', '-22% Accuracy'] },
            { id: 'tnk33', name: 'Garrison', category: 'tank', price: 15000, health: 235, speed: 0.65, fireRate: 0.88, damage: 1.25, accuracy: 0.92, buffs: ['+135% Health', '+25% Damage'], debuffs: ['-35% Speed', '-12% Fire Rate'] },
            { id: 'tnk34', name: 'Barricade', category: 'tank', price: 20000, health: 280, speed: 0.48, fireRate: 0.72, damage: 1.55, accuracy: 0.75, buffs: ['+180% Health', '+55% Damage'], debuffs: ['-52% Speed', '-28% Fire Rate', '-25% Accuracy'] },
            { id: 'tnk35', name: 'Blockade', category: 'tank', price: 22000, health: 250, speed: 0.62, fireRate: 0.85, damage: 1.32, accuracy: 0.88, buffs: ['+150% Health', '+32% Damage'], debuffs: ['-38% Speed', '-15% Fire Rate', '-12% Accuracy'] },
            { id: 'tnk36', name: 'Shield Wall', category: 'tank', price: 28000, health: 300, speed: 0.45, fireRate: 0.68, damage: 1.62, accuracy: 0.72, buffs: ['+200% Health', '+62% Damage'], debuffs: ['-55% Speed', '-32% Fire Rate', '-28% Accuracy'] },
            { id: 'tnk37', name: 'Iron Curtain', category: 'tank', price: 32000, health: 270, speed: 0.58, fireRate: 0.82, damage: 1.4, accuracy: 0.85, buffs: ['+170% Health', '+40% Damage'], debuffs: ['-42% Speed', '-18% Fire Rate', '-15% Accuracy'] },
            { id: 'tnk38', name: 'Steel Barrier', category: 'tank', price: 38000, health: 320, speed: 0.42, fireRate: 0.65, damage: 1.7, accuracy: 0.68, buffs: ['+220% Health', '+70% Damage'], debuffs: ['-58% Speed', '-35% Fire Rate', '-32% Accuracy'] },
            { id: 'tnk39', name: 'Titanium Wall', category: 'tank', price: 42000, health: 290, speed: 0.55, fireRate: 0.78, damage: 1.48, accuracy: 0.82, buffs: ['+190% Health', '+48% Damage'], debuffs: ['-45% Speed', '-22% Fire Rate', '-18% Accuracy'] },
            { id: 'tnk40', name: 'Adamantine', category: 'tank', price: 48000, health: 340, speed: 0.38, fireRate: 0.62, damage: 1.78, accuracy: 0.65, buffs: ['+240% Health', '+78% Damage'], debuffs: ['-62% Speed', '-38% Fire Rate', '-35% Accuracy'] },
            { id: 'tnk41', name: 'Mithril Hull', category: 'tank', price: 55000, health: 310, speed: 0.52, fireRate: 0.75, damage: 1.55, accuracy: 0.78, buffs: ['+210% Health', '+55% Damage'], debuffs: ['-48% Speed', '-25% Fire Rate', '-22% Accuracy'] },
            { id: 'tnk42', name: 'Orichalcum', category: 'tank', price: 62000, health: 360, speed: 0.35, fireRate: 0.58, damage: 1.85, accuracy: 0.62, buffs: ['+260% Health', '+85% Damage'], debuffs: ['-65% Speed', '-42% Fire Rate', '-38% Accuracy'] },
            { id: 'tnk43', name: 'Diamond Plate', category: 'tank', price: 72000, health: 330, speed: 0.48, fireRate: 0.72, damage: 1.62, accuracy: 0.75, buffs: ['+230% Health', '+62% Damage'], debuffs: ['-52% Speed', '-28% Fire Rate', '-25% Accuracy'] },
            { id: 'tnk44', name: 'Neutronium', category: 'tank', price: 82000, health: 380, speed: 0.32, fireRate: 0.55, damage: 1.92, accuracy: 0.58, buffs: ['+280% Health', '+92% Damage'], debuffs: ['-68% Speed', '-45% Fire Rate', '-42% Accuracy'] },
            { id: 'tnk45', name: 'Dark Matter', category: 'tank', price: 95000, health: 350, speed: 0.45, fireRate: 0.68, damage: 1.7, accuracy: 0.72, buffs: ['+250% Health', '+70% Damage'], debuffs: ['-55% Speed', '-32% Fire Rate', '-28% Accuracy'] },
            { id: 'tnk46', name: 'Event Shield', category: 'tank', price: 110000, health: 400, speed: 0.28, fireRate: 0.52, damage: 2.0, accuracy: 0.55, buffs: ['+300% Health', '+100% Damage'], debuffs: ['-72% Speed', '-48% Fire Rate', '-45% Accuracy'] },
            { id: 'tnk47', name: 'Singularity', category: 'tank', price: 125000, health: 370, speed: 0.42, fireRate: 0.65, damage: 1.78, accuracy: 0.68, buffs: ['+270% Health', '+78% Damage'], debuffs: ['-58% Speed', '-35% Fire Rate', '-32% Accuracy'] },
            { id: 'tnk48', name: 'Black Hole', category: 'tank', price: 140000, health: 420, speed: 0.25, fireRate: 0.48, damage: 2.08, accuracy: 0.52, buffs: ['+320% Health', '+108% Damage'], debuffs: ['-75% Speed', '-52% Fire Rate', '-48% Accuracy'] },
            { id: 'tnk49', name: 'Nebula Core', category: 'tank', price: 160000, health: 390, speed: 0.38, fireRate: 0.62, damage: 1.85, accuracy: 0.65, buffs: ['+290% Health', '+85% Damage'], debuffs: ['-62% Speed', '-38% Fire Rate', '-35% Accuracy'] },
            { id: 'tnk50', name: 'Galactic Fort', category: 'tank', price: 180000, health: 440, speed: 0.22, fireRate: 0.45, damage: 2.15, accuracy: 0.48, buffs: ['+340% Health', '+115% Damage'], debuffs: ['-78% Speed', '-55% Fire Rate', '-52% Accuracy'] },
            { id: 'tnk51', name: 'Universe Wall', category: 'tank', price: 220000, health: 410, speed: 0.35, fireRate: 0.58, damage: 1.92, accuracy: 0.62, buffs: ['+310% Health', '+92% Damage'], debuffs: ['-65% Speed', '-42% Fire Rate', '-38% Accuracy'] },
            { id: 'tnk52', name: 'Cosmic Shield', category: 'tank', price: 250000, health: 460, speed: 0.2, fireRate: 0.42, damage: 2.22, accuracy: 0.45, buffs: ['+360% Health', '+122% Damage'], debuffs: ['-80% Speed', '-58% Fire Rate', '-55% Accuracy'] },
            { id: 'tnk53', name: 'Dimension Wall', category: 'tank', price: 280000, health: 430, speed: 0.32, fireRate: 0.55, damage: 2.0, accuracy: 0.58, buffs: ['+330% Health', '+100% Damage'], debuffs: ['-68% Speed', '-45% Fire Rate', '-42% Accuracy'] },
            { id: 'tnk54', name: 'Reality Anchor', category: 'tank', price: 320000, health: 480, speed: 0.18, fireRate: 0.38, damage: 2.3, accuracy: 0.42, buffs: ['+380% Health', '+130% Damage'], debuffs: ['-82% Speed', '-62% Fire Rate', '-58% Accuracy'] },
            { id: 'tnk55', name: 'Multiverse Fort', category: 'tank', price: 360000, health: 450, speed: 0.28, fireRate: 0.52, damage: 2.08, accuracy: 0.55, buffs: ['+350% Health', '+108% Damage'], debuffs: ['-72% Speed', '-48% Fire Rate', '-45% Accuracy'] },
            { id: 'tnk56', name: 'Omni Shield', category: 'tank', price: 420000, health: 500, speed: 0.15, fireRate: 0.35, damage: 2.38, accuracy: 0.38, buffs: ['+400% Health', '+138% Damage'], debuffs: ['-85% Speed', '-65% Fire Rate', '-62% Accuracy'] },
            { id: 'tnk57', name: 'Infinity Fort', category: 'tank', price: 480000, health: 470, speed: 0.25, fireRate: 0.48, damage: 2.15, accuracy: 0.52, buffs: ['+370% Health', '+115% Damage'], debuffs: ['-75% Speed', '-52% Fire Rate', '-48% Accuracy'] },
            { id: 'tnk58', name: 'Eternal Wall', category: 'tank', price: 550000, health: 520, speed: 0.12, fireRate: 0.32, damage: 2.45, accuracy: 0.35, buffs: ['+420% Health', '+145% Damage'], debuffs: ['-88% Speed', '-68% Fire Rate', '-65% Accuracy'] },
            { id: 'tnk59', name: 'Timeless Fort', category: 'tank', price: 620000, health: 490, speed: 0.22, fireRate: 0.45, damage: 2.22, accuracy: 0.48, buffs: ['+390% Health', '+122% Damage'], debuffs: ['-78% Speed', '-55% Fire Rate', '-52% Accuracy'] },
            { id: 'tnk60', name: 'Absolute Defense', category: 'tank', price: 700000, health: 540, speed: 0.1, fireRate: 0.28, damage: 2.52, accuracy: 0.32, buffs: ['+440% Health', '+152% Damage'], debuffs: ['-90% Speed', '-72% Fire Rate', '-68% Accuracy'] },
            { id: 'tnk61', name: 'Void Fortress', category: 'tank', price: 800000, health: 510, speed: 0.18, fireRate: 0.42, damage: 2.3, accuracy: 0.45, buffs: ['+410% Health', '+130% Damage'], debuffs: ['-82% Speed', '-58% Fire Rate', '-55% Accuracy'] },
            { id: 'tnk62', name: 'Null Zone', category: 'tank', price: 900000, health: 560, speed: 0.08, fireRate: 0.25, damage: 2.6, accuracy: 0.28, buffs: ['+460% Health', '+160% Damage'], debuffs: ['-92% Speed', '-75% Fire Rate', '-72% Accuracy'] },
            { id: 'tnk63', name: 'Zero Point', category: 'tank', price: 1100000, health: 530, speed: 0.15, fireRate: 0.38, damage: 2.38, accuracy: 0.42, buffs: ['+430% Health', '+138% Damage'], debuffs: ['-85% Speed', '-62% Fire Rate', '-58% Accuracy'] },
            { id: 'tnk64', name: 'Absolute Zero', category: 'tank', price: 1300000, health: 580, speed: 0.06, fireRate: 0.22, damage: 2.68, accuracy: 0.25, buffs: ['+480% Health', '+168% Damage'], debuffs: ['-94% Speed', '-78% Fire Rate', '-75% Accuracy'] },
            { id: 'tnk65', name: 'Entropy Wall', category: 'tank', price: 1500000, health: 550, speed: 0.12, fireRate: 0.35, damage: 2.45, accuracy: 0.38, buffs: ['+450% Health', '+145% Damage'], debuffs: ['-88% Speed', '-65% Fire Rate', '-62% Accuracy'] },
            { id: 'tnk66', name: 'Heat Death', category: 'tank', price: 1800000, health: 600, speed: 0.05, fireRate: 0.2, damage: 2.75, accuracy: 0.22, buffs: ['+500% Health', '+175% Damage'], debuffs: ['-95% Speed', '-80% Fire Rate', '-78% Accuracy'] },
            { id: 'tnk67', name: 'Big Crunch', category: 'tank', price: 2200000, health: 570, speed: 0.1, fireRate: 0.32, damage: 2.52, accuracy: 0.35, buffs: ['+470% Health', '+152% Damage'], debuffs: ['-90% Speed', '-68% Fire Rate', '-65% Accuracy'] },
            { id: 'tnk68', name: 'Big Bang', category: 'tank', price: 2500000, health: 620, speed: 0.04, fireRate: 0.18, damage: 2.82, accuracy: 0.2, buffs: ['+520% Health', '+182% Damage'], debuffs: ['-96% Speed', '-82% Fire Rate', '-80% Accuracy'] },
            { id: 'tnk69', name: 'Primordial', category: 'tank', price: 3000000, health: 590, speed: 0.08, fireRate: 0.28, damage: 2.6, accuracy: 0.32, buffs: ['+490% Health', '+160% Damage'], debuffs: ['-92% Speed', '-72% Fire Rate', '-68% Accuracy'] },
            { id: 'tnk70', name: 'Genesis Shield', category: 'tank', price: 3500000, health: 640, speed: 0.03, fireRate: 0.15, damage: 2.9, accuracy: 0.18, buffs: ['+540% Health', '+190% Damage'], debuffs: ['-97% Speed', '-85% Fire Rate', '-82% Accuracy'] },
            { id: 'tnk71', name: 'Creation Fort', category: 'tank', price: 4000000, health: 610, speed: 0.06, fireRate: 0.25, damage: 2.68, accuracy: 0.28, buffs: ['+510% Health', '+168% Damage'], debuffs: ['-94% Speed', '-75% Fire Rate', '-72% Accuracy'] },
            { id: 'tnk72', name: 'Divine Shield', category: 'tank', price: 4500000, health: 660, speed: 0.02, fireRate: 0.12, damage: 2.98, accuracy: 0.15, buffs: ['+560% Health', '+198% Damage'], debuffs: ['-98% Speed', '-88% Fire Rate', '-85% Accuracy'] },
            { id: 'tnk73', name: 'Holy Fortress', category: 'tank', price: 5000000, health: 630, speed: 0.05, fireRate: 0.22, damage: 2.75, accuracy: 0.25, buffs: ['+530% Health', '+175% Damage'], debuffs: ['-95% Speed', '-78% Fire Rate', '-75% Accuracy'] },
            { id: 'tnk74', name: 'Sacred Wall', category: 'tank', price: 6000000, health: 680, speed: 0.02, fireRate: 0.1, damage: 3.05, accuracy: 0.12, buffs: ['+580% Health', '+205% Damage'], debuffs: ['-98% Speed', '-90% Fire Rate', '-88% Accuracy'] },
            { id: 'tnk75', name: 'Blessed Fort', category: 'tank', price: 7000000, health: 650, speed: 0.04, fireRate: 0.2, damage: 2.82, accuracy: 0.22, buffs: ['+550% Health', '+182% Damage'], debuffs: ['-96% Speed', '-80% Fire Rate', '-78% Accuracy'] },
            { id: 'tnk76', name: 'Angelic Shield', category: 'tank', price: 8000000, health: 700, speed: 0.02, fireRate: 0.08, damage: 3.12, accuracy: 0.1, buffs: ['+600% Health', '+212% Damage'], debuffs: ['-98% Speed', '-92% Fire Rate', '-90% Accuracy'] },
            { id: 'tnk77', name: 'Seraphim Wall', category: 'tank', price: 9000000, health: 670, speed: 0.03, fireRate: 0.18, damage: 2.9, accuracy: 0.2, buffs: ['+570% Health', '+190% Damage'], debuffs: ['-97% Speed', '-82% Fire Rate', '-80% Accuracy'] },
            { id: 'tnk78', name: 'Cherubim Fort', category: 'tank', price: 10000000, health: 720, speed: 0.02, fireRate: 0.06, damage: 3.2, accuracy: 0.08, buffs: ['+620% Health', '+220% Damage'], debuffs: ['-98% Speed', '-94% Fire Rate', '-92% Accuracy'] },
            { id: 'tnk79', name: 'Throne Shield', category: 'tank', price: 12000000, health: 690, speed: 0.03, fireRate: 0.15, damage: 2.98, accuracy: 0.18, buffs: ['+590% Health', '+198% Damage'], debuffs: ['-97% Speed', '-85% Fire Rate', '-82% Accuracy'] },
            { id: 'tnk80', name: 'Ultimate Tank', category: 'tank', price: 15000000, health: 750, speed: 0.01, fireRate: 0.05, damage: 3.3, accuracy: 0.05, buffs: ['+650% Health', '+230% Damage'], debuffs: ['-99% Speed', '-95% Fire Rate', '-95% Accuracy'] },
            
            // EXTENDED DAMAGE SHIPS (60 more)
            { id: 'dmg21', name: 'Pain Bringer', category: 'damage', price: 650, health: 92, speed: 0.95, fireRate: 0.92, damage: 1.35, accuracy: 1.05, buffs: ['+35% Damage', '+5% Accuracy'], debuffs: ['-8% Health', '-8% Fire Rate'] },
            { id: 'dmg22', name: 'Hurt Locker', category: 'damage', price: 900, health: 85, speed: 0.9, fireRate: 0.88, damage: 1.45, accuracy: 1.1, buffs: ['+45% Damage', '+10% Accuracy'], debuffs: ['-15% Health', '-12% Fire Rate'] },
            { id: 'dmg23', name: 'Wound Maker', category: 'damage', price: 1500, health: 95, speed: 0.98, fireRate: 0.95, damage: 1.38, accuracy: 1.02, buffs: ['+38% Damage'], debuffs: ['-5% Health', '-5% Fire Rate'] },
            { id: 'dmg24', name: 'Agony', category: 'damage', price: 1800, health: 82, speed: 0.85, fireRate: 0.82, damage: 1.55, accuracy: 1.15, buffs: ['+55% Damage', '+15% Accuracy'], debuffs: ['-18% Health', '-18% Fire Rate', '-15% Speed'] },
            { id: 'dmg25', name: 'Torment', category: 'damage', price: 2800, health: 90, speed: 0.92, fireRate: 0.9, damage: 1.48, accuracy: 1.08, buffs: ['+48% Damage', '+8% Accuracy'], debuffs: ['-10% Health', '-10% Fire Rate'] },
            { id: 'dmg26', name: 'Suffering', category: 'damage', price: 3500, health: 78, speed: 0.82, fireRate: 0.78, damage: 1.65, accuracy: 1.2, buffs: ['+65% Damage', '+20% Accuracy'], debuffs: ['-22% Health', '-22% Fire Rate', '-18% Speed'] },
            { id: 'dmg27', name: 'Misery', category: 'damage', price: 4200, health: 88, speed: 0.95, fireRate: 0.88, damage: 1.52, accuracy: 1.05, buffs: ['+52% Damage', '+5% Accuracy'], debuffs: ['-12% Health', '-12% Fire Rate'] },
            { id: 'dmg28', name: 'Anguish', category: 'damage', price: 6000, health: 75, speed: 0.78, fireRate: 0.75, damage: 1.75, accuracy: 1.25, buffs: ['+75% Damage', '+25% Accuracy'], debuffs: ['-25% Health', '-25% Fire Rate', '-22% Speed'] },
            { id: 'dmg29', name: 'Woe', category: 'damage', price: 7000, health: 85, speed: 0.92, fireRate: 0.85, damage: 1.58, accuracy: 1.1, buffs: ['+58% Damage', '+10% Accuracy'], debuffs: ['-15% Health', '-15% Fire Rate'] },
            { id: 'dmg30', name: 'Calamity', category: 'damage', price: 9000, health: 72, speed: 0.75, fireRate: 0.72, damage: 1.85, accuracy: 1.3, buffs: ['+85% Damage', '+30% Accuracy'], debuffs: ['-28% Health', '-28% Fire Rate', '-25% Speed'] },
            { id: 'dmg31', name: 'Catastrophe', category: 'damage', price: 10500, health: 82, speed: 0.88, fireRate: 0.82, damage: 1.65, accuracy: 1.15, buffs: ['+65% Damage', '+15% Accuracy'], debuffs: ['-18% Health', '-18% Fire Rate', '-12% Speed'] },
            { id: 'dmg32', name: 'Cataclysm', category: 'damage', price: 13000, health: 68, speed: 0.72, fireRate: 0.68, damage: 1.95, accuracy: 1.35, buffs: ['+95% Damage', '+35% Accuracy'], debuffs: ['-32% Health', '-32% Fire Rate', '-28% Speed'] },
            { id: 'dmg33', name: 'Apocalypse', category: 'damage', price: 15000, health: 78, speed: 0.85, fireRate: 0.78, damage: 1.72, accuracy: 1.2, buffs: ['+72% Damage', '+20% Accuracy'], debuffs: ['-22% Health', '-22% Fire Rate', '-15% Speed'] },
            { id: 'dmg34', name: 'Armageddon', category: 'damage', price: 20000, health: 65, speed: 0.68, fireRate: 0.65, damage: 2.05, accuracy: 1.4, buffs: ['+105% Damage', '+40% Accuracy'], debuffs: ['-35% Health', '-35% Fire Rate', '-32% Speed'] },
            { id: 'dmg35', name: 'Ragnarok', category: 'damage', price: 22000, health: 75, speed: 0.82, fireRate: 0.75, damage: 1.8, accuracy: 1.25, buffs: ['+80% Damage', '+25% Accuracy'], debuffs: ['-25% Health', '-25% Fire Rate', '-18% Speed'] },
            { id: 'dmg36', name: 'Doomsday', category: 'damage', price: 28000, health: 62, speed: 0.65, fireRate: 0.62, damage: 2.15, accuracy: 1.45, buffs: ['+115% Damage', '+45% Accuracy'], debuffs: ['-38% Health', '-38% Fire Rate', '-35% Speed'] },
            { id: 'dmg37', name: 'Extinction', category: 'damage', price: 32000, health: 72, speed: 0.78, fireRate: 0.72, damage: 1.88, accuracy: 1.3, buffs: ['+88% Damage', '+30% Accuracy'], debuffs: ['-28% Health', '-28% Fire Rate', '-22% Speed'] },
            { id: 'dmg38', name: 'Annihilation', category: 'damage', price: 38000, health: 58, speed: 0.62, fireRate: 0.58, damage: 2.25, accuracy: 1.5, buffs: ['+125% Damage', '+50% Accuracy'], debuffs: ['-42% Health', '-42% Fire Rate', '-38% Speed'] },
            { id: 'dmg39', name: 'Oblivion', category: 'damage', price: 42000, health: 68, speed: 0.75, fireRate: 0.68, damage: 1.95, accuracy: 1.35, buffs: ['+95% Damage', '+35% Accuracy'], debuffs: ['-32% Health', '-32% Fire Rate', '-25% Speed'] },
            { id: 'dmg40', name: 'Void Strike', category: 'damage', price: 48000, health: 55, speed: 0.58, fireRate: 0.55, damage: 2.35, accuracy: 1.55, buffs: ['+135% Damage', '+55% Accuracy'], debuffs: ['-45% Health', '-45% Fire Rate', '-42% Speed'] },
            { id: 'dmg41', name: 'Null Cannon', category: 'damage', price: 55000, health: 65, speed: 0.72, fireRate: 0.65, damage: 2.02, accuracy: 1.4, buffs: ['+102% Damage', '+40% Accuracy'], debuffs: ['-35% Health', '-35% Fire Rate', '-28% Speed'] },
            { id: 'dmg42', name: 'Zero Point Gun', category: 'damage', price: 62000, health: 52, speed: 0.55, fireRate: 0.52, damage: 2.45, accuracy: 1.6, buffs: ['+145% Damage', '+60% Accuracy'], debuffs: ['-48% Health', '-48% Fire Rate', '-45% Speed'] },
            { id: 'dmg43', name: 'Entropy Cannon', category: 'damage', price: 72000, health: 62, speed: 0.68, fireRate: 0.62, damage: 2.1, accuracy: 1.45, buffs: ['+110% Damage', '+45% Accuracy'], debuffs: ['-38% Health', '-38% Fire Rate', '-32% Speed'] },
            { id: 'dmg44', name: 'Chaos Cannon', category: 'damage', price: 82000, health: 48, speed: 0.52, fireRate: 0.48, damage: 2.55, accuracy: 1.65, buffs: ['+155% Damage', '+65% Accuracy'], debuffs: ['-52% Health', '-52% Fire Rate', '-48% Speed'] },
            { id: 'dmg45', name: 'Discord', category: 'damage', price: 95000, health: 58, speed: 0.65, fireRate: 0.58, damage: 2.18, accuracy: 1.5, buffs: ['+118% Damage', '+50% Accuracy'], debuffs: ['-42% Health', '-42% Fire Rate', '-35% Speed'] },
            { id: 'dmg46', name: 'Havoc', category: 'damage', price: 110000, health: 45, speed: 0.48, fireRate: 0.45, damage: 2.65, accuracy: 1.7, buffs: ['+165% Damage', '+70% Accuracy'], debuffs: ['-55% Health', '-55% Fire Rate', '-52% Speed'] },
            { id: 'dmg47', name: 'Mayhem', category: 'damage', price: 125000, health: 55, speed: 0.62, fireRate: 0.55, damage: 2.25, accuracy: 1.55, buffs: ['+125% Damage', '+55% Accuracy'], debuffs: ['-45% Health', '-45% Fire Rate', '-38% Speed'] },
            { id: 'dmg48', name: 'Pandemonium', category: 'damage', price: 140000, health: 42, speed: 0.45, fireRate: 0.42, damage: 2.75, accuracy: 1.75, buffs: ['+175% Damage', '+75% Accuracy'], debuffs: ['-58% Health', '-58% Fire Rate', '-55% Speed'] },
            { id: 'dmg49', name: 'Turmoil', category: 'damage', price: 160000, health: 52, speed: 0.58, fireRate: 0.52, damage: 2.32, accuracy: 1.6, buffs: ['+132% Damage', '+60% Accuracy'], debuffs: ['-48% Health', '-48% Fire Rate', '-42% Speed'] },
            { id: 'dmg50', name: 'Upheaval', category: 'damage', price: 180000, health: 38, speed: 0.42, fireRate: 0.38, damage: 2.85, accuracy: 1.8, buffs: ['+185% Damage', '+80% Accuracy'], debuffs: ['-62% Health', '-62% Fire Rate', '-58% Speed'] },
            { id: 'dmg51', name: 'Revolution', category: 'damage', price: 220000, health: 48, speed: 0.55, fireRate: 0.48, damage: 2.4, accuracy: 1.65, buffs: ['+140% Damage', '+65% Accuracy'], debuffs: ['-52% Health', '-52% Fire Rate', '-45% Speed'] },
            { id: 'dmg52', name: 'Insurrection', category: 'damage', price: 250000, health: 35, speed: 0.38, fireRate: 0.35, damage: 2.95, accuracy: 1.85, buffs: ['+195% Damage', '+85% Accuracy'], debuffs: ['-65% Health', '-65% Fire Rate', '-62% Speed'] },
            { id: 'dmg53', name: 'Rebellion', category: 'damage', price: 280000, health: 45, speed: 0.52, fireRate: 0.45, damage: 2.48, accuracy: 1.7, buffs: ['+148% Damage', '+70% Accuracy'], debuffs: ['-55% Health', '-55% Fire Rate', '-48% Speed'] },
            { id: 'dmg54', name: 'Revolt', category: 'damage', price: 320000, health: 32, speed: 0.35, fireRate: 0.32, damage: 3.05, accuracy: 1.9, buffs: ['+205% Damage', '+90% Accuracy'], debuffs: ['-68% Health', '-68% Fire Rate', '-65% Speed'] },
            { id: 'dmg55', name: 'Mutiny', category: 'damage', price: 360000, health: 42, speed: 0.48, fireRate: 0.42, damage: 2.55, accuracy: 1.75, buffs: ['+155% Damage', '+75% Accuracy'], debuffs: ['-58% Health', '-58% Fire Rate', '-52% Speed'] },
            { id: 'dmg56', name: 'Sedition', category: 'damage', price: 420000, health: 28, speed: 0.32, fireRate: 0.28, damage: 3.15, accuracy: 1.95, buffs: ['+215% Damage', '+95% Accuracy'], debuffs: ['-72% Health', '-72% Fire Rate', '-68% Speed'] },
            { id: 'dmg57', name: 'Anarchy', category: 'damage', price: 480000, health: 38, speed: 0.45, fireRate: 0.38, damage: 2.62, accuracy: 1.8, buffs: ['+162% Damage', '+80% Accuracy'], debuffs: ['-62% Health', '-62% Fire Rate', '-55% Speed'] },
            { id: 'dmg58', name: 'Chaos Lord', category: 'damage', price: 550000, health: 25, speed: 0.28, fireRate: 0.25, damage: 3.25, accuracy: 2.0, buffs: ['+225% Damage', '+100% Accuracy'], debuffs: ['-75% Health', '-75% Fire Rate', '-72% Speed'] },
            { id: 'dmg59', name: 'Entropy King', category: 'damage', price: 620000, health: 35, speed: 0.42, fireRate: 0.35, damage: 2.7, accuracy: 1.85, buffs: ['+170% Damage', '+85% Accuracy'], debuffs: ['-65% Health', '-65% Fire Rate', '-58% Speed'] },
            { id: 'dmg60', name: 'Void Emperor', category: 'damage', price: 700000, health: 22, speed: 0.25, fireRate: 0.22, damage: 3.35, accuracy: 2.05, buffs: ['+235% Damage', '+105% Accuracy'], debuffs: ['-78% Health', '-78% Fire Rate', '-75% Speed'] },
            { id: 'dmg61', name: 'Null Monarch', category: 'damage', price: 800000, health: 32, speed: 0.38, fireRate: 0.32, damage: 2.78, accuracy: 1.9, buffs: ['+178% Damage', '+90% Accuracy'], debuffs: ['-68% Health', '-68% Fire Rate', '-62% Speed'] },
            { id: 'dmg62', name: 'Zero Sovereign', category: 'damage', price: 900000, health: 18, speed: 0.22, fireRate: 0.18, damage: 3.45, accuracy: 2.1, buffs: ['+245% Damage', '+110% Accuracy'], debuffs: ['-82% Health', '-82% Fire Rate', '-78% Speed'] },
            { id: 'dmg63', name: 'Omega Destroyer', category: 'damage', price: 1100000, health: 28, speed: 0.35, fireRate: 0.28, damage: 2.85, accuracy: 1.95, buffs: ['+185% Damage', '+95% Accuracy'], debuffs: ['-72% Health', '-72% Fire Rate', '-65% Speed'] },
            { id: 'dmg64', name: 'Alpha Striker', category: 'damage', price: 1300000, health: 15, speed: 0.18, fireRate: 0.15, damage: 3.55, accuracy: 2.15, buffs: ['+255% Damage', '+115% Accuracy'], debuffs: ['-85% Health', '-85% Fire Rate', '-82% Speed'] },
            { id: 'dmg65', name: 'Prime Annihilator', category: 'damage', price: 1500000, health: 25, speed: 0.32, fireRate: 0.25, damage: 2.92, accuracy: 2.0, buffs: ['+192% Damage', '+100% Accuracy'], debuffs: ['-75% Health', '-75% Fire Rate', '-68% Speed'] },
            { id: 'dmg66', name: 'Ultimate Cannon', category: 'damage', price: 1800000, health: 12, speed: 0.15, fireRate: 0.12, damage: 3.65, accuracy: 2.2, buffs: ['+265% Damage', '+120% Accuracy'], debuffs: ['-88% Health', '-88% Fire Rate', '-85% Speed'] },
            { id: 'dmg67', name: 'Supreme Strike', category: 'damage', price: 2200000, health: 22, speed: 0.28, fireRate: 0.22, damage: 3.0, accuracy: 2.05, buffs: ['+200% Damage', '+105% Accuracy'], debuffs: ['-78% Health', '-78% Fire Rate', '-72% Speed'] },
            { id: 'dmg68', name: 'Infinite Damage', category: 'damage', price: 2500000, health: 10, speed: 0.12, fireRate: 0.1, damage: 3.75, accuracy: 2.25, buffs: ['+275% Damage', '+125% Accuracy'], debuffs: ['-90% Health', '-90% Fire Rate', '-88% Speed'] },
            { id: 'dmg69', name: 'Eternal Pain', category: 'damage', price: 3000000, health: 18, speed: 0.25, fireRate: 0.18, damage: 3.08, accuracy: 2.1, buffs: ['+208% Damage', '+110% Accuracy'], debuffs: ['-82% Health', '-82% Fire Rate', '-75% Speed'] },
            { id: 'dmg70', name: 'Timeless Fury', category: 'damage', price: 3500000, health: 8, speed: 0.1, fireRate: 0.08, damage: 3.85, accuracy: 2.3, buffs: ['+285% Damage', '+130% Accuracy'], debuffs: ['-92% Health', '-92% Fire Rate', '-90% Speed'] },
            { id: 'dmg71', name: 'Divine Wrath', category: 'damage', price: 4000000, health: 15, speed: 0.22, fireRate: 0.15, damage: 3.15, accuracy: 2.15, buffs: ['+215% Damage', '+115% Accuracy'], debuffs: ['-85% Health', '-85% Fire Rate', '-78% Speed'] },
            { id: 'dmg72', name: 'Holy Smite', category: 'damage', price: 4500000, health: 6, speed: 0.08, fireRate: 0.06, damage: 3.95, accuracy: 2.35, buffs: ['+295% Damage', '+135% Accuracy'], debuffs: ['-94% Health', '-94% Fire Rate', '-92% Speed'] },
            { id: 'dmg73', name: 'Sacred Strike', category: 'damage', price: 5000000, health: 12, speed: 0.18, fireRate: 0.12, damage: 3.22, accuracy: 2.2, buffs: ['+222% Damage', '+120% Accuracy'], debuffs: ['-88% Health', '-88% Fire Rate', '-82% Speed'] },
            { id: 'dmg74', name: 'Blessed Fury', category: 'damage', price: 6000000, health: 5, speed: 0.06, fireRate: 0.05, damage: 4.05, accuracy: 2.4, buffs: ['+305% Damage', '+140% Accuracy'], debuffs: ['-95% Health', '-95% Fire Rate', '-94% Speed'] },
            { id: 'dmg75', name: 'Angelic Wrath', category: 'damage', price: 7000000, health: 10, speed: 0.15, fireRate: 0.1, damage: 3.3, accuracy: 2.25, buffs: ['+230% Damage', '+125% Accuracy'], debuffs: ['-90% Health', '-90% Fire Rate', '-85% Speed'] },
            { id: 'dmg76', name: 'Seraphim Strike', category: 'damage', price: 8000000, health: 4, speed: 0.05, fireRate: 0.04, damage: 4.15, accuracy: 2.45, buffs: ['+315% Damage', '+145% Accuracy'], debuffs: ['-96% Health', '-96% Fire Rate', '-95% Speed'] },
            { id: 'dmg77', name: 'Cherubim Cannon', category: 'damage', price: 9000000, health: 8, speed: 0.12, fireRate: 0.08, damage: 3.38, accuracy: 2.3, buffs: ['+238% Damage', '+130% Accuracy'], debuffs: ['-92% Health', '-92% Fire Rate', '-88% Speed'] },
            { id: 'dmg78', name: 'Throne Fury', category: 'damage', price: 10000000, health: 3, speed: 0.04, fireRate: 0.03, damage: 4.25, accuracy: 2.5, buffs: ['+325% Damage', '+150% Accuracy'], debuffs: ['-97% Health', '-97% Fire Rate', '-96% Speed'] },
            { id: 'dmg79', name: 'Dominion Strike', category: 'damage', price: 12000000, health: 6, speed: 0.1, fireRate: 0.06, damage: 3.45, accuracy: 2.35, buffs: ['+245% Damage', '+135% Accuracy'], debuffs: ['-94% Health', '-94% Fire Rate', '-90% Speed'] },
            { id: 'dmg80', name: 'Ultimate Damage', category: 'damage', price: 15000000, health: 2, speed: 0.02, fireRate: 0.02, damage: 4.5, accuracy: 2.6, buffs: ['+350% Damage', '+160% Accuracy'], debuffs: ['-98% Health', '-98% Fire Rate', '-98% Speed'] },
            
            // EXTENDED BALANCED SHIPS (60 more)
            { id: 'bal21', name: 'Equilibrium', category: 'balanced', price: 650, health: 108, speed: 1.05, fireRate: 1.05, damage: 1.05, accuracy: 1.05, buffs: ['+5% All Stats'], debuffs: [] },
            { id: 'bal22', name: 'Poise', category: 'balanced', price: 900, health: 112, speed: 1.08, fireRate: 1.08, damage: 1.08, accuracy: 1.08, buffs: ['+8% All Stats'], debuffs: [] },
            { id: 'bal23', name: 'Steadfast', category: 'balanced', price: 1500, health: 118, speed: 1.1, fireRate: 1.1, damage: 1.1, accuracy: 1.1, buffs: ['+10% All Stats'], debuffs: [] },
            { id: 'bal24', name: 'Resolute', category: 'balanced', price: 1800, health: 125, speed: 1.12, fireRate: 1.12, damage: 1.12, accuracy: 1.12, buffs: ['+12% All Stats'], debuffs: [] },
            { id: 'bal25', name: 'Stalwart', category: 'balanced', price: 2800, health: 132, speed: 1.15, fireRate: 1.15, damage: 1.15, accuracy: 1.15, buffs: ['+15% All Stats'], debuffs: [] },
            { id: 'bal26', name: 'Unwavering', category: 'balanced', price: 3500, health: 140, speed: 1.18, fireRate: 1.18, damage: 1.18, accuracy: 1.18, buffs: ['+18% All Stats'], debuffs: [] },
            { id: 'bal27', name: 'Indomitable', category: 'balanced', price: 4200, health: 148, speed: 1.2, fireRate: 1.2, damage: 1.2, accuracy: 1.2, buffs: ['+20% All Stats'], debuffs: [] },
            { id: 'bal28', name: 'Unyielding', category: 'balanced', price: 6000, health: 155, speed: 1.22, fireRate: 1.22, damage: 1.22, accuracy: 1.22, buffs: ['+22% All Stats'], debuffs: [] },
            { id: 'bal29', name: 'Unbreakable', category: 'balanced', price: 7000, health: 162, speed: 1.25, fireRate: 1.25, damage: 1.25, accuracy: 1.25, buffs: ['+25% All Stats'], debuffs: [] },
            { id: 'bal30', name: 'Immovable', category: 'balanced', price: 9000, health: 170, speed: 1.28, fireRate: 1.28, damage: 1.28, accuracy: 1.28, buffs: ['+28% All Stats'], debuffs: [] },
            { id: 'bal31', name: 'Invincible', category: 'balanced', price: 10500, health: 178, speed: 1.3, fireRate: 1.3, damage: 1.3, accuracy: 1.3, buffs: ['+30% All Stats'], debuffs: [] },
            { id: 'bal32', name: 'Unconquerable', category: 'balanced', price: 13000, health: 185, speed: 1.32, fireRate: 1.32, damage: 1.32, accuracy: 1.32, buffs: ['+32% All Stats'], debuffs: [] },
            { id: 'bal33', name: 'Impregnable', category: 'balanced', price: 15000, health: 192, speed: 1.35, fireRate: 1.35, damage: 1.35, accuracy: 1.35, buffs: ['+35% All Stats'], debuffs: [] },
            { id: 'bal34', name: 'Insurmountable', category: 'balanced', price: 20000, health: 200, speed: 1.38, fireRate: 1.38, damage: 1.38, accuracy: 1.38, buffs: ['+38% All Stats'], debuffs: [] },
            { id: 'bal35', name: 'Unstoppable', category: 'balanced', price: 22000, health: 208, speed: 1.4, fireRate: 1.4, damage: 1.4, accuracy: 1.4, buffs: ['+40% All Stats'], debuffs: [] },
            { id: 'bal36', name: 'Relentless', category: 'balanced', price: 28000, health: 215, speed: 1.42, fireRate: 1.42, damage: 1.42, accuracy: 1.42, buffs: ['+42% All Stats'], debuffs: [] },
            { id: 'bal37', name: 'Persistent', category: 'balanced', price: 32000, health: 222, speed: 1.45, fireRate: 1.45, damage: 1.45, accuracy: 1.45, buffs: ['+45% All Stats'], debuffs: [] },
            { id: 'bal38', name: 'Tenacious', category: 'balanced', price: 38000, health: 230, speed: 1.48, fireRate: 1.48, damage: 1.48, accuracy: 1.48, buffs: ['+48% All Stats'], debuffs: [] },
            { id: 'bal39', name: 'Determined', category: 'balanced', price: 42000, health: 238, speed: 1.5, fireRate: 1.5, damage: 1.5, accuracy: 1.5, buffs: ['+50% All Stats'], debuffs: [] },
            { id: 'bal40', name: 'Resolute II', category: 'balanced', price: 48000, health: 245, speed: 1.52, fireRate: 1.52, damage: 1.52, accuracy: 1.52, buffs: ['+52% All Stats'], debuffs: [] },
            { id: 'bal41', name: 'Steadfast II', category: 'balanced', price: 55000, health: 252, speed: 1.55, fireRate: 1.55, damage: 1.55, accuracy: 1.55, buffs: ['+55% All Stats'], debuffs: [] },
            { id: 'bal42', name: 'Stalwart II', category: 'balanced', price: 62000, health: 260, speed: 1.58, fireRate: 1.58, damage: 1.58, accuracy: 1.58, buffs: ['+58% All Stats'], debuffs: [] },
            { id: 'bal43', name: 'Unwavering II', category: 'balanced', price: 72000, health: 268, speed: 1.6, fireRate: 1.6, damage: 1.6, accuracy: 1.6, buffs: ['+60% All Stats'], debuffs: [] },
            { id: 'bal44', name: 'Indomitable II', category: 'balanced', price: 82000, health: 275, speed: 1.62, fireRate: 1.62, damage: 1.62, accuracy: 1.62, buffs: ['+62% All Stats'], debuffs: [] },
            { id: 'bal45', name: 'Unyielding II', category: 'balanced', price: 95000, health: 282, speed: 1.65, fireRate: 1.65, damage: 1.65, accuracy: 1.65, buffs: ['+65% All Stats'], debuffs: [] },
            { id: 'bal46', name: 'Unbreakable II', category: 'balanced', price: 110000, health: 290, speed: 1.68, fireRate: 1.68, damage: 1.68, accuracy: 1.68, buffs: ['+68% All Stats'], debuffs: [] },
            { id: 'bal47', name: 'Immovable II', category: 'balanced', price: 125000, health: 298, speed: 1.7, fireRate: 1.7, damage: 1.7, accuracy: 1.7, buffs: ['+70% All Stats'], debuffs: [] },
            { id: 'bal48', name: 'Invincible II', category: 'balanced', price: 140000, health: 305, speed: 1.72, fireRate: 1.72, damage: 1.72, accuracy: 1.72, buffs: ['+72% All Stats'], debuffs: [] },
            { id: 'bal49', name: 'Unconquerable II', category: 'balanced', price: 160000, health: 312, speed: 1.75, fireRate: 1.75, damage: 1.75, accuracy: 1.75, buffs: ['+75% All Stats'], debuffs: [] },
            { id: 'bal50', name: 'Impregnable II', category: 'balanced', price: 180000, health: 320, speed: 1.78, fireRate: 1.78, damage: 1.78, accuracy: 1.78, buffs: ['+78% All Stats'], debuffs: [] },
            { id: 'bal51', name: 'Insurmountable II', category: 'balanced', price: 220000, health: 328, speed: 1.8, fireRate: 1.8, damage: 1.8, accuracy: 1.8, buffs: ['+80% All Stats'], debuffs: [] },
            { id: 'bal52', name: 'Unstoppable II', category: 'balanced', price: 250000, health: 335, speed: 1.82, fireRate: 1.82, damage: 1.82, accuracy: 1.82, buffs: ['+82% All Stats'], debuffs: [] },
            { id: 'bal53', name: 'Relentless II', category: 'balanced', price: 280000, health: 342, speed: 1.85, fireRate: 1.85, damage: 1.85, accuracy: 1.85, buffs: ['+85% All Stats'], debuffs: [] },
            { id: 'bal54', name: 'Persistent II', category: 'balanced', price: 320000, health: 350, speed: 1.88, fireRate: 1.88, damage: 1.88, accuracy: 1.88, buffs: ['+88% All Stats'], debuffs: [] },
            { id: 'bal55', name: 'Tenacious II', category: 'balanced', price: 360000, health: 358, speed: 1.9, fireRate: 1.9, damage: 1.9, accuracy: 1.9, buffs: ['+90% All Stats'], debuffs: [] },
            { id: 'bal56', name: 'Determined II', category: 'balanced', price: 420000, health: 365, speed: 1.92, fireRate: 1.92, damage: 1.92, accuracy: 1.92, buffs: ['+92% All Stats'], debuffs: [] },
            { id: 'bal57', name: 'Equilibrium II', category: 'balanced', price: 480000, health: 372, speed: 1.95, fireRate: 1.95, damage: 1.95, accuracy: 1.95, buffs: ['+95% All Stats'], debuffs: [] },
            { id: 'bal58', name: 'Poise II', category: 'balanced', price: 550000, health: 380, speed: 1.98, fireRate: 1.98, damage: 1.98, accuracy: 1.98, buffs: ['+98% All Stats'], debuffs: [] },
            { id: 'bal59', name: 'Harmony', category: 'balanced', price: 620000, health: 388, speed: 2.0, fireRate: 2.0, damage: 2.0, accuracy: 2.0, buffs: ['+100% All Stats'], debuffs: [] },
            { id: 'bal60', name: 'Serenity', category: 'balanced', price: 700000, health: 395, speed: 2.02, fireRate: 2.02, damage: 2.02, accuracy: 2.02, buffs: ['+102% All Stats'], debuffs: [] },
            { id: 'bal61', name: 'Tranquility', category: 'balanced', price: 800000, health: 402, speed: 2.05, fireRate: 2.05, damage: 2.05, accuracy: 2.05, buffs: ['+105% All Stats'], debuffs: [] },
            { id: 'bal62', name: 'Peace', category: 'balanced', price: 900000, health: 410, speed: 2.08, fireRate: 2.08, damage: 2.08, accuracy: 2.08, buffs: ['+108% All Stats'], debuffs: [] },
            { id: 'bal63', name: 'Unity', category: 'balanced', price: 1100000, health: 418, speed: 2.1, fireRate: 2.1, damage: 2.1, accuracy: 2.1, buffs: ['+110% All Stats'], debuffs: [] },
            { id: 'bal64', name: 'Accord', category: 'balanced', price: 1300000, health: 425, speed: 2.12, fireRate: 2.12, damage: 2.12, accuracy: 2.12, buffs: ['+112% All Stats'], debuffs: [] },
            { id: 'bal65', name: 'Concord', category: 'balanced', price: 1500000, health: 432, speed: 2.15, fireRate: 2.15, damage: 2.15, accuracy: 2.15, buffs: ['+115% All Stats'], debuffs: [] },
            { id: 'bal66', name: 'Amity', category: 'balanced', price: 1800000, health: 440, speed: 2.18, fireRate: 2.18, damage: 2.18, accuracy: 2.18, buffs: ['+118% All Stats'], debuffs: [] },
            { id: 'bal67', name: 'Solidarity', category: 'balanced', price: 2200000, health: 448, speed: 2.2, fireRate: 2.2, damage: 2.2, accuracy: 2.2, buffs: ['+120% All Stats'], debuffs: [] },
            { id: 'bal68', name: 'Fellowship', category: 'balanced', price: 2500000, health: 455, speed: 2.22, fireRate: 2.22, damage: 2.22, accuracy: 2.22, buffs: ['+122% All Stats'], debuffs: [] },
            { id: 'bal69', name: 'Kinship', category: 'balanced', price: 3000000, health: 462, speed: 2.25, fireRate: 2.25, damage: 2.25, accuracy: 2.25, buffs: ['+125% All Stats'], debuffs: [] },
            { id: 'bal70', name: 'Brotherhood', category: 'balanced', price: 3500000, health: 470, speed: 2.28, fireRate: 2.28, damage: 2.28, accuracy: 2.28, buffs: ['+128% All Stats'], debuffs: [] },
            { id: 'bal71', name: 'Alliance', category: 'balanced', price: 4000000, health: 478, speed: 2.3, fireRate: 2.3, damage: 2.3, accuracy: 2.3, buffs: ['+130% All Stats'], debuffs: [] },
            { id: 'bal72', name: 'Coalition', category: 'balanced', price: 4500000, health: 485, speed: 2.32, fireRate: 2.32, damage: 2.32, accuracy: 2.32, buffs: ['+132% All Stats'], debuffs: [] },
            { id: 'bal73', name: 'Federation', category: 'balanced', price: 5000000, health: 492, speed: 2.35, fireRate: 2.35, damage: 2.35, accuracy: 2.35, buffs: ['+135% All Stats'], debuffs: [] },
            { id: 'bal74', name: 'Confederation', category: 'balanced', price: 6000000, health: 500, speed: 2.38, fireRate: 2.38, damage: 2.38, accuracy: 2.38, buffs: ['+138% All Stats'], debuffs: [] },
            { id: 'bal75', name: 'Empire', category: 'balanced', price: 7000000, health: 508, speed: 2.4, fireRate: 2.4, damage: 2.4, accuracy: 2.4, buffs: ['+140% All Stats'], debuffs: [] },
            { id: 'bal76', name: 'Dynasty', category: 'balanced', price: 8000000, health: 515, speed: 2.42, fireRate: 2.42, damage: 2.42, accuracy: 2.42, buffs: ['+142% All Stats'], debuffs: [] },
            { id: 'bal77', name: 'Dominion', category: 'balanced', price: 9000000, health: 522, speed: 2.45, fireRate: 2.45, damage: 2.45, accuracy: 2.45, buffs: ['+145% All Stats'], debuffs: [] },
            { id: 'bal78', name: 'Sovereignty', category: 'balanced', price: 10000000, health: 530, speed: 2.48, fireRate: 2.48, damage: 2.48, accuracy: 2.48, buffs: ['+148% All Stats'], debuffs: [] },
            { id: 'bal79', name: 'Reign', category: 'balanced', price: 12000000, health: 538, speed: 2.5, fireRate: 2.5, damage: 2.5, accuracy: 2.5, buffs: ['+150% All Stats'], debuffs: [] },
            { id: 'bal80', name: 'Ultimate Balance', category: 'balanced', price: 15000000, health: 550, speed: 2.55, fireRate: 2.55, damage: 2.55, accuracy: 2.55, buffs: ['+155% All Stats'], debuffs: [] },
            
            // EXTENDED SPECIAL SHIPS (60 more) - with extreme trade-offs
            { id: 'spc20', name: 'Paradox', category: 'special', price: 4000, health: 150, speed: 0.5, fireRate: 2.5, damage: 0.5, accuracy: 1.5, buffs: ['+50% Health', '+150% Fire Rate', '+50% Accuracy'], debuffs: ['-50% Speed', '-50% Damage'] },
            { id: 'spc21', name: 'Contradiction', category: 'special', price: 5500, health: 50, speed: 2.0, fireRate: 0.5, damage: 2.5, accuracy: 0.8, buffs: ['+100% Speed', '+150% Damage'], debuffs: ['-50% Health', '-50% Fire Rate', '-20% Accuracy'] },
            { id: 'spc22', name: 'Enigma', category: 'special', price: 7000, health: 200, speed: 0.4, fireRate: 0.4, damage: 3.0, accuracy: 1.0, buffs: ['+100% Health', '+200% Damage'], debuffs: ['-60% Speed', '-60% Fire Rate'] },
            { id: 'spc23', name: 'Mystery', category: 'special', price: 9000, health: 30, speed: 2.5, fireRate: 3.0, damage: 0.6, accuracy: 0.6, buffs: ['+150% Speed', '+200% Fire Rate'], debuffs: ['-70% Health', '-40% Damage', '-40% Accuracy'] },
            { id: 'spc24', name: 'Riddle', category: 'special', price: 11000, health: 120, speed: 1.0, fireRate: 1.0, damage: 1.0, accuracy: 2.5, buffs: ['+20% Health', '+150% Accuracy'], debuffs: ['No other buffs'] },
            { id: 'spc25', name: 'Puzzle', category: 'special', price: 14000, health: 80, speed: 1.5, fireRate: 1.5, damage: 1.5, accuracy: 0.5, buffs: ['+50% Speed/Fire/Damage'], debuffs: ['-20% Health', '-50% Accuracy'] },
            { id: 'spc26', name: 'Conundrum', category: 'special', price: 17000, health: 250, speed: 0.3, fireRate: 1.8, damage: 0.8, accuracy: 1.2, buffs: ['+150% Health', '+80% Fire Rate', '+20% Accuracy'], debuffs: ['-70% Speed', '-20% Damage'] },
            { id: 'spc27', name: 'Dilemma', category: 'special', price: 21000, health: 40, speed: 1.8, fireRate: 0.6, damage: 3.5, accuracy: 1.3, buffs: ['+80% Speed', '+250% Damage', '+30% Accuracy'], debuffs: ['-60% Health', '-40% Fire Rate'] },
            { id: 'spc28', name: 'Quandary', category: 'special', price: 26000, health: 100, speed: 0.8, fireRate: 2.8, damage: 0.7, accuracy: 1.4, buffs: ['+180% Fire Rate', '+40% Accuracy'], debuffs: ['-20% Speed', '-30% Damage'] },
            { id: 'spc29', name: 'Predicament', category: 'special', price: 32000, health: 180, speed: 0.6, fireRate: 0.8, damage: 2.2, accuracy: 1.8, buffs: ['+80% Health', '+120% Damage', '+80% Accuracy'], debuffs: ['-40% Speed', '-20% Fire Rate'] },
            { id: 'spc30', name: 'Impasse', category: 'special', price: 38000, health: 60, speed: 2.2, fireRate: 2.0, damage: 1.2, accuracy: 0.7, buffs: ['+120% Speed', '+100% Fire Rate', '+20% Damage'], debuffs: ['-40% Health', '-30% Accuracy'] },
            { id: 'spc31', name: 'Stalemate', category: 'special', price: 45000, health: 300, speed: 0.25, fireRate: 0.6, damage: 2.8, accuracy: 1.1, buffs: ['+200% Health', '+180% Damage'], debuffs: ['-75% Speed', '-40% Fire Rate'] },
            { id: 'spc32', name: 'Deadlock', category: 'special', price: 52000, health: 25, speed: 2.8, fireRate: 2.5, damage: 1.5, accuracy: 0.6, buffs: ['+180% Speed', '+150% Fire Rate', '+50% Damage'], debuffs: ['-75% Health', '-40% Accuracy'] },
            { id: 'spc33', name: 'Standoff', category: 'special', price: 65000, health: 140, speed: 1.2, fireRate: 0.5, damage: 4.0, accuracy: 1.6, buffs: ['+40% Health', '+300% Damage', '+60% Accuracy'], debuffs: ['-50% Fire Rate'] },
            { id: 'spc34', name: 'Gridlock', category: 'special', price: 75000, health: 90, speed: 1.0, fireRate: 3.2, damage: 0.6, accuracy: 1.0, buffs: ['+220% Fire Rate'], debuffs: ['-10% Health', '-40% Damage'] },
            { id: 'spc35', name: 'Bottleneck', category: 'special', price: 88000, health: 220, speed: 0.5, fireRate: 1.5, damage: 1.8, accuracy: 1.3, buffs: ['+120% Health', '+50% Fire Rate', '+80% Damage', '+30% Accuracy'], debuffs: ['-50% Speed'] },
            { id: 'spc36', name: 'Crossroads', category: 'special', price: 100000, health: 70, speed: 1.8, fireRate: 1.8, damage: 1.8, accuracy: 0.5, buffs: ['+80% Speed/Fire/Damage'], debuffs: ['-30% Health', '-50% Accuracy'] },
            { id: 'spc37', name: 'Junction', category: 'special', price: 115000, health: 160, speed: 0.7, fireRate: 2.2, damage: 1.4, accuracy: 1.5, buffs: ['+60% Health', '+120% Fire Rate', '+40% Damage', '+50% Accuracy'], debuffs: ['-30% Speed'] },
            { id: 'spc38', name: 'Intersection', category: 'special', price: 130000, health: 55, speed: 2.5, fireRate: 1.2, damage: 2.4, accuracy: 0.8, buffs: ['+150% Speed', '+140% Damage'], debuffs: ['-45% Health', '-20% Accuracy'] },
            { id: 'spc39', name: 'Vertex', category: 'special', price: 150000, health: 280, speed: 0.35, fireRate: 0.7, damage: 2.6, accuracy: 1.4, buffs: ['+180% Health', '+160% Damage', '+40% Accuracy'], debuffs: ['-65% Speed', '-30% Fire Rate'] },
            { id: 'spc40', name: 'Apex', category: 'special', price: 175000, health: 45, speed: 2.4, fireRate: 2.8, damage: 1.3, accuracy: 0.75, buffs: ['+140% Speed', '+180% Fire Rate', '+30% Damage'], debuffs: ['-55% Health', '-25% Accuracy'] },
            { id: 'spc41', name: 'Zenith', category: 'special', price: 200000, health: 130, speed: 1.1, fireRate: 1.4, damage: 2.0, accuracy: 1.7, buffs: ['+30% Health', '+100% Damage', '+70% Accuracy'], debuffs: ['-10% Speed'] },
            { id: 'spc42', name: 'Pinnacle', category: 'special', price: 230000, health: 350, speed: 0.3, fireRate: 1.0, damage: 2.2, accuracy: 1.2, buffs: ['+250% Health', '+120% Damage', '+20% Accuracy'], debuffs: ['-70% Speed'] },
            { id: 'spc43', name: 'Summit', category: 'special', price: 260000, health: 35, speed: 2.7, fireRate: 2.2, damage: 2.0, accuracy: 0.7, buffs: ['+170% Speed', '+120% Fire Rate', '+100% Damage'], debuffs: ['-65% Health', '-30% Accuracy'] },
            { id: 'spc44', name: 'Peak', category: 'special', price: 300000, health: 170, speed: 0.8, fireRate: 2.5, damage: 1.5, accuracy: 1.4, buffs: ['+70% Health', '+150% Fire Rate', '+50% Damage', '+40% Accuracy'], debuffs: ['-20% Speed'] },
            { id: 'spc45', name: 'Crest', category: 'special', price: 340000, health: 65, speed: 2.0, fireRate: 0.8, damage: 3.2, accuracy: 1.5, buffs: ['+100% Speed', '+220% Damage', '+50% Accuracy'], debuffs: ['-35% Health', '-20% Fire Rate'] },
            { id: 'spc46', name: 'Crown', category: 'special', price: 380000, health: 240, speed: 0.45, fireRate: 1.8, damage: 1.8, accuracy: 1.3, buffs: ['+140% Health', '+80% Fire Rate', '+80% Damage', '+30% Accuracy'], debuffs: ['-55% Speed'] },
            { id: 'spc47', name: 'Throne', category: 'special', price: 430000, health: 50, speed: 2.3, fireRate: 3.0, damage: 1.1, accuracy: 0.8, buffs: ['+130% Speed', '+200% Fire Rate'], debuffs: ['-50% Health', '-20% Accuracy'] },
            { id: 'spc48', name: 'Scepter', category: 'special', price: 480000, health: 190, speed: 0.65, fireRate: 1.2, damage: 2.5, accuracy: 1.6, buffs: ['+90% Health', '+150% Damage', '+60% Accuracy'], debuffs: ['-35% Speed', '-20% Fire Rate'] },
            { id: 'spc49', name: 'Orb', category: 'special', price: 530000, health: 80, speed: 1.6, fireRate: 2.2, damage: 1.6, accuracy: 1.1, buffs: ['+60% Speed', '+120% Fire Rate', '+60% Damage'], debuffs: ['-20% Health'] },
            { id: 'spc50', name: 'Regalia', category: 'special', price: 600000, health: 320, speed: 0.35, fireRate: 1.5, damage: 2.0, accuracy: 1.4, buffs: ['+220% Health', '+50% Fire Rate', '+100% Damage', '+40% Accuracy'], debuffs: ['-65% Speed'] },
            { id: 'spc51', name: 'Imperial', category: 'special', price: 680000, health: 42, speed: 2.6, fireRate: 2.4, damage: 1.8, accuracy: 0.75, buffs: ['+160% Speed', '+140% Fire Rate', '+80% Damage'], debuffs: ['-58% Health', '-25% Accuracy'] },
            { id: 'spc52', name: 'Royal', category: 'special', price: 750000, health: 200, speed: 0.75, fireRate: 1.6, damage: 2.2, accuracy: 1.5, buffs: ['+100% Health', '+60% Fire Rate', '+120% Damage', '+50% Accuracy'], debuffs: ['-25% Speed'] },
            { id: 'spc53', name: 'Noble', category: 'special', price: 850000, health: 110, speed: 1.4, fireRate: 1.0, damage: 2.8, accuracy: 1.7, buffs: ['+40% Speed', '+180% Damage', '+70% Accuracy'], debuffs: ['-10% Health'] },
            { id: 'spc54', name: 'Aristocrat', category: 'special', price: 950000, health: 380, speed: 0.28, fireRate: 0.8, damage: 2.8, accuracy: 1.3, buffs: ['+280% Health', '+180% Damage', '+30% Accuracy'], debuffs: ['-72% Speed', '-20% Fire Rate'] },
            { id: 'spc55', name: 'Patrician', category: 'special', price: 1100000, health: 55, speed: 2.4, fireRate: 2.8, damage: 1.5, accuracy: 0.85, buffs: ['+140% Speed', '+180% Fire Rate', '+50% Damage'], debuffs: ['-45% Health', '-15% Accuracy'] },
            { id: 'spc56', name: 'Senator', category: 'special', price: 1250000, health: 160, speed: 1.0, fireRate: 2.0, damage: 2.0, accuracy: 1.4, buffs: ['+60% Health', '+100% Fire Rate', '+100% Damage', '+40% Accuracy'], debuffs: [] },
            { id: 'spc57', name: 'Consul', category: 'special', price: 1400000, health: 75, speed: 1.8, fireRate: 1.4, damage: 2.6, accuracy: 1.2, buffs: ['+80% Speed', '+40% Fire Rate', '+160% Damage', '+20% Accuracy'], debuffs: ['-25% Health'] },
            { id: 'spc58', name: 'Praetor', category: 'special', price: 1600000, health: 280, speed: 0.5, fireRate: 1.8, damage: 2.2, accuracy: 1.5, buffs: ['+180% Health', '+80% Fire Rate', '+120% Damage', '+50% Accuracy'], debuffs: ['-50% Speed'] },
            { id: 'spc59', name: 'Tribune', category: 'special', price: 1800000, health: 48, speed: 2.5, fireRate: 2.6, damage: 2.0, accuracy: 0.8, buffs: ['+150% Speed', '+160% Fire Rate', '+100% Damage'], debuffs: ['-52% Health', '-20% Accuracy'] },
            { id: 'spc60', name: 'Dictator', category: 'special', price: 2000000, health: 220, speed: 0.7, fireRate: 1.5, damage: 2.6, accuracy: 1.6, buffs: ['+120% Health', '+50% Fire Rate', '+160% Damage', '+60% Accuracy'], debuffs: ['-30% Speed'] },
            { id: 'spc61', name: 'Emperor', category: 'special', price: 2300000, health: 90, speed: 1.7, fireRate: 2.2, damage: 2.2, accuracy: 1.1, buffs: ['+70% Speed', '+120% Fire Rate', '+120% Damage'], debuffs: ['-10% Health'] },
            { id: 'spc62', name: 'Caesar', category: 'special', price: 2600000, health: 400, speed: 0.35, fireRate: 1.2, damage: 2.5, accuracy: 1.4, buffs: ['+300% Health', '+20% Fire Rate', '+150% Damage', '+40% Accuracy'], debuffs: ['-65% Speed'] },
            { id: 'spc63', name: 'Augustus', category: 'special', price: 3000000, health: 60, speed: 2.3, fireRate: 2.8, damage: 2.2, accuracy: 0.9, buffs: ['+130% Speed', '+180% Fire Rate', '+120% Damage'], debuffs: ['-40% Health', '-10% Accuracy'] },
            { id: 'spc64', name: 'Imperator', category: 'special', price: 3500000, health: 180, speed: 1.2, fireRate: 1.8, damage: 2.5, accuracy: 1.5, buffs: ['+80% Health', '+80% Fire Rate', '+150% Damage', '+50% Accuracy'], debuffs: ['-20% Speed'] },
            { id: 'spc65', name: 'Tyrant', category: 'special', price: 4000000, health: 100, speed: 1.5, fireRate: 1.5, damage: 3.0, accuracy: 1.3, buffs: ['+50% Speed', '+50% Fire Rate', '+200% Damage', '+30% Accuracy'], debuffs: [] },
            { id: 'spc66', name: 'Despot', category: 'special', price: 4500000, health: 450, speed: 0.3, fireRate: 1.0, damage: 2.8, accuracy: 1.3, buffs: ['+350% Health', '+180% Damage', '+30% Accuracy'], debuffs: ['-70% Speed'] },
            { id: 'spc67', name: 'Overlord', category: 'special', price: 5000000, health: 70, speed: 2.2, fireRate: 2.5, damage: 2.5, accuracy: 0.95, buffs: ['+120% Speed', '+150% Fire Rate', '+150% Damage'], debuffs: ['-30% Health', '-5% Accuracy'] },
            { id: 'spc68', name: 'Warlord', category: 'special', price: 5500000, health: 250, speed: 0.8, fireRate: 2.0, damage: 2.5, accuracy: 1.5, buffs: ['+150% Health', '+100% Fire Rate', '+150% Damage', '+50% Accuracy'], debuffs: ['-20% Speed'] },
            { id: 'spc69', name: 'Conqueror', category: 'special', price: 6000000, health: 120, speed: 1.6, fireRate: 1.8, damage: 2.8, accuracy: 1.4, buffs: ['+60% Speed', '+80% Fire Rate', '+180% Damage', '+40% Accuracy'], debuffs: ['-20% Health'] },
            { id: 'spc70', name: 'Vanquisher', category: 'special', price: 7000000, health: 500, speed: 0.25, fireRate: 0.9, damage: 3.0, accuracy: 1.4, buffs: ['+400% Health', '+200% Damage', '+40% Accuracy'], debuffs: ['-75% Speed', '-10% Fire Rate'] },
            { id: 'spc71', name: 'Subjugator', category: 'special', price: 8000000, health: 80, speed: 2.1, fireRate: 2.8, damage: 2.6, accuracy: 1.0, buffs: ['+110% Speed', '+180% Fire Rate', '+160% Damage'], debuffs: ['-20% Health'] },
            { id: 'spc72', name: 'Dominator', category: 'special', price: 9000000, health: 300, speed: 0.7, fireRate: 1.8, damage: 2.8, accuracy: 1.6, buffs: ['+200% Health', '+80% Fire Rate', '+180% Damage', '+60% Accuracy'], debuffs: ['-30% Speed'] },
            { id: 'spc73', name: 'Annihilator', category: 'special', price: 10000000, health: 140, speed: 1.5, fireRate: 2.0, damage: 3.0, accuracy: 1.4, buffs: ['+50% Speed', '+100% Fire Rate', '+200% Damage', '+40% Accuracy'], debuffs: ['-40% Health'] },
            { id: 'spc74', name: 'Eradicator', category: 'special', price: 12000000, health: 550, speed: 0.22, fireRate: 0.8, damage: 3.2, accuracy: 1.5, buffs: ['+450% Health', '+220% Damage', '+50% Accuracy'], debuffs: ['-78% Speed', '-20% Fire Rate'] },
            { id: 'spc75', name: 'Exterminator', category: 'special', price: 14000000, health: 90, speed: 2.0, fireRate: 2.6, damage: 2.8, accuracy: 1.1, buffs: ['+100% Speed', '+160% Fire Rate', '+180% Damage'], debuffs: ['-10% Health'] },
            { id: 'spc76', name: 'Obliterator', category: 'special', price: 16000000, health: 350, speed: 0.6, fireRate: 2.0, damage: 3.0, accuracy: 1.6, buffs: ['+250% Health', '+100% Fire Rate', '+200% Damage', '+60% Accuracy'], debuffs: ['-40% Speed'] },
            { id: 'spc77', name: 'Decimator', category: 'special', price: 18000000, health: 160, speed: 1.4, fireRate: 2.2, damage: 3.2, accuracy: 1.4, buffs: ['+40% Speed', '+120% Fire Rate', '+220% Damage', '+40% Accuracy'], debuffs: ['-60% Health'] },
            { id: 'spc78', name: 'Terminator', category: 'special', price: 20000000, health: 600, speed: 0.2, fireRate: 1.5, damage: 3.5, accuracy: 1.6, buffs: ['+500% Health', '+50% Fire Rate', '+250% Damage', '+60% Accuracy'], debuffs: ['-80% Speed'] },
            { id: 'spc79', name: 'Omega Elite', category: 'special', price: 25000000, health: 400, speed: 1.8, fireRate: 2.0, damage: 3.0, accuracy: 1.8, buffs: ['+300% Health', '+80% Speed', '+100% Fire Rate', '+200% Damage', '+80% Accuracy'], debuffs: [] }
        ];
        
        function initShop() {
            updateShipDisplay();
            renderShop('all');
        }
        
        function toggleShop() {
            const panel = document.getElementById('shop-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        function resetAllProgress() {
            if (confirm('Are you sure you want to restart? This will delete ALL your progress including money, ships, and quests!')) {
                localStorage.removeItem('warships_money');
                localStorage.removeItem('warships_totalEarned');
                localStorage.removeItem('warships_stats');
                localStorage.removeItem('warships_ownedShips');
                localStorage.removeItem('warships_selectedShip');
                localStorage.removeItem('warships_completedQuests');
                localStorage.removeItem('warships_teamMembers');
                location.reload();
            }
        }
        
        function toggleQuests() {
            const panel = document.getElementById('quest-panel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }
        
        // ============ TEAM PANEL FUNCTIONS ============
        let selectedTeamMemberId = null;
        
        const personalityDescriptions = {
            'aggressive': 'Engages enemies head-on, prioritizes offense',
            'cautious': 'Maintains distance, provides covering fire',
            'balanced': 'Adapts to situation, flanks when possible'
        };
        
        const roleIcons = {
            'Flanker': '‚öîÔ∏è',
            'Support': 'üõ°Ô∏è',
            'Scout': 'üî≠'
        };
        
        function toggleTeam() {
            const panel = document.getElementById('team-panel');
            if (panel.style.display === 'none' || panel.style.display === '') {
                panel.style.display = 'block';
                renderTeamMembers();
            } else {
                panel.style.display = 'none';
            }
        }
        
        function renderTeamMembers() {
            const grid = document.getElementById('team-members-grid');
            document.getElementById('team-ship-selection').style.display = 'none';
            
            grid.innerHTML = teamMembers.map(member => {
                const shipStats = getTeamMemberShipStats(member.id);
                const hasCustomShip = member.assignedShipId !== null;
                
                return `
                    <div class="team-member-card" onclick="selectTeamMember('${member.id}')">
                        <div class="member-role">${roleIcons[member.role] || 'üë§'} ${member.role}</div>
                        <div class="member-name">${member.name}</div>
                        <div class="member-personality">${personalityDescriptions[member.personality] || ''}</div>
                        <div class="assigned-ship">
                            <div class="ship-info">
                                <span class="ship-emoji">${getShipEmoji(shipStats)}</span>
                                <span>${shipStats.name}</span>
                            </div>
                            <div style="color: ${hasCustomShip ? '#00ff88' : '#88aacc'}; font-size: 0.8em; margin-top: 5px;">
                                ${hasCustomShip ? 'ASSIGNED' : 'DEFAULT'}
                            </div>
                        </div>
                        <button class="assign-btn">${hasCustomShip ? 'Change Ship' : 'Assign Ship'}</button>
                    </div>
                `;
            }).join('');
        }
        
        function selectTeamMember(memberId) {
            selectedTeamMemberId = memberId;
            const member = teamMembers.find(m => m.id === memberId);
            
            document.getElementById('team-selection-title').textContent = `Select Ship for ${member.name}`;
            document.getElementById('team-ship-selection').style.display = 'block';
            
            renderTeamShipSelection();
        }
        
        function renderTeamShipSelection() {
            const grid = document.getElementById('team-ship-grid');
            const member = teamMembers.find(m => m.id === selectedTeamMemberId);
            
            // Get ships available for assignment (owned, not player's, not assigned to OTHER members)
            const otherAssignedIds = teamMembers
                .filter(m => m.id !== selectedTeamMemberId && m.assignedShipId)
                .map(m => m.assignedShipId);
            
            const availableShips = ownedShips
                .filter(shipId => shipId !== selectedShipId && !otherAssignedIds.includes(shipId))
                .map(shipId => {
                    const ship = shipTemplates.find(s => s.id === shipId);
                    return {
                        ...ship,
                        isCurrentlyAssigned: member.assignedShipId === shipId
                    };
                });
            
            if (availableShips.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: 1/-1; text-align: center; padding: 30px; color: #88aacc;">
                        <p>No additional ships available to assign.</p>
                        <p style="font-size: 0.9em; opacity: 0.7;">Buy more ships from the Shop, or unassign from another crew member.</p>
                    </div>
                `;
                return;
            }
            
            grid.innerHTML = availableShips.map(ship => `
                <div class="team-ship-card ${ship.isCurrentlyAssigned ? 'assigned' : ''}" onclick="assignShipToTeamMember('${ship.id}')">
                    <div class="ship-emoji-lg">${getShipEmoji(ship)}</div>
                    <div style="font-weight: bold; color: #fff;">${ship.name}</div>
                    <div style="font-size: 0.8em; color: #88aacc;">
                        ‚ù§Ô∏è${ship.health} ‚ö°${(ship.speed * 100).toFixed(0)}% üí•${(ship.damage * 100).toFixed(0)}%
                    </div>
                    <div style="margin-top: 8px; padding: 5px; border-radius: 4px; font-size: 0.85em; font-weight: bold;
                        ${ship.isCurrentlyAssigned 
                            ? 'background: linear-gradient(180deg, #44aa44, #228822); color: #fff;' 
                            : 'background: linear-gradient(180deg, #0088ff, #0066cc); color: #fff;'}">
                        ${ship.isCurrentlyAssigned ? '‚úì ASSIGNED' : 'TAP TO ASSIGN'}
                    </div>
                </div>
            `).join('');
        }
        
        function assignShipToTeamMember(shipId) {
            const member = teamMembers.find(m => m.id === selectedTeamMemberId);
            if (!member) return;
            
            // If clicking the already-assigned ship, unassign it
            if (member.assignedShipId === shipId) {
                member.assignedShipId = null;
            } else {
                // Remove this ship from any other member
                teamMembers.forEach(m => {
                    if (m.assignedShipId === shipId) {
                        m.assignedShipId = null;
                    }
                });
                // Assign to selected member
                member.assignedShipId = shipId;
            }
            
            // Save to localStorage
            localStorage.setItem('warships_teamMembers', JSON.stringify(teamMembers));
            
            // Refresh UI
            renderTeamShipSelection();
        }
        
        function closeTeamShipSelection() {
            document.getElementById('team-ship-selection').style.display = 'none';
            selectedTeamMemberId = null;
            renderTeamMembers();
        }
        
        function showShopCategory(category) {
            document.querySelectorAll('.shop-tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            renderShop(category);
        }
        
        function renderShop(category) {
            const grid = document.getElementById('ship-grid');
            const filtered = category === 'all' ? shipTemplates : shipTemplates.filter(s => s.category === category);
            
            grid.innerHTML = filtered.map(ship => {
                const owned = ownedShips.includes(ship.id);
                const selected = selectedShipId === ship.id;
                const canAfford = money >= ship.price;
                
                return `
                    <div class="ship-card ${owned ? 'owned' : ''} ${selected ? 'selected' : ''}">
                        <div class="ship-name">${ship.name}</div>
                        <div class="ship-price">${ship.price === 0 ? 'FREE' : '$' + ship.price.toLocaleString()}</div>
                        <div class="ship-stats">
                            <div>‚ù§Ô∏è ${ship.health}% | ‚ö° ${Math.round(ship.speed * 100)}%</div>
                            <div>üî• ${Math.round(ship.fireRate * 100)}% | üí• ${Math.round(ship.damage * 100)}%</div>
                            <div>üéØ ${Math.round(ship.accuracy * 100)}%</div>
                            ${ship.buffs.map(b => `<div class="buff">‚úì ${b}</div>`).join('')}
                            ${ship.debuffs.map(d => `<div class="debuff">‚úó ${d}</div>`).join('')}
                        </div>
                        ${owned 
                            ? (selected 
                                ? '<button disabled>EQUIPPED</button>' 
                                : `<button onclick="selectShip('${ship.id}')">EQUIP</button>`)
                            : `<button onclick="buyShip('${ship.id}')" ${!canAfford ? 'disabled' : ''}>${canAfford ? 'BUY' : 'Need $' + (ship.price - money).toLocaleString()}</button>`
                        }
                    </div>
                `;
            }).join('');
        }
        
        function buyShip(shipId) {
            const ship = shipTemplates.find(s => s.id === shipId);
            if (!ship || money < ship.price) return;
            
            money -= ship.price;
            ownedShips.push(shipId);
            localStorage.setItem('warships_money', money.toString());
            localStorage.setItem('warships_ownedShips', JSON.stringify(ownedShips));
            document.getElementById('money').textContent = money.toLocaleString();
            
            // Show purchase popup
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,50,100,0.95);border:3px solid #00d4ff;border-radius:15px;padding:20px 40px;color:#fff;text-align:center;z-index:3000;animation:fadeOut 2s forwards;';
            popup.innerHTML = `<div style="color:#00d4ff;font-size:1.5em;">üö¢ SHIP PURCHASED!</div><div style="margin:10px 0;font-size:1.2em;">${ship.name}</div>`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 2000);
            
            renderShop(document.querySelector('.shop-tab.active')?.textContent.toLowerCase() || 'all');
        }
        
        function selectShip(shipId) {
            if (!ownedShips.includes(shipId)) return;
            selectedShipId = shipId;
            localStorage.setItem('warships_selectedShip', shipId);
            updateShipDisplay();
            renderShop(document.querySelector('.shop-tab.active')?.textContent.toLowerCase() || 'all');
        }
        
        function updateShipDisplay() {
            const ship = shipTemplates.find(s => s.id === selectedShipId) || shipTemplates[0];
            document.getElementById('current-ship-name').textContent = ship.name;
        }
        
        function getSelectedShipStats() {
            return shipTemplates.find(s => s.id === selectedShipId) || shipTemplates[0];
        }
        
        // Particle limits to prevent memory issues
        const MAX_SMOKE_PARTICLES = 100;
        const MAX_TRAIL_PARTICLES = 50;
        const MAX_EXPLOSION_PARTICLES = 200;
        
        // Helper to properly dispose THREE.js objects
        function disposeMesh(mesh) {
            if (!mesh) return;
            if (mesh.geometry) mesh.geometry.dispose();
            if (mesh.material) {
                if (Array.isArray(mesh.material)) {
                    mesh.material.forEach(m => m.dispose());
                } else {
                    mesh.material.dispose();
                }
            }
            scene.remove(mesh);
        }

        document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function init() {
            // Scene with fog for atmosphere
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x9ab8d0, 0.00018);

            // Camera
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 80, 120);

            // Renderer with maximum photorealistic quality settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance",
                alpha: false,
                precision: "highp",
                logarithmicDepthBuffer: true,
                stencil: true,
                depth: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.95;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.physicallyCorrectLights = true;
            renderer.gammaFactor = 2.2;
            renderer.sortObjects = true;
            renderer.autoClear = true;
            document.body.appendChild(renderer.domElement);

            // Sky
            createSky();

            // Ultra-realistic lighting setup with global illumination simulation
            // Ambient - subtle sky blue fill
            const ambientLight = new THREE.AmbientLight(0x5577aa, 0.12);
            scene.add(ambientLight);

            // Main sun light - golden hour cinematic lighting
            sun = new THREE.DirectionalLight(0xfff5e8, 2.8);
            sun.position.set(200, 100, -300);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 10;
            sun.shadow.camera.far = 1000;
            sun.shadow.camera.left = -400;
            sun.shadow.camera.right = 400;
            sun.shadow.camera.top = 400;
            sun.shadow.camera.bottom = -400;
            sun.shadow.bias = -0.00005;
            sun.shadow.normalBias = 0.015;
            sun.shadow.radius = 2;
            scene.add(sun);

            // Hemisphere light - enhanced sky/ocean color bounce
            const hemiLight = new THREE.HemisphereLight(0x8ec8e8, 0x2a4a5a, 0.5);
            scene.add(hemiLight);
            
            // Rim light from behind (cinematic backlight)
            const rimLight = new THREE.DirectionalLight(0xffd4a6, 1.0);
            rimLight.position.set(-100, 50, 200);
            scene.add(rimLight);
            
            // Fill light from opposite side for balanced lighting
            const fillLight = new THREE.DirectionalLight(0x88aacc, 0.4);
            fillLight.position.set(-150, 80, -100);
            scene.add(fillLight);

            // Ocean
            createOcean();
            
            // Islands scattered across the battlefield
            createIslands();
            
            // Add god rays / volumetric light
            // createGodRays(); // Disabled for performance
            
            // Add sea spray particle system
            createSeaSpray();
            
            // Add cinematic lens flare
            createLensFlare();

            // Ships spawned when game starts

            window.addEventListener('resize', onWindowResize);
        }
        
        // Volumetric god rays from sun
        let godRaysMesh = null;
        function createGodRays() {
            const rayGeometry = new THREE.ConeGeometry(300, 800, 32, 1, true);
            const rayMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying float vHeight;
                    void main() {
                        vUv = uv;
                        vHeight = position.y;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying float vHeight;
                    
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    void main() {
                        float ray = sin(vUv.x * 40.0 + time * 0.5) * 0.5 + 0.5;
                        ray *= sin(vUv.x * 23.0 - time * 0.3) * 0.5 + 0.5;
                        ray = pow(ray, 3.0);
                        
                        float fade = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.5, vUv.y);
                        float alpha = ray * fade * 0.08;
                        
                        vec3 color = vec3(1.0, 0.95, 0.8);
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            godRaysMesh = new THREE.Mesh(rayGeometry, rayMaterial);
            godRaysMesh.position.set(200, 400, -300);
            godRaysMesh.rotation.x = Math.PI;
            godRaysMesh.rotation.z = 0.3;
            scene.add(godRaysMesh);
        }
        
        // Sea spray and mist particles
        let seaSprayParticles = [];
        function createSeaSpray() {
            const sprayGroup = new THREE.Group();
            const sprayGeometry = new THREE.SphereGeometry(0.5, 4, 4);
            const sprayMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            
            for (let i = 0; i < 40; i++) {
                const spray = new THREE.Mesh(sprayGeometry, sprayMaterial.clone());
                spray.position.set(
                    (Math.random() - 0.5) * WORLD_SIZE * 2,
                    Math.random() * 3,
                    (Math.random() - 0.5) * WORLD_SIZE * 2
                );
                spray.userData = {
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2,
                    vz: (Math.random() - 0.5) * 2,
                    life: Math.random()
                };
                sprayGroup.add(spray);
                seaSprayParticles.push(spray);
            }
            scene.add(sprayGroup);
        }
        
        function updateSeaSpray(delta) {
            seaSprayParticles.forEach(spray => {
                spray.userData.life -= delta * 0.5;
                if (spray.userData.life <= 0) {
                    // Respawn near camera or ships
                    const target = playerShip ? playerShip : { x: 0, z: 0 };
                    spray.position.set(
                        target.x + (Math.random() - 0.5) * 200,
                        Math.random() * 0.5,
                        target.z + (Math.random() - 0.5) * 200
                    );
                    spray.userData.life = 1.0;
                    spray.userData.vy = 1 + Math.random() * 3;
                }
                
                spray.position.x += spray.userData.vx * delta;
                spray.position.y += spray.userData.vy * delta;
                spray.position.z += spray.userData.vz * delta;
                spray.userData.vy -= delta * 5; // gravity
                
                spray.material.opacity = spray.userData.life * 0.4;
                spray.scale.setScalar(1 + (1 - spray.userData.life) * 2);
            });
        }
        
        // Create lens flare effect
        let lensFlareGroup = null;
        function createLensFlare() {
            lensFlareGroup = new THREE.Group();
            
            const flareColors = [
                { size: 80, color: 0xffffee, opacity: 0.8, dist: 0 },
                { size: 40, color: 0xffdd88, opacity: 0.4, dist: 0.1 },
                { size: 120, color: 0xff8844, opacity: 0.15, dist: 0.3 },
                { size: 60, color: 0x88aaff, opacity: 0.2, dist: 0.5 },
                { size: 30, color: 0xaaddff, opacity: 0.3, dist: 0.7 },
                { size: 90, color: 0xff6622, opacity: 0.1, dist: 0.9 },
                { size: 25, color: 0xffffff, opacity: 0.4, dist: 1.1 }
            ];
            
            flareColors.forEach(flare => {
                const geometry = new THREE.CircleGeometry(flare.size, 32);
                const material = new THREE.MeshBasicMaterial({
                    color: flare.color,
                    transparent: true,
                    opacity: flare.opacity,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.userData.flareDist = flare.dist;
                mesh.userData.baseOpacity = flare.opacity;
                lensFlareGroup.add(mesh);
            });
            
            scene.add(lensFlareGroup);
        }
        
        function updateLensFlare() {
            if (!lensFlareGroup || !camera) return;
            
            const sunPos = new THREE.Vector3(200, 100, -300);
            const screenCenter = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const toSun = sunPos.clone().sub(camera.position).normalize();
            
            // Check if sun is in view
            const dot = screenCenter.dot(toSun);
            const sunVisible = dot > 0.3;
            
            lensFlareGroup.children.forEach((flare, i) => {
                if (!sunVisible) {
                    flare.material.opacity = 0;
                    return;
                }
                
                const dist = flare.userData.flareDist;
                const pos = sunPos.clone().lerp(camera.position, dist * 0.5);
                flare.position.copy(pos);
                flare.lookAt(camera.position);
                flare.material.opacity = flare.userData.baseOpacity * (dot - 0.3) * 1.5;
            });
        }

        function createSky() {
            // Photorealistic sky with Rayleigh/Mie scattering simulation
            const skyGeometry = new THREE.SphereGeometry(1500, 64, 64);
            const skyMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    sunPosition: { value: new THREE.Vector3(200, 100, -300) },
                    rayleigh: { value: 2.5 },
                    turbidity: { value: 10.0 },
                    mieCoefficient: { value: 0.008 },
                    mieDirectionalG: { value: 0.85 },
                    luminance: { value: 1.2 },
                    time: { value: 0 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    varying vec3 vSunDirection;
                    varying vec3 vPosition;
                    uniform vec3 sunPosition;
                    
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vPosition = position;
                        vSunDirection = normalize(sunPosition);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float rayleigh;
                    uniform float turbidity;
                    uniform float mieCoefficient;
                    uniform float mieDirectionalG;
                    uniform float luminance;
                    uniform vec3 sunPosition;
                    uniform float time;
                    
                    varying vec3 vWorldPosition;
                    varying vec3 vSunDirection;
                    varying vec3 vPosition;
                    
                    // Noise functions for volumetric clouds
                    float hash(vec3 p) {
                        p = fract(p * vec3(443.897, 441.423, 437.195));
                        p += dot(p, p.yzx + 19.19);
                        return fract((p.x + p.y) * p.z);
                    }
                    
                    float noise3D(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        return mix(
                            mix(mix(hash(i), hash(i + vec3(1,0,0)), f.x),
                                mix(hash(i + vec3(0,1,0)), hash(i + vec3(1,1,0)), f.x), f.y),
                            mix(mix(hash(i + vec3(0,0,1)), hash(i + vec3(1,0,1)), f.x),
                                mix(hash(i + vec3(0,1,1)), hash(i + vec3(1,1,1)), f.x), f.y), f.z);
                    }
                    
                    float fbm(vec3 p) {
                        float f = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        for(int i = 0; i < 3; i++) {
                            f += amplitude * noise3D(p * frequency);
                            frequency *= 2.0;
                            amplitude *= 0.5;
                        }
                        return f;
                    }
                    
                    float cloudDensity(vec3 p, float t) {
                        vec3 wind = vec3(t * 2.0, 0.0, t * 0.5);
                        float density = fbm(p * 0.002 + wind * 0.001);
                        density = smoothstep(0.4, 0.7, density);
                        return density;
                    }
                    
                    // Rayleigh and Mie phase functions
                    float rayleighPhase(float cosTheta) {
                        return (3.0 / (16.0 * 3.14159)) * (1.0 + cosTheta * cosTheta);
                    }
                    
                    float hgPhase(float cosTheta, float g) {
                        float g2 = g * g;
                        float inverse = 1.0 / pow(1.0 - 2.0 * g * cosTheta + g2, 1.5);
                        return (1.0 / (4.0 * 3.14159)) * ((1.0 - g2) * inverse);
                    }
                    
                    void main() {
                        vec3 direction = normalize(vWorldPosition);
                        float zenithAngle = acos(max(0.0, direction.y));
                        float inverse = 1.0 / (cos(zenithAngle) + 0.15 * pow(93.885 - degrees(zenithAngle), -1.253));
                        
                        // Enhanced Rayleigh scattering coefficients for deeper blue
                        vec3 betaR = vec3(5.8e-6, 13.5e-6, 33.1e-6) * rayleigh;
                        
                        // Mie scattering for haze
                        float Km = turbidity * mieCoefficient;
                        vec3 betaM = vec3(Km, Km, Km);
                        
                        // Optical depth with improved atmosphere model
                        float sR = inverse * 8400.0;
                        float sM = inverse * 1200.0;
                        
                        // Extinction factor
                        vec3 Fex = exp(-(betaR * sR + betaM * sM));
                        
                        // Sun angle calculations
                        float cosTheta = dot(direction, vSunDirection);
                        
                        // Improved scattering
                        float rPhase = rayleighPhase(cosTheta);
                        vec3 betaRTheta = betaR * rPhase;
                        
                        float mPhase = hgPhase(cosTheta, mieDirectionalG);
                        vec3 betaMTheta = betaM * mPhase;
                        
                        // Enhanced sun intensity with color temperature
                        vec3 sunE = vec3(1.0, 0.98, 0.92) * 1200.0;
                        
                        // In-scattering with improved blending
                        vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex), vec3(1.5));
                        
                        // Horizon glow
                        float sunHeight = vSunDirection.y;
                        vec3 horizonGlow = vec3(1.0, 0.7, 0.4) * pow(max(0.0, 1.0 - abs(direction.y)), 8.0) * (1.0 - sunHeight * 0.5);
                        Lin += horizonGlow * 0.15;
                        
                        // Blend based on sun position
                        Lin *= mix(vec3(1.0), pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex, vec3(0.5)), 
                                   clamp(pow(1.0 - dot(vSunDirection, vec3(0.0, 1.0, 0.0)), 5.0), 0.0, 1.0));
                        
                        // Improved sun disc with corona
                        float sunAngularDiameter = 0.00933;
                        float sunDist = length(direction - vSunDirection);
                        float sundisk = smoothstep(sunAngularDiameter, sunAngularDiameter * 0.85, sunDist);
                        float corona = smoothstep(sunAngularDiameter * 6.0, sunAngularDiameter, sunDist) * 0.3;
                        
                        vec3 L0 = vec3(0.1) * Fex;
                        L0 += sunE * 25000.0 * Fex * sundisk;
                        L0 += sunE * 2000.0 * Fex * corona;
                        
                        // Volumetric clouds
                        float cloudHeight = 0.15;
                        float cloudThickness = 0.35;
                        if(direction.y > cloudHeight && direction.y < cloudHeight + cloudThickness) {
                            float cloudY = (direction.y - cloudHeight) / cloudThickness;
                            vec3 cloudPos = vPosition * 0.8;
                            float cloud = cloudDensity(cloudPos, time);
                            
                            // Cloud shaping - thicker in middle
                            cloud *= smoothstep(0.0, 0.3, cloudY) * smoothstep(1.0, 0.7, cloudY);
                            
                            // Cloud lighting
                            float cloudSunLight = max(0.0, dot(vec3(0.0, 1.0, 0.0), vSunDirection));
                            vec3 cloudColor = mix(vec3(0.7, 0.75, 0.85), vec3(1.0, 0.98, 0.95), cloudSunLight);
                            
                            // Cloud shadows/highlights
                            cloudColor *= 0.8 + 0.4 * cloudSunLight;
                            
                            // Silver lining effect
                            float silverLining = pow(max(0.0, cosTheta), 8.0) * cloud;
                            cloudColor += vec3(1.0, 0.95, 0.9) * silverLining * 0.5;
                            
                            Lin = mix(Lin, cloudColor, cloud * 0.85);
                        }
                        
                        // Final color with HDR tone mapping
                        vec3 texColor = (Lin + L0) * 0.04;
                        
                        // ACES filmic tone mapping
                        texColor = (texColor * (2.51 * texColor + 0.03)) / (texColor * (2.43 * texColor + 0.59) + 0.14);
                        
                        // Gamma correction
                        texColor = pow(texColor, vec3(1.0 / 2.2));
                        
                        // Enhanced zenith blue
                        float horizonBlend = pow(1.0 - max(direction.y, 0.0), 4.0);
                        vec3 horizonColor = vec3(0.78, 0.85, 0.95);
                        texColor = mix(texColor, horizonColor, horizonBlend * 0.25);
                        
                        // Add subtle gradient near horizon for depth
                        float atmosphericDepth = pow(1.0 - direction.y, 16.0);
                        texColor = mix(texColor, vec3(0.85, 0.88, 0.92), atmosphericDepth * 0.4);
                        
                        gl_FragColor = vec4(clamp(texColor * luminance, 0.0, 1.0), 1.0);
                    }
                `,
                side: THREE.BackSide,
                depthWrite: false
            });
            sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Photorealistic sun with proper glow
            const sunGroup = new THREE.Group();
            
            // Core sun disc
            const sunGeometry = new THREE.SphereGeometry(20, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffee
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunGroup.add(sunMesh);
            
            // Inner corona
            const corona1Geo = new THREE.SphereGeometry(35, 32, 32);
            const corona1Mat = new THREE.MeshBasicMaterial({ 
                color: 0xfffaf0, transparent: true, opacity: 0.4
            });
            sunGroup.add(new THREE.Mesh(corona1Geo, corona1Mat));
            
            // Outer corona
            const corona2Geo = new THREE.SphereGeometry(55, 32, 32);
            const corona2Mat = new THREE.MeshBasicMaterial({ 
                color: 0xffeedd, transparent: true, opacity: 0.15
            });
            sunGroup.add(new THREE.Mesh(corona2Geo, corona2Mat));
            
            // Atmospheric glow
            const glowGeo = new THREE.SphereGeometry(90, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({ 
                color: 0xffcc88, transparent: true, opacity: 0.08
            });
            sunGroup.add(new THREE.Mesh(glowGeo, glowMat));
            
            sunGroup.position.set(200, 100, -300);
            scene.add(sunGroup);

            // Photorealistic cumulus clouds
            createRealisticClouds();
        }
        
        function createRealisticClouds() {
            // Create layered cumulus cloud formations
            const cloudPositions = [
                { x: -400, y: 120, z: -500, scale: 1.2 },
                { x: 200, y: 140, z: -600, scale: 1.5 },
                { x: -200, y: 100, z: -400, scale: 0.9 },
                { x: 500, y: 130, z: -450, scale: 1.1 },
                { x: -600, y: 110, z: -550, scale: 1.3 },
                { x: 100, y: 150, z: -700, scale: 1.8 },
                { x: -350, y: 125, z: -650, scale: 1.0 },
                { x: 400, y: 115, z: -350, scale: 0.8 },
                { x: -100, y: 135, z: -500, scale: 1.4 },
                { x: 300, y: 145, z: -600, scale: 1.6 }
            ];
            
            for (let pos of cloudPositions) {
                createCumulusCloud(pos.x, pos.y, pos.z, pos.scale);
            }
        }
        
        function createCumulusCloud(x, y, z, scale) {
            const cloudGroup = new THREE.Group();
            
            // Multi-layered cloud for depth
            const layers = [
                { opacity: 0.9, color: 0xffffff, yOffset: 0, count: 12 },
                { opacity: 0.6, color: 0xf8f8ff, yOffset: 8, count: 8 },
                { opacity: 0.3, color: 0xf0f0f5, yOffset: 15, count: 5 }
            ];
            
            for (let layer of layers) {
                const material = new THREE.MeshPhongMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    flatShading: false,
                    depthWrite: false
                });
                
                for (let i = 0; i < layer.count; i++) {
                    const size = (15 + Math.random() * 25) * scale;
                    const geo = new THREE.SphereGeometry(size, 16, 16);
                    const puff = new THREE.Mesh(geo, material);
                    
                    puff.position.set(
                        (Math.random() - 0.5) * 80 * scale,
                        layer.yOffset + (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 80 * scale
                    );
                    puff.scale.y = 0.5 + Math.random() * 0.2;
                    puff.scale.x = 0.8 + Math.random() * 0.4;
                    cloudGroup.add(puff);
                }
            }
            
            // Subtle shadow on bottom
            const shadowMat = new THREE.MeshBasicMaterial({
                color: 0x8899aa,
                transparent: true,
                opacity: 0.2,
                depthWrite: false
            });
            
            for (let i = 0; i < 6; i++) {
                const size = (20 + Math.random() * 20) * scale;
                const geo = new THREE.SphereGeometry(size, 12, 12);
                const shadow = new THREE.Mesh(geo, shadowMat);
                shadow.position.set(
                    (Math.random() - 0.5) * 60 * scale,
                    -10,
                    (Math.random() - 0.5) * 60 * scale
                );
                shadow.scale.y = 0.3;
                cloudGroup.add(shadow);
            }
            
            cloudGroup.position.set(x, y, z);
            cloudGroup.userData = { driftSpeed: 0.3 + Math.random() * 0.3, originalX: x };
            scene.add(cloudGroup);
        }

        function createOcean() {
            // Ocean with super small waves
            const waterGeometry = new THREE.PlaneGeometry(4000, 4000, 64, 64);
            const waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    deepColor: { value: new THREE.Color(0x001828) },
                    midColor: { value: new THREE.Color(0x064273) },
                    shallowColor: { value: new THREE.Color(0x0a8a9f) },
                    sunDirection: { value: new THREE.Vector3(0.5, 0.8, -0.3).normalize() },
                    sunColor: { value: new THREE.Color(0xfffaf0) },
                    skyColorTop: { value: new THREE.Color(0x0077be) },
                    skyColorHorizon: { value: new THREE.Color(0x87ceeb) },
                    foamColor: { value: new THREE.Color(0xffffff) },
                    scatterColor: { value: new THREE.Color(0x00c8ff) }
                },
                vertexShader: `
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vHeight;
                    varying float vFoam;
                    
                    // Simplex noise functions for realistic waves
                    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                    
                    float snoise(vec3 v) {
                        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                        vec3 i = floor(v + dot(v, C.yyy));
                        vec3 x0 = v - i + dot(i, C.xxx);
                        vec3 g = step(x0.yzx, x0.xyz);
                        vec3 l = 1.0 - g;
                        vec3 i1 = min(g.xyz, l.zxy);
                        vec3 i2 = max(g.xyz, l.zxy);
                        vec3 x1 = x0 - i1 + C.xxx;
                        vec3 x2 = x0 - i2 + C.yyy;
                        vec3 x3 = x0 - D.yyy;
                        i = mod289(i);
                        vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                        float n_ = 0.142857142857;
                        vec3 ns = n_ * D.wyz - D.xzx;
                        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                        vec4 x_ = floor(j * ns.z);
                        vec4 y_ = floor(j - 7.0 * x_);
                        vec4 x = x_ *ns.x + ns.yyyy;
                        vec4 y = y_ *ns.x + ns.yyyy;
                        vec4 h = 1.0 - abs(x) - abs(y);
                        vec4 b0 = vec4(x.xy, y.xy);
                        vec4 b1 = vec4(x.zw, y.zw);
                        vec4 s0 = floor(b0)*2.0 + 1.0;
                        vec4 s1 = floor(b1)*2.0 + 1.0;
                        vec4 sh = -step(h, vec4(0.0));
                        vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                        vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                        vec3 p0 = vec3(a0.xy, h.x);
                        vec3 p1 = vec3(a0.zw, h.y);
                        vec3 p2 = vec3(a1.xy, h.z);
                        vec3 p3 = vec3(a1.zw, h.w);
                        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                        p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                        m = m * m;
                        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                    }
                    
                    float oceanWave(vec2 pos, float t) {
                        float height = 0.0;
                        // Primary swell waves
                        height += snoise(vec3(pos * 0.008, t * 0.15)) * 2.5;
                        height += snoise(vec3(pos * 0.015 + 50.0, t * 0.2)) * 1.5;
                        // Secondary chop
                        height += snoise(vec3(pos * 0.04 + 100.0, t * 0.35)) * 0.6;
                        height += snoise(vec3(pos * 0.08 + 150.0, t * 0.5)) * 0.25;
                        // Fine detail ripples
                        height += snoise(vec3(pos * 0.2 + 200.0, t * 0.8)) * 0.08;
                        height += snoise(vec3(pos * 0.5 + 250.0, t * 1.2)) * 0.03;
                        return height;
                    }
                    
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        float t = time;
                        
                        // Calculate wave height using ocean simulation
                        float waveHeight = oceanWave(pos.xy, t);
                        vHeight = waveHeight;
                        
                        // Calculate foam based on wave peaks and steepness
                        float foam = smoothstep(1.8, 3.0, waveHeight);
                        float steepness = abs(oceanWave(pos.xy + vec2(1.0, 0.0), t) - oceanWave(pos.xy - vec2(1.0, 0.0), t));
                        foam += smoothstep(0.3, 0.8, steepness) * 0.5;
                        vFoam = clamp(foam, 0.0, 1.0);
                        
                        // Calculate normals from wave gradients
                        float epsilon = 0.5;
                        float hL = oceanWave(pos.xy - vec2(epsilon, 0.0), t);
                        float hR = oceanWave(pos.xy + vec2(epsilon, 0.0), t);
                        float hD = oceanWave(pos.xy - vec2(0.0, epsilon), t);
                        float hU = oceanWave(pos.xy + vec2(0.0, epsilon), t);
                        vec3 normal = normalize(vec3(hL - hR, 2.0 * epsilon, hD - hU));
                        vNormal = normal;
                        
                        vec4 worldPosition = modelMatrix * vec4(pos.x, pos.y, waveHeight, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 deepColor;
                    uniform vec3 midColor;
                    uniform vec3 shallowColor;
                    uniform vec3 sunDirection;
                    uniform vec3 sunColor;
                    uniform vec3 skyColorTop;
                    uniform vec3 skyColorHorizon;
                    uniform vec3 foamColor;
                    uniform vec3 scatterColor;
                    uniform float time;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying float vHeight;
                    varying float vFoam;
                    
                    // Noise for caustics and foam detail
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    float noise(vec2 p) {
                        vec2 i = floor(p);
                        vec2 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        float a = hash(i);
                        float b = hash(i + vec2(1.0, 0.0));
                        float c = hash(i + vec2(0.0, 1.0));
                        float d = hash(i + vec2(1.0, 1.0));
                        return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
                    }
                    
                    float caustics(vec2 uv, float t) {
                        float c = 0.0;
                        uv *= 8.0;
                        c += abs(sin(uv.x + sin(uv.y + t) * 2.0) * sin(uv.y + sin(uv.x + t * 1.3) * 2.0));
                        c = pow(c, 3.0);
                        return c * 0.15;
                    }
                    
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                        vec3 normal = normalize(vNormal);
                        
                        // Distance-based depth fade
                        float distFromCamera = length(cameraPosition - vWorldPosition);
                        float depthFactor = clamp(distFromCamera / 500.0, 0.0, 1.0);
                        
                        // Blend water colors based on height and depth
                        float heightFactor = clamp((vHeight + 2.0) / 5.0, 0.0, 1.0);
                        vec3 waterColor = mix(deepColor, midColor, heightFactor * 0.6);
                        waterColor = mix(waterColor, shallowColor, heightFactor * 0.3);
                        
                        // Subsurface scattering simulation
                        float scatter = pow(max(0.0, dot(viewDir, -sunDirection)), 4.0);
                        scatter *= pow(1.0 - abs(dot(normal, viewDir)), 2.0);
                        waterColor += scatterColor * scatter * 0.4;
                        
                        // Fresnel effect with Schlick approximation
                        float F0 = 0.02;
                        float cosTheta = max(dot(normal, viewDir), 0.0);
                        float fresnel = F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
                        
                        // Realistic sky reflection with distortion
                        vec3 reflectDir = reflect(-viewDir, normal);
                        float skyBlend = smoothstep(-0.2, 0.5, reflectDir.y);
                        vec3 reflectedSky = mix(skyColorHorizon, skyColorTop, skyBlend);
                        
                        // Sun specular with multiple lobes for realism
                        vec3 halfDir = normalize(sunDirection + viewDir);
                        float spec1 = pow(max(dot(normal, halfDir), 0.0), 512.0) * 2.0;
                        float spec2 = pow(max(dot(normal, halfDir), 0.0), 64.0) * 0.5;
                        float spec3 = pow(max(dot(normal, halfDir), 0.0), 16.0) * 0.15;
                        vec3 specular = sunColor * (spec1 + spec2 + spec3);
                        
                        // Caustics pattern
                        float causticsPattern = caustics(vWorldPosition.xz * 0.02, time * 0.5);
                        waterColor += vec3(0.2, 0.5, 0.7) * causticsPattern;
                        
                        // Foam with animated noise detail
                        float foamNoise = noise(vWorldPosition.xz * 0.5 + time * 0.3);
                        foamNoise += noise(vWorldPosition.xz * 1.5 + time * 0.5) * 0.5;
                        float foamAmount = vFoam * foamNoise;
                        foamAmount = smoothstep(0.3, 0.8, foamAmount);
                        
                        // Combine everything
                        vec3 finalColor = mix(waterColor, reflectedSky, fresnel * 0.7);
                        finalColor += specular;
                        finalColor = mix(finalColor, foamColor, foamAmount * 0.8);
                        
                        // Atmospheric fog at distance
                        vec3 fogColor = mix(skyColorHorizon, vec3(0.8, 0.85, 0.9), 0.5);
                        finalColor = mix(finalColor, fogColor, depthFactor * 0.6);
                        
                        // Tone mapping
                        finalColor = finalColor / (finalColor + vec3(1.0));
                        finalColor = pow(finalColor, vec3(1.0 / 2.2));
                        
                        gl_FragColor = vec4(finalColor, 0.97);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = 0;
            scene.add(water);
        }

        let islandAnimations = [];
        
        function createIslands() {
            // Island configurations - scattered around the battlefield (spread far apart)
            const islandConfigs = [
                { x: -550, z: -450, size: 45, height: 12 },
                { x: 500, z: 400, size: 55, height: 15 },
                { x: -350, z: 550, size: 35, height: 10 },
                { x: 580, z: -480, size: 50, height: 14 },
                { x: 0, z: -580, size: 40, height: 11 },
                { x: -600, z: 200, size: 60, height: 18 },
                { x: 420, z: -150, size: 30, height: 8 },
                { x: -200, z: -300, size: 25, height: 7 },
                { x: 600, z: 80, size: 45, height: 13 },
                { x: -480, z: 480, size: 38, height: 10 },
                { x: 200, z: 600, size: 42, height: 12 },
                { x: -580, z: -580, size: 55, height: 16 }
            ];
            
            islandConfigs.forEach((config, index) => {
                const islandData = createIsland(config.size, config.height, index);
                islandData.group.position.set(config.x, 0, config.z);
                scene.add(islandData.group);
                islands.push({
                    mesh: islandData.group,
                    x: config.x,
                    z: config.z,
                    radius: config.size * 1.2
                });
                
                // Store animated elements
                if (islandData.animations) {
                    islandAnimations.push({
                        ...islandData.animations,
                        baseX: config.x,
                        baseZ: config.z
                    });
                }
                
                // Shore waves disabled for performance
                // const shoreWaves = createShoreWaves(config.size, config.x, config.z);
                // scene.add(shoreWaves);
                
                // Add seagulls circling island (reduced count)
                const seagulls = createSeagulls(config.size, config.x, config.z, index);
                scene.add(seagulls.group);
                islandAnimations.push({ seagulls: seagulls });
                
                // Coral reef disabled for performance
                // const coral = createCoralReef(config.size, config.x, config.z, index);
                // scene.add(coral);
                
                // Butterflies disabled for performance
                // if (config.size > 40) {
                //     const butterflies = createButterflies(config.size, config.x, config.z, index);
                //     scene.add(butterflies.group);
                //     islandAnimations.push({ butterflies: butterflies });
                // }
            });
        }
        
        function createShoreWaves(size, islandX, islandZ) {
            const group = new THREE.Group();
            
            // Multiple wave rings at different distances
            for (let w = 0; w < 3; w++) {
                const waveRadius = size * 1.1 + w * 3;
                const waveGeo = new THREE.RingGeometry(waveRadius, waveRadius + 1.5, 48, 1);
                const waveMat = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        waveIndex: { value: w },
                        baseRadius: { value: waveRadius }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float waveIndex;
                        uniform float baseRadius;
                        varying float vAlpha;
                        varying vec2 vUv;
                        
                        void main() {
                            vUv = uv;
                            vec3 pos = position;
                            
                            // Animate wave expansion
                            float phase = time * 0.5 + waveIndex * 2.094;
                            float expansion = sin(phase) * 0.5 + 0.5;
                            float scale = 1.0 + expansion * 0.15;
                            pos.x *= scale;
                            pos.z *= scale;
                            
                            // Fade based on expansion
                            vAlpha = (1.0 - expansion) * 0.6;
                            
                            // Add vertical wave motion
                            pos.y = sin(phase + atan(pos.z, pos.x) * 8.0) * 0.3;
                            
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        varying float vAlpha;
                        varying vec2 vUv;
                        
                        void main() {
                            vec3 foamColor = vec3(0.95, 0.98, 1.0);
                            float foam = smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y);
                            gl_FragColor = vec4(foamColor, vAlpha * foam);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const wave = new THREE.Mesh(waveGeo, waveMat);
                wave.rotation.x = -Math.PI / 2;
                wave.position.set(islandX, 0.5, islandZ);
                group.add(wave);
                
                islandAnimations.push({ waveMaterial: waveMat });
            }
            
            // Foam particles around shore
            const numFoamParticles = 12;
            for (let f = 0; f < numFoamParticles; f++) {
                const foamGeo = new THREE.CircleGeometry(0.5 + Math.random() * 0.5, 6);
                const foamMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4 + Math.random() * 0.3,
                    side: THREE.DoubleSide
                });
                const foam = new THREE.Mesh(foamGeo, foamMat);
                const angle = (f / numFoamParticles) * Math.PI * 2;
                const dist = size * 1.05 + Math.random() * 5;
                foam.position.set(
                    islandX + Math.cos(angle) * dist,
                    0.2,
                    islandZ + Math.sin(angle) * dist
                );
                foam.rotation.x = -Math.PI / 2;
                foam.userData = { angle, dist, baseX: islandX, baseZ: islandZ, phase: Math.random() * Math.PI * 2 };
                group.add(foam);
                islandAnimations.push({ foamParticle: foam });
            }
            
            return group;
        }
        
        function createSeagulls(size, islandX, islandZ, seed) {
            const group = new THREE.Group();
            const seagulls = [];
            
            const numSeagulls = 2 + Math.floor(Math.sin(seed * 100) + 1);
            
            for (let s = 0; s < numSeagulls; s++) {
                const seagull = new THREE.Group();
                
                // Body (using stretched sphere instead of CapsuleGeometry for compatibility)
                const bodyGeo = new THREE.SphereGeometry(0.35, 8, 6);
                const bodyMat = new THREE.MeshPhongMaterial({ color: 0xfafafa, shininess: 20 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.scale.set(2.0, 0.8, 0.8);
                seagull.add(body);
                
                // Head
                const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
                const head = new THREE.Mesh(headGeo, bodyMat);
                head.position.x = 0.6;
                seagull.add(head);
                
                // Beak
                const beakGeo = new THREE.ConeGeometry(0.08, 0.3, 4);
                const beakMat = new THREE.MeshPhongMaterial({ color: 0xffaa00 });
                const beak = new THREE.Mesh(beakGeo, beakMat);
                beak.position.set(0.85, 0, 0);
                beak.rotation.z = -Math.PI / 2;
                seagull.add(beak);
                
                // Wings
                const wingGeo = new THREE.PlaneGeometry(1.2, 0.4);
                const wingMat = new THREE.MeshPhongMaterial({ 
                    color: 0xeeeeee, 
                    side: THREE.DoubleSide 
                });
                
                const leftWing = new THREE.Mesh(wingGeo, wingMat);
                leftWing.position.set(0, 0.1, 0.6);
                leftWing.rotation.x = 0.3;
                seagull.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeo, wingMat);
                rightWing.position.set(0, 0.1, -0.6);
                rightWing.rotation.x = -0.3;
                seagull.add(rightWing);
                
                // Wing tips (darker)
                const tipGeo = new THREE.PlaneGeometry(0.4, 0.3);
                const tipMat = new THREE.MeshPhongMaterial({ color: 0x333333, side: THREE.DoubleSide });
                
                const leftTip = new THREE.Mesh(tipGeo, tipMat);
                leftTip.position.set(-0.2, 0.1, 1.0);
                seagull.add(leftTip);
                
                const rightTip = new THREE.Mesh(tipGeo, tipMat);
                rightTip.position.set(-0.2, 0.1, -1.0);
                seagull.add(rightTip);
                
                // Store wings for animation
                seagull.userData = {
                    leftWing,
                    rightWing,
                    orbitAngle: (s / numSeagulls) * Math.PI * 2,
                    orbitRadius: size * 1.5 + Math.random() * size,
                    orbitSpeed: 0.3 + Math.random() * 0.2,
                    orbitHeight: 20 + Math.random() * 15,
                    wingPhase: Math.random() * Math.PI * 2,
                    baseX: islandX,
                    baseZ: islandZ
                };
                
                seagull.scale.setScalar(1.5);
                group.add(seagull);
                seagulls.push(seagull);
            }
            
            return { group, seagulls };
        }
        
        function createCoralReef(size, islandX, islandZ, seed) {
            const group = new THREE.Group();
            
            const seededRandom = (s) => {
                const x = Math.sin(seed * 9999 + s * 1234) * 10000;
                return x - Math.floor(x);
            };
            
            // Coral formations
            const numCorals = 5 + Math.floor(seededRandom(1) * 5);
            const coralColors = [0xff6b6b, 0xff9f43, 0xfeca57, 0x48dbfb, 0xff6b81, 0xa55eea, 0x26de81];
            
            for (let c = 0; c < numCorals; c++) {
                const coralType = Math.floor(seededRandom(c * 10) * 4);
                let coral;
                
                if (coralType === 0) {
                    // Brain coral
                    const geo = new THREE.SphereGeometry(1.5 + seededRandom(c * 11) * 2, 12, 12);
                    const positions = geo.attributes.position;
                    for (let i = 0; i < positions.count; i++) {
                        const x = positions.getX(i);
                        const y = positions.getY(i);
                        const z = positions.getZ(i);
                        const n = Math.sin(x * 3 + y * 2) * Math.sin(z * 3 + y * 2) * 0.2;
                        positions.setX(i, x * (1 + n));
                        positions.setY(i, y * (0.6 + n * 0.5));
                        positions.setZ(i, z * (1 + n));
                    }
                    geo.computeVertexNormals();
                    const mat = new THREE.MeshPhongMaterial({
                        color: coralColors[Math.floor(seededRandom(c * 12) * coralColors.length)],
                        shininess: 30
                    });
                    coral = new THREE.Mesh(geo, mat);
                } else if (coralType === 1) {
                    // Branching coral
                    coral = new THREE.Group();
                    const branchColor = coralColors[Math.floor(seededRandom(c * 13) * coralColors.length)];
                    const numBranches = 5 + Math.floor(seededRandom(c * 14) * 6);
                    for (let b = 0; b < numBranches; b++) {
                        const branchGeo = new THREE.CylinderGeometry(0.1, 0.2, 2 + seededRandom(c * 15 + b) * 2, 6);
                        const branchMat = new THREE.MeshPhongMaterial({ color: branchColor, shininess: 20 });
                        const branch = new THREE.Mesh(branchGeo, branchMat);
                        branch.position.set(
                            (seededRandom(c * 16 + b) - 0.5) * 1.5,
                            seededRandom(c * 17 + b) * 1.5,
                            (seededRandom(c * 18 + b) - 0.5) * 1.5
                        );
                        branch.rotation.set(
                            (seededRandom(c * 19 + b) - 0.5) * 0.8,
                            seededRandom(c * 20 + b) * Math.PI,
                            (seededRandom(c * 21 + b) - 0.5) * 0.8
                        );
                        coral.add(branch);
                    }
                } else if (coralType === 2) {
                    // Fan coral
                    const fanGeo = new THREE.CircleGeometry(2 + seededRandom(c * 22) * 1.5, 16);
                    const fanMat = new THREE.MeshPhongMaterial({
                        color: coralColors[Math.floor(seededRandom(c * 23) * coralColors.length)],
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    coral = new THREE.Mesh(fanGeo, fanMat);
                    coral.rotation.x = -0.3 + seededRandom(c * 24) * 0.6;
                    coral.rotation.y = seededRandom(c * 25) * Math.PI * 2;
                } else {
                    // Tube coral
                    coral = new THREE.Group();
                    const tubeColor = coralColors[Math.floor(seededRandom(c * 26) * coralColors.length)];
                    const numTubes = 8 + Math.floor(seededRandom(c * 27) * 8);
                    for (let t = 0; t < numTubes; t++) {
                        const tubeGeo = new THREE.CylinderGeometry(0.15, 0.2, 1 + seededRandom(c * 28 + t) * 1.5, 8, 1, true);
                        const tubeMat = new THREE.MeshPhongMaterial({ color: tubeColor, shininess: 25 });
                        const tube = new THREE.Mesh(tubeGeo, tubeMat);
                        const angle = (t / numTubes) * Math.PI * 2;
                        const dist = 0.3 + seededRandom(c * 29 + t) * 0.5;
                        tube.position.set(Math.cos(angle) * dist, 0.5, Math.sin(angle) * dist);
                        coral.add(tube);
                    }
                }
                
                const angle = seededRandom(c * 30) * Math.PI * 2;
                const dist = size * 1.2 + seededRandom(c * 31) * size * 0.4;
                coral.position.set(
                    islandX + Math.cos(angle) * dist,
                    -2 - seededRandom(c * 32) * 3,
                    islandZ + Math.sin(angle) * dist
                );
                coral.rotation.y = seededRandom(c * 33) * Math.PI * 2;
                group.add(coral);
            }
            
            // Seaweed
            const numSeaweed = 6 + Math.floor(seededRandom(50) * 6);
            for (let sw = 0; sw < numSeaweed; sw++) {
                const seaweed = createSeaweed(seededRandom(sw + 100));
                const angle = seededRandom(sw + 101) * Math.PI * 2;
                const dist = size * 1.1 + seededRandom(sw + 102) * size * 0.5;
                seaweed.position.set(
                    islandX + Math.cos(angle) * dist,
                    -4,
                    islandZ + Math.sin(angle) * dist
                );
                group.add(seaweed);
                islandAnimations.push({ seaweed: seaweed });
            }
            
            return group;
        }
        
        function createSeaweed(seed) {
            const group = new THREE.Group();
            
            const numStrands = 3 + Math.floor(seed * 4);
            const seaweedColors = [0x2d5a2d, 0x3d6a3d, 0x2a4a2a, 0x1d3d1d];
            
            for (let s = 0; s < numStrands; s++) {
                const height = 3 + seed * 4 + Math.random() * 2;
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(Math.sin(seed * 10 + s) * 0.5, height * 0.3, Math.cos(seed * 10 + s) * 0.5),
                    new THREE.Vector3(Math.sin(seed * 20 + s) * 0.8, height * 0.6, Math.cos(seed * 20 + s) * 0.8),
                    new THREE.Vector3(Math.sin(seed * 30 + s) * 0.5, height, Math.cos(seed * 30 + s) * 0.5)
                ]);
                
                const strandGeo = new THREE.TubeGeometry(curve, 12, 0.1, 6, false);
                const strandMat = new THREE.MeshPhongMaterial({
                    color: seaweedColors[Math.floor(seed * seaweedColors.length + s) % seaweedColors.length],
                    shininess: 20,
                    transparent: true,
                    opacity: 0.85
                });
                const strand = new THREE.Mesh(strandGeo, strandMat);
                strand.position.x = (s - numStrands / 2) * 0.3;
                strand.userData.swayPhase = seed * 10 + s;
                group.add(strand);
            }
            
            return group;
        }
        
        function createButterflies(size, islandX, islandZ, seed) {
            const group = new THREE.Group();
            const butterflies = [];
            
            const numButterflies = 2 + Math.floor(Math.sin(seed * 50) * 2 + 1);
            const butterflyColors = [0xff6b9d, 0xffd93d, 0x6bcb77, 0x4d96ff, 0xff8b3d, 0xc56cf0];
            
            for (let b = 0; b < numButterflies; b++) {
                const butterfly = new THREE.Group();
                
                const wingColor = butterflyColors[b % butterflyColors.length];
                const wingMat = new THREE.MeshPhongMaterial({
                    color: wingColor,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                
                // Wings (2 on each side)
                const upperWingGeo = new THREE.CircleGeometry(0.4, 8, 0, Math.PI);
                const lowerWingGeo = new THREE.CircleGeometry(0.3, 6, 0, Math.PI * 0.8);
                
                const leftUpperWing = new THREE.Mesh(upperWingGeo, wingMat);
                leftUpperWing.position.z = 0.15;
                leftUpperWing.rotation.y = Math.PI / 2;
                butterfly.add(leftUpperWing);
                
                const rightUpperWing = new THREE.Mesh(upperWingGeo, wingMat);
                rightUpperWing.position.z = -0.15;
                rightUpperWing.rotation.y = -Math.PI / 2;
                butterfly.add(rightUpperWing);
                
                const leftLowerWing = new THREE.Mesh(lowerWingGeo, wingMat);
                leftLowerWing.position.set(-0.15, 0, 0.12);
                leftLowerWing.rotation.y = Math.PI / 2;
                butterfly.add(leftLowerWing);
                
                const rightLowerWing = new THREE.Mesh(lowerWingGeo, wingMat);
                rightLowerWing.position.set(-0.15, 0, -0.12);
                rightLowerWing.rotation.y = -Math.PI / 2;
                butterfly.add(rightLowerWing);
                
                // Body (using cylinder for compatibility)
                const bodyGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.4, 6);
                const bodyMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.rotation.z = Math.PI / 2;
                butterfly.add(body);
                
                // Antennae
                const antennaGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.2, 4);
                const antennaMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
                
                const leftAntenna = new THREE.Mesh(antennaGeo, antennaMat);
                leftAntenna.position.set(0.15, 0.1, 0.03);
                leftAntenna.rotation.z = -0.5;
                butterfly.add(leftAntenna);
                
                const rightAntenna = new THREE.Mesh(antennaGeo, antennaMat);
                rightAntenna.position.set(0.15, 0.1, -0.03);
                rightAntenna.rotation.z = -0.5;
                butterfly.add(rightAntenna);
                
                butterfly.userData = {
                    leftUpperWing,
                    rightUpperWing,
                    leftLowerWing,
                    rightLowerWing,
                    flightAngle: Math.random() * Math.PI * 2,
                    flightRadius: 5 + Math.random() * size * 0.3,
                    flightSpeed: 0.5 + Math.random() * 0.3,
                    flightHeight: 10 + Math.random() * 8,
                    wingPhase: Math.random() * Math.PI * 2,
                    baseX: islandX,
                    baseZ: islandZ,
                    verticalPhase: Math.random() * Math.PI * 2
                };
                
                butterfly.scale.setScalar(0.8);
                group.add(butterfly);
                butterflies.push(butterfly);
            }
            
            return { group, butterflies };
        }
        
        function updateIslandAnimations(delta, time) {
            islandAnimations.forEach(anim => {
                // Update wave materials
                if (anim.waveMaterial) {
                    anim.waveMaterial.uniforms.time.value = time;
                }
                
                // Update foam particles
                if (anim.foamParticle) {
                    const foam = anim.foamParticle;
                    const wave = Math.sin(time * 2 + foam.userData.phase) * 2;
                    foam.position.x = foam.userData.baseX + Math.cos(foam.userData.angle) * (foam.userData.dist + wave);
                    foam.position.z = foam.userData.baseZ + Math.sin(foam.userData.angle) * (foam.userData.dist + wave);
                    foam.material.opacity = 0.3 + Math.sin(time * 3 + foam.userData.phase) * 0.2;
                }
                
                // Update seagulls
                if (anim.seagulls) {
                    anim.seagulls.seagulls.forEach(seagull => {
                        const ud = seagull.userData;
                        ud.orbitAngle += ud.orbitSpeed * delta;
                        
                        seagull.position.x = ud.baseX + Math.cos(ud.orbitAngle) * ud.orbitRadius;
                        seagull.position.z = ud.baseZ + Math.sin(ud.orbitAngle) * ud.orbitRadius;
                        seagull.position.y = ud.orbitHeight + Math.sin(time * 0.5 + ud.wingPhase) * 3;
                        
                        // Face direction of travel
                        seagull.rotation.y = -ud.orbitAngle + Math.PI / 2;
                        
                        // Wing flapping
                        const wingFlap = Math.sin(time * 8 + ud.wingPhase) * 0.4;
                        ud.leftWing.rotation.x = 0.3 + wingFlap;
                        ud.rightWing.rotation.x = -0.3 - wingFlap;
                        
                        // Slight banking in turns
                        seagull.rotation.z = Math.sin(ud.orbitAngle) * 0.15;
                    });
                }
                
                // Update seaweed swaying
                if (anim.seaweed) {
                    anim.seaweed.children.forEach(strand => {
                        const phase = strand.userData.swayPhase || 0;
                        strand.rotation.x = Math.sin(time * 0.8 + phase) * 0.2;
                        strand.rotation.z = Math.sin(time * 0.6 + phase + 1) * 0.15;
                    });
                }
                
                // Update butterflies
                if (anim.butterflies) {
                    anim.butterflies.butterflies.forEach(butterfly => {
                        const ud = butterfly.userData;
                        ud.flightAngle += ud.flightSpeed * delta;
                        
                        // Erratic flight path
                        const wobbleX = Math.sin(time * 2 + ud.wingPhase) * 2;
                        const wobbleZ = Math.cos(time * 1.7 + ud.wingPhase) * 2;
                        
                        butterfly.position.x = ud.baseX + Math.cos(ud.flightAngle) * ud.flightRadius + wobbleX;
                        butterfly.position.z = ud.baseZ + Math.sin(ud.flightAngle) * ud.flightRadius + wobbleZ;
                        butterfly.position.y = ud.flightHeight + Math.sin(time * 1.5 + ud.verticalPhase) * 2;
                        
                        // Face direction with some randomness
                        butterfly.rotation.y = -ud.flightAngle + Math.PI / 2 + Math.sin(time * 3) * 0.3;
                        
                        // Wing fluttering (fast)
                        const wingFlutter = Math.sin(time * 25 + ud.wingPhase) * 0.6;
                        ud.leftUpperWing.rotation.z = wingFlutter;
                        ud.rightUpperWing.rotation.z = -wingFlutter;
                        ud.leftLowerWing.rotation.z = wingFlutter * 0.8;
                        ud.rightLowerWing.rotation.z = -wingFlutter * 0.8;
                    });
                }
            });
        }
        
        function createIsland(size, height, seed) {
            const group = new THREE.Group();
            
            // Seeded random for consistent islands
            const seededRandom = (s) => {
                const x = Math.sin(seed * 9999 + s * 1234) * 10000;
                return x - Math.floor(x);
            };
            
            // Noise function for terrain
            const noise2D = (x, z, scale, octaves) => {
                let value = 0;
                let amplitude = 1;
                let frequency = scale;
                let maxValue = 0;
                for (let o = 0; o < octaves; o++) {
                    value += Math.sin(x * frequency + seed * 100) * Math.cos(z * frequency + seed * 50) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                return value / maxValue;
            };
            
            // === UNDERWATER TERRAIN ===
            const underwaterGeo = new THREE.CylinderGeometry(size * 1.3, size * 1.5, 8, 24, 4);
            const uwPositions = underwaterGeo.attributes.position;
            for (let i = 0; i < uwPositions.count; i++) {
                const x = uwPositions.getX(i);
                const y = uwPositions.getY(i);
                const z = uwPositions.getZ(i);
                const n = noise2D(x * 0.1, z * 0.1, 0.5, 3) * 0.3 + seededRandom(i * 3) * 0.2;
                uwPositions.setX(i, x * (0.9 + n));
                uwPositions.setZ(i, z * (0.9 + n));
            }
            underwaterGeo.computeVertexNormals();
            const underwaterMat = new THREE.MeshPhongMaterial({
                color: 0x2a3a2a,
                shininess: 5,
                specular: 0x111111
            });
            const underwater = new THREE.Mesh(underwaterGeo, underwaterMat);
            underwater.position.y = -4;
            group.add(underwater);
            
            // === ROCKY CLIFF BASE ===
            const cliffGeo = new THREE.CylinderGeometry(size * 0.85, size * 1.1, height * 0.6, 16, 8);
            const cliffPositions = cliffGeo.attributes.position;
            for (let i = 0; i < cliffPositions.count; i++) {
                const x = cliffPositions.getX(i);
                const y = cliffPositions.getY(i);
                const z = cliffPositions.getZ(i);
                const distFromCenter = Math.sqrt(x * x + z * z);
                const heightFactor = (y + height * 0.3) / (height * 0.6);
                const n = noise2D(x * 0.15, z * 0.15, 0.8, 4) * 0.35;
                const erosion = seededRandom(i * 7) * 0.25;
                uwPositions.setX(i, x * (0.85 + n + erosion * heightFactor));
                uwPositions.setZ(i, z * (0.85 + n + erosion * heightFactor));
            }
            cliffGeo.computeVertexNormals();
            
            // Layered cliff material with color variation
            const cliffColors = [0x6b5a4a, 0x5a4a3a, 0x7a6a5a, 0x4a3a2a];
            const cliffMat = new THREE.MeshPhongMaterial({
                color: cliffColors[seed % cliffColors.length],
                shininess: 8,
                specular: 0x222211,
                flatShading: true
            });
            const cliff = new THREE.Mesh(cliffGeo, cliffMat);
            cliff.position.y = height * 0.3;
            cliff.castShadow = true;
            cliff.receiveShadow = true;
            group.add(cliff);
            
            // === SANDY BEACH ===
            const beachGeo = new THREE.RingGeometry(size * 0.75, size * 1.15, 32, 3);
            const beachPositions = beachGeo.attributes.position;
            for (let i = 0; i < beachPositions.count; i++) {
                const x = beachPositions.getX(i);
                const z = beachPositions.getZ(i);
                const wave = Math.sin(Math.atan2(z, x) * 8 + seed) * 0.15;
                const n = seededRandom(i * 11) * 0.1;
                beachPositions.setX(i, x * (1 + wave + n));
                beachPositions.setZ(i, z * (1 + wave + n));
                beachPositions.setY(i, seededRandom(i * 13) * 0.3);
            }
            beachGeo.computeVertexNormals();
            
            const beachMat = new THREE.MeshPhongMaterial({
                color: 0xd4c4a0,
                shininess: 3,
                specular: 0x333322
            });
            const beach = new THREE.Mesh(beachGeo, beachMat);
            beach.rotation.x = -Math.PI / 2;
            beach.position.y = 0.3;
            beach.receiveShadow = true;
            group.add(beach);
            
            // === WET SAND NEAR WATER ===
            const wetSandGeo = new THREE.RingGeometry(size * 1.0, size * 1.2, 32, 2);
            const wetSandMat = new THREE.MeshPhongMaterial({
                color: 0x9a8a6a,
                shininess: 25,
                specular: 0x444433
            });
            const wetSand = new THREE.Mesh(wetSandGeo, wetSandMat);
            wetSand.rotation.x = -Math.PI / 2;
            wetSand.position.y = 0.1;
            wetSand.receiveShadow = true;
            group.add(wetSand);
            
            // === GRASSY TERRAIN TOP ===
            const terrainGeo = new THREE.SphereGeometry(size * 0.7, 24, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const terrainPositions = terrainGeo.attributes.position;
            for (let i = 0; i < terrainPositions.count; i++) {
                const x = terrainPositions.getX(i);
                const y = terrainPositions.getY(i);
                const z = terrainPositions.getZ(i);
                const hillNoise = noise2D(x * 0.2, z * 0.2, 1, 5) * 0.4;
                const micro = seededRandom(i * 17) * 0.15;
                terrainPositions.setX(i, x * (1 + hillNoise * 0.3));
                terrainPositions.setY(i, y * (1 + hillNoise + micro));
                terrainPositions.setZ(i, z * (1 + hillNoise * 0.3));
            }
            terrainGeo.computeVertexNormals();
            
            // Lush grass material
            const grassMat = new THREE.MeshPhongMaterial({
                color: 0x3d7a2e,
                shininess: 12,
                specular: 0x224422
            });
            const terrain = new THREE.Mesh(terrainGeo, grassMat);
            terrain.position.y = height * 0.5;
            terrain.castShadow = true;
            terrain.receiveShadow = true;
            group.add(terrain);
            
            // === DARKER GRASS PATCHES ===
            const numPatches = Math.floor(seededRandom(20) * 5) + 3;
            for (let p = 0; p < numPatches; p++) {
                const patchGeo = new THREE.CircleGeometry(size * 0.15 + seededRandom(p * 21) * size * 0.1, 8);
                const patchMat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.28 + seededRandom(p * 23) * 0.05, 0.6, 0.25 + seededRandom(p * 25) * 0.1),
                    shininess: 8
                });
                const patch = new THREE.Mesh(patchGeo, patchMat);
                const angle = seededRandom(p * 27) * Math.PI * 2;
                const dist = seededRandom(p * 29) * size * 0.4;
                patch.position.set(Math.cos(angle) * dist, height * 0.5 + size * 0.3, Math.sin(angle) * dist);
                patch.rotation.x = -Math.PI / 2 - 0.2;
                patch.rotation.z = seededRandom(p * 31) * 0.3;
                group.add(patch);
            }
            
            // === REALISTIC PALM TREES ===
            const numTrees = Math.floor(seededRandom(50) * 2) + 2;
            for (let t = 0; t < numTrees; t++) {
                const tree = createRealisticPalmTree(seededRandom(t + 200), size);
                const angle = seededRandom(t + 300) * Math.PI * 2;
                const dist = seededRandom(t + 400) * size * 0.35 + size * 0.1;
                tree.position.set(
                    Math.cos(angle) * dist,
                    height * 0.5 + size * 0.2,
                    Math.sin(angle) * dist
                );
                tree.rotation.y = seededRandom(t + 500) * Math.PI * 2;
                const treeScale = 0.7 + seededRandom(t + 600) * 0.5;
                tree.scale.setScalar(treeScale);
                group.add(tree);
            }
            
            // === TROPICAL BUSHES ===
            const numBushes = Math.floor(seededRandom(60) * 2) + 2;
            for (let b = 0; b < numBushes; b++) {
                const bush = createTropicalBush(seededRandom(b + 700));
                const angle = seededRandom(b + 710) * Math.PI * 2;
                const dist = seededRandom(b + 720) * size * 0.5;
                bush.position.set(
                    Math.cos(angle) * dist,
                    height * 0.5 + size * 0.15,
                    Math.sin(angle) * dist
                );
                bush.scale.setScalar(0.5 + seededRandom(b + 730) * 0.5);
                group.add(bush);
            }
            
            // === SCATTERED ROCKS ===
            const numRocks = Math.floor(seededRandom(70) * 3) + 2;
            for (let r = 0; r < numRocks; r++) {
                const rock = createRealisticRock(seededRandom(r + 800), 1 + seededRandom(r + 810) * 3);
                const onBeach = seededRandom(r + 815) > 0.5;
                const angle = seededRandom(r + 820) * Math.PI * 2;
                const dist = onBeach ? size * 0.9 + seededRandom(r + 825) * size * 0.2 : seededRandom(r + 830) * size * 0.5;
                const yPos = onBeach ? 0.5 : height * 0.5 + size * 0.1;
                rock.position.set(Math.cos(angle) * dist, yPos, Math.sin(angle) * dist);
                rock.rotation.set(
                    seededRandom(r + 840) * 0.3,
                    seededRandom(r + 850) * Math.PI * 2,
                    seededRandom(r + 860) * 0.3
                );
                rock.castShadow = true;
                group.add(rock);
            }
            
            // === DRIFTWOOD ON BEACH ===
            const numDriftwood = Math.floor(seededRandom(90) * 3) + 1;
            for (let d = 0; d < numDriftwood; d++) {
                const driftwood = createDriftwood(seededRandom(d + 900));
                const angle = seededRandom(d + 910) * Math.PI * 2;
                const dist = size * 0.95 + seededRandom(d + 920) * size * 0.15;
                driftwood.position.set(Math.cos(angle) * dist, 0.4, Math.sin(angle) * dist);
                driftwood.rotation.y = angle + seededRandom(d + 930) * 0.5;
                group.add(driftwood);
            }
            
            // === TIDE POOLS ===
            const numPools = Math.floor(seededRandom(95) * 2) + 1;
            for (let tp = 0; tp < numPools; tp++) {
                const poolGeo = new THREE.CircleGeometry(1.5 + seededRandom(tp * 100) * 2, 12);
                const poolMat = new THREE.MeshPhongMaterial({
                    color: 0x2a5a6a,
                    shininess: 90,
                    specular: 0x668899,
                    transparent: true,
                    opacity: 0.8
                });
                const pool = new THREE.Mesh(poolGeo, poolMat);
                const angle = seededRandom(tp * 102) * Math.PI * 2;
                pool.position.set(Math.cos(angle) * size * 0.85, 0.35, Math.sin(angle) * size * 0.85);
                pool.rotation.x = -Math.PI / 2;
                group.add(pool);
            }
            
            // === SEASHELLS ===
            const numShells = Math.floor(seededRandom(110) * 3) + 2;
            for (let sh = 0; sh < numShells; sh++) {
                const shellGeo = new THREE.ConeGeometry(0.15 + seededRandom(sh * 112) * 0.1, 0.3, 6);
                const shellColors = [0xfff5e6, 0xffe4c4, 0xeeddcc, 0xddccbb];
                const shellMat = new THREE.MeshPhongMaterial({
                    color: shellColors[Math.floor(seededRandom(sh * 114) * shellColors.length)],
                    shininess: 40
                });
                const shell = new THREE.Mesh(shellGeo, shellMat);
                const angle = seededRandom(sh * 116) * Math.PI * 2;
                const dist = size * 0.85 + seededRandom(sh * 118) * size * 0.25;
                shell.position.set(Math.cos(angle) * dist, 0.35, Math.sin(angle) * dist);
                shell.rotation.x = Math.PI / 2 + seededRandom(sh * 120) * 0.5;
                shell.rotation.z = seededRandom(sh * 122) * Math.PI * 2;
                group.add(shell);
            }
            
            return { group, animations: null };
        }
        
        function createRealisticPalmTree(seed, islandSize) {
            const group = new THREE.Group();
            
            // Curved trunk with segments
            const trunkSegments = 8;
            const trunkHeight = 10 + seed * 4;
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3((seed - 0.5) * 1.5, trunkHeight * 0.3, (seed - 0.3) * 1),
                new THREE.Vector3((seed - 0.5) * 2, trunkHeight * 0.6, (seed - 0.5) * 1.5),
                new THREE.Vector3((seed - 0.4) * 1.5, trunkHeight * 0.85, (seed - 0.4) * 1),
                new THREE.Vector3((seed - 0.5) * 0.5, trunkHeight, (seed - 0.5) * 0.5)
            ]);
            
            const trunkGeo = new THREE.TubeGeometry(curve, 20, 0.4, 8, false);
            
            // Bark texture via vertex colors
            const trunkMat = new THREE.MeshPhongMaterial({
                color: 0x6b5030,
                shininess: 5,
                specular: 0x221100
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            group.add(trunk);
            
            // Trunk rings/segments
            for (let r = 0; r < trunkSegments; r++) {
                const t = r / trunkSegments;
                const ringPos = curve.getPoint(t);
                const ringGeo = new THREE.TorusGeometry(0.45, 0.08, 6, 12);
                const ringMat = new THREE.MeshPhongMaterial({ color: 0x4a3520, shininess: 3 });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.position.copy(ringPos);
                ring.rotation.x = Math.PI / 2;
                group.add(ring);
            }
            
            // Crown position
            const crownPos = curve.getPoint(1);
            
            // Fronds with individual leaves
            const numFronds = 9 + Math.floor(seed * 4);
            for (let f = 0; f < numFronds; f++) {
                const frond = createPalmFrond(seed + f * 0.1);
                const angle = (f / numFronds) * Math.PI * 2 + seed * 2;
                const tilt = 0.3 + seed * 0.4 + (f % 2) * 0.2;
                frond.position.copy(crownPos);
                frond.rotation.y = angle;
                frond.rotation.x = tilt;
                frond.rotation.z = (seed - 0.5) * 0.2;
                group.add(frond);
            }
            
            // Coconut cluster
            const numCoconuts = 2 + Math.floor(seed * 4);
            for (let c = 0; c < numCoconuts; c++) {
                const coconutGeo = new THREE.SphereGeometry(0.35, 10, 10);
                const coconutMat = new THREE.MeshPhongMaterial({
                    color: 0x4a3a20,
                    shininess: 15,
                    specular: 0x222211
                });
                const coconut = new THREE.Mesh(coconutGeo, coconutMat);
                const cAngle = (c / numCoconuts) * Math.PI * 2 + seed;
                coconut.position.set(
                    crownPos.x + Math.cos(cAngle) * 0.5,
                    crownPos.y - 0.8 - seed * 0.3,
                    crownPos.z + Math.sin(cAngle) * 0.5
                );
                coconut.scale.y = 1.2;
                coconut.castShadow = true;
                group.add(coconut);
            }
            
            // Dead fronds hanging
            const numDeadFronds = Math.floor(seed * 3);
            for (let df = 0; df < numDeadFronds; df++) {
                const deadGeo = new THREE.ConeGeometry(0.3, 4, 4);
                const deadMat = new THREE.MeshPhongMaterial({ color: 0x6a5a3a, shininess: 3 });
                const dead = new THREE.Mesh(deadGeo, deadMat);
                const dAngle = (df / 3) * Math.PI * 2 + seed * 3;
                dead.position.set(
                    crownPos.x + Math.cos(dAngle) * 0.6,
                    crownPos.y - 1.5,
                    crownPos.z + Math.sin(dAngle) * 0.6
                );
                dead.rotation.x = Math.PI * 0.7;
                dead.rotation.z = dAngle;
                group.add(dead);
            }
            
            return group;
        }
        
        function createPalmFrond(seed) {
            const group = new THREE.Group();
            
            // Frond stem
            const stemCurve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0, -0.5, 2),
                new THREE.Vector3(0, -1.5, 4),
                new THREE.Vector3(0, -2.5, 5.5)
            ]);
            const stemGeo = new THREE.TubeGeometry(stemCurve, 12, 0.08, 6, false);
            const stemMat = new THREE.MeshPhongMaterial({ color: 0x4a6a2a, shininess: 8 });
            const stem = new THREE.Mesh(stemGeo, stemMat);
            group.add(stem);
            
            // Individual leaflets
            const numLeaflets = 14;
            for (let l = 0; l < numLeaflets; l++) {
                const t = (l + 2) / (numLeaflets + 2);
                const leafPos = stemCurve.getPoint(t);
                const leafLength = 1.5 * (1 - Math.abs(t - 0.5) * 1.5);
                
                for (let side = -1; side <= 1; side += 2) {
                    const leafGeo = new THREE.PlaneGeometry(0.15, leafLength);
                    const leafMat = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL(0.28 + seed * 0.03, 0.7, 0.35 + seed * 0.1),
                        shininess: 15,
                        side: THREE.DoubleSide
                    });
                    const leaf = new THREE.Mesh(leafGeo, leafMat);
                    leaf.position.copy(leafPos);
                    leaf.position.x += side * leafLength * 0.5;
                    leaf.rotation.z = side * 0.4;
                    leaf.rotation.y = side * 0.3;
                    group.add(leaf);
                }
            }
            
            return group;
        }
        
        function createTropicalBush(seed) {
            const group = new THREE.Group();
            
            const numClusters = 5 + Math.floor(seed * 4);
            for (let c = 0; c < numClusters; c++) {
                const clusterGeo = new THREE.SphereGeometry(0.6 + seed * 0.3, 8, 6);
                const positions = clusterGeo.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const n = Math.sin(seed * 100 + i) * 0.2;
                    positions.setX(i, x * (1 + n));
                    positions.setY(i, y * (1 + n * 0.5));
                    positions.setZ(i, z * (1 + n));
                }
                clusterGeo.computeVertexNormals();
                
                const clusterMat = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.25 + seed * 0.08, 0.65, 0.3 + seed * 0.1),
                    shininess: 10
                });
                const cluster = new THREE.Mesh(clusterGeo, clusterMat);
                const angle = (c / numClusters) * Math.PI * 2;
                cluster.position.set(
                    Math.cos(angle) * (0.3 + seed * 0.3),
                    0.3 + c * 0.15,
                    Math.sin(angle) * (0.3 + seed * 0.3)
                );
                cluster.castShadow = true;
                group.add(cluster);
            }
            
            // Flowers on some bushes
            if (seed > 0.6) {
                const numFlowers = 3 + Math.floor(seed * 5);
                const flowerColors = [0xff6688, 0xffaa44, 0xffff66, 0xff44aa, 0xffffff];
                for (let fl = 0; fl < numFlowers; fl++) {
                    const flowerGeo = new THREE.SphereGeometry(0.12, 6, 6);
                    const flowerMat = new THREE.MeshBasicMaterial({
                        color: flowerColors[Math.floor(seed * 10 + fl) % flowerColors.length]
                    });
                    const flower = new THREE.Mesh(flowerGeo, flowerMat);
                    flower.position.set(
                        (seed - 0.5) * 1.5 + Math.sin(fl * 2) * 0.5,
                        0.8 + seed * 0.5,
                        (seed - 0.3) * 1.5 + Math.cos(fl * 2) * 0.5
                    );
                    group.add(flower);
                }
            }
            
            return group;
        }
        
        function createRealisticRock(seed, size) {
            const geo = new THREE.DodecahedronGeometry(size, 1);
            const positions = geo.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                const n = Math.sin(seed * 1000 + i * 7) * 0.3;
                positions.setX(i, x * (1 + n));
                positions.setY(i, y * (0.7 + n * 0.5));
                positions.setZ(i, z * (1 + n));
            }
            geo.computeVertexNormals();
            
            const rockColors = [0x5a5045, 0x6a6055, 0x4a4035, 0x7a7065];
            const mat = new THREE.MeshPhongMaterial({
                color: rockColors[Math.floor(seed * rockColors.length)],
                shininess: 12,
                specular: 0x222222,
                flatShading: true
            });
            
            const rock = new THREE.Mesh(geo, mat);
            
            // Add moss on top of some rocks
            if (seed > 0.4) {
                const mossGeo = new THREE.SphereGeometry(size * 0.6, 8, 6, 0, Math.PI * 2, 0, Math.PI / 3);
                const mossMat = new THREE.MeshPhongMaterial({
                    color: 0x3a5a2a,
                    shininess: 5
                });
                const moss = new THREE.Mesh(mossGeo, mossMat);
                moss.position.y = size * 0.4;
                rock.add(moss);
            }
            
            return rock;
        }
        
        function createDriftwood(seed) {
            const group = new THREE.Group();
            
            const length = 2 + seed * 3;
            const curve = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-length / 2, 0, 0),
                new THREE.Vector3(-length / 4, 0.2 * seed, 0.3 * seed),
                new THREE.Vector3(length / 4, 0.1 * seed, -0.2 * seed),
                new THREE.Vector3(length / 2, 0, 0)
            ]);
            
            const logGeo = new THREE.TubeGeometry(curve, 12, 0.15 + seed * 0.1, 8, false);
            const logMat = new THREE.MeshPhongMaterial({
                color: 0x8a7a6a,
                shininess: 3,
                specular: 0x111111
            });
            const log = new THREE.Mesh(logGeo, logMat);
            log.castShadow = true;
            group.add(log);
            
            // Small branches
            const numBranches = Math.floor(seed * 3) + 1;
            for (let b = 0; b < numBranches; b++) {
                const branchGeo = new THREE.CylinderGeometry(0.03, 0.06, 0.5 + seed * 0.5, 6);
                const branch = new THREE.Mesh(branchGeo, logMat);
                const t = (b + 1) / (numBranches + 1);
                const pos = curve.getPoint(t);
                branch.position.copy(pos);
                branch.position.y += 0.15;
                branch.rotation.z = (seed - 0.5) * Math.PI * 0.5;
                branch.rotation.x = seed * 0.5;
                group.add(branch);
            }
            
            return group;
        }
        
        function createPalmTree(seed) {
            // Redirect to realistic version
            return createRealisticPalmTree(seed, 30);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createDetailedShip(color, isPlayer, team) {
            const group = new THREE.Group();
            const teamColor = new THREE.Color(team === 'red' ? 0x8b0000 : 0x1c3d5a);
            
            // Ultra-realistic naval ship materials with weathering
            const hullGray = new THREE.Color(0x3d4448);
            const darkGray = new THREE.Color(0x252a2e);
            const deckWood = new THREE.Color(0x5a3a1f);
            const metalDark = new THREE.Color(0x151618);
            const rust = new THREE.Color(0x4a2d1b);
            const brassAccent = new THREE.Color(0x8b7355);
            
            // Enhanced PBR-like materials with realistic metal appearance
            const hullMaterial = new THREE.MeshPhongMaterial({ 
                color: hullGray, 
                shininess: 35,
                specular: 0x3a3a3a,
                flatShading: false,
                reflectivity: 0.2
            });
            
            const armoredMaterial = new THREE.MeshPhongMaterial({ 
                color: darkGray, 
                shininess: 55,
                specular: 0x4a4a4a,
                reflectivity: 0.3
            });
            
            const deckMaterial = new THREE.MeshPhongMaterial({ 
                color: deckWood, 
                shininess: 12,
                specular: 0x1a1a1a,
                reflectivity: 0.05
            });
            
            const metalMaterial = new THREE.MeshPhongMaterial({ 
                color: metalDark, 
                shininess: 80,
                specular: 0x666666,
                reflectivity: 0.4
            });
            
            const brassMaterial = new THREE.MeshPhongMaterial({
                color: brassAccent,
                shininess: 90,
                specular: 0x886644,
                reflectivity: 0.5
            });

            // === MAIN HULL - Realistic warship shape ===
            // Lower hull (underwater portion - anti-fouling paint red/black)
            const lowerHullShape = new THREE.Shape();
            lowerHullShape.moveTo(-20, 0);
            lowerHullShape.quadraticCurveTo(-18, 3, -14, 4);
            lowerHullShape.lineTo(18, 4);
            lowerHullShape.quadraticCurveTo(24, 3, 28, 0);
            lowerHullShape.quadraticCurveTo(24, -3, 18, -4);
            lowerHullShape.lineTo(-14, -4);
            lowerHullShape.quadraticCurveTo(-18, -3, -20, 0);
            
            const lowerHullGeo = new THREE.ExtrudeGeometry(lowerHullShape, { 
                depth: 5, bevelEnabled: true, bevelThickness: 0.8, bevelSize: 0.8, bevelSegments: 3 
            });
            const lowerHullMat = new THREE.MeshPhongMaterial({ 
                color: 0x2a1515, shininess: 15, specular: 0x111111
            });
            const lowerHull = new THREE.Mesh(lowerHullGeo, lowerHullMat);
            lowerHull.rotation.x = Math.PI / 2;
            lowerHull.position.y = -2.5;
            lowerHull.castShadow = true;
            lowerHull.receiveShadow = true;
            group.add(lowerHull);

            // Upper hull 
            const upperHullShape = new THREE.Shape();
            upperHullShape.moveTo(-18, 0);
            upperHullShape.quadraticCurveTo(-16, 4.5, -12, 5);
            upperHullShape.lineTo(20, 5);
            upperHullShape.quadraticCurveTo(26, 4, 30, 0);
            upperHullShape.quadraticCurveTo(26, -4, 20, -5);
            upperHullShape.lineTo(-12, -5);
            upperHullShape.quadraticCurveTo(-16, -4.5, -18, 0);
            
            const upperHullGeo = new THREE.ExtrudeGeometry(upperHullShape, { 
                depth: 6, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.5, bevelSegments: 2 
            });
            const upperHull = new THREE.Mesh(upperHullGeo, hullMaterial);
            upperHull.rotation.x = Math.PI / 2;
            upperHull.position.y = 2.5;
            upperHull.castShadow = true;
            upperHull.receiveShadow = true;
            group.add(upperHull);

            // Hull plating lines (welded seams)
            for (let i = -16; i <= 24; i += 8) {
                const seamGeo = new THREE.BoxGeometry(0.15, 6, 10.5);
                const seamMat = new THREE.MeshPhongMaterial({ color: 0x252525, shininess: 10 });
                const seam = new THREE.Mesh(seamGeo, seamMat);
                seam.position.set(i, 2, 0);
                group.add(seam);
            }
            
            // Rust streaks (weathering detail)
            for (let i = 0; i < 8; i++) {
                const rustGeo = new THREE.PlaneGeometry(0.3, 2 + Math.random() * 3);
                const rustMat = new THREE.MeshBasicMaterial({ 
                    color: rust, 
                    transparent: true, 
                    opacity: 0.3 + Math.random() * 0.3,
                    side: THREE.DoubleSide
                });
                const rustStreak = new THREE.Mesh(rustGeo, rustMat);
                rustStreak.position.set(
                    -15 + Math.random() * 40,
                    1 + Math.random() * 3,
                    (Math.random() > 0.5 ? 5.1 : -5.1)
                );
                group.add(rustStreak);
            }

            // Waterline stripe
            const waterlineGeo = new THREE.BoxGeometry(52, 0.4, 10.2);
            const waterlineMat = new THREE.MeshPhongMaterial({ color: teamColor });
            const waterline = new THREE.Mesh(waterlineGeo, waterlineMat);
            waterline.position.set(4, 0, 0);
            group.add(waterline);

            // === BOW (Front) Details ===
            // Bow wave cutter
            const bowGeo = new THREE.ConeGeometry(2, 8, 4);
            const bowMat = new THREE.MeshPhongMaterial({ color: hullGray });
            const bow = new THREE.Mesh(bowGeo, bowMat);
            bow.rotation.z = -Math.PI / 2;
            bow.position.set(32, 2, 0);
            bow.castShadow = true;
            group.add(bow);

            // Anchor housings
            for (let z of [-3.5, 3.5]) {
                const anchorHouseGeo = new THREE.BoxGeometry(2, 3, 1.5);
                const anchorHouse = new THREE.Mesh(anchorHouseGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                anchorHouse.position.set(22, 4, z);
                group.add(anchorHouse);
                
                // Anchor chain holes
                const chainHoleGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 8);
                const chainHole = new THREE.Mesh(chainHoleGeo, new THREE.MeshPhongMaterial({ color: 0x000000 }));
                chainHole.rotation.x = Math.PI / 2;
                chainHole.position.set(22, 3.5, z > 0 ? z + 0.8 : z - 0.8);
                group.add(chainHole);
            }

            // === MAIN DECK ===
            const deckGeo = new THREE.BoxGeometry(48, 0.8, 9);
            const deckMat = new THREE.MeshPhongMaterial({ color: deckWood, shininess: 10 });
            const deck = new THREE.Mesh(deckGeo, deckMat);
            deck.position.set(4, 5.4, 0);
            deck.receiveShadow = true;
            group.add(deck);

            // Deck planking detail
            for (let i = -20; i <= 26; i += 1.5) {
                const plankGeo = new THREE.BoxGeometry(0.08, 0.1, 8.5);
                const plankMat = new THREE.MeshPhongMaterial({ color: 0x3d2817 });
                const plank = new THREE.Mesh(plankGeo, plankMat);
                plank.position.set(i, 5.9, 0);
                group.add(plank);
            }

            // === FORWARD MAIN TURRET (Triple 16-inch guns) ===
            // Turret barbette (armored base)
            const barbetteGeo = new THREE.CylinderGeometry(4.5, 5, 3, 16);
            const armorMat = new THREE.MeshPhongMaterial({ color: hullGray, shininess: 60 });
            const barbette1 = new THREE.Mesh(barbetteGeo, armorMat);
            barbette1.position.set(16, 7, 0);
            barbette1.castShadow = true;
            group.add(barbette1);

            // Turret housing
            const turretShape = new THREE.Shape();
            turretShape.moveTo(-3.5, -3);
            turretShape.lineTo(-3.5, 3);
            turretShape.quadraticCurveTo(4, 3.5, 5, 0);
            turretShape.quadraticCurveTo(4, -3.5, -3.5, -3);
            
            const turretGeo = new THREE.ExtrudeGeometry(turretShape, { 
                depth: 3.5, bevelEnabled: true, bevelThickness: 0.3, bevelSize: 0.3 
            });
            const turret1 = new THREE.Mesh(turretGeo, armorMat);
            turret1.rotation.x = Math.PI / 2;
            turret1.position.set(16, 9.5, 0);
            turret1.castShadow = true;
            group.add(turret1);

            // Main gun barrels (triple)
            for (let z of [-1.5, 0, 1.5]) {
                const barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 14, 12);
                const barrelMat = new THREE.MeshPhongMaterial({ color: metalDark, shininess: 80 });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = -Math.PI / 2;
                barrel.position.set(26, 9.5, z);
                barrel.castShadow = true;
                group.add(barrel);
                
                // Barrel blast shields
                const shieldGeo = new THREE.CylinderGeometry(0.7, 0.8, 1, 12);
                const shield = new THREE.Mesh(shieldGeo, armorMat);
                shield.rotation.z = -Math.PI / 2;
                shield.position.set(20, 9.5, z);
                group.add(shield);
            }

            // === AFT MAIN TURRET ===
            const barbette2 = new THREE.Mesh(barbetteGeo.clone(), armorMat);
            barbette2.position.set(-8, 7, 0);
            barbette2.castShadow = true;
            group.add(barbette2);

            const turret2 = turret1.clone();
            turret2.position.set(-8, 9.5, 0);
            turret2.rotation.y = Math.PI;
            group.add(turret2);

            for (let z of [-1.5, 0, 1.5]) {
                const barrelGeo = new THREE.CylinderGeometry(0.5, 0.6, 14, 12);
                const barrel = new THREE.Mesh(barrelGeo, new THREE.MeshPhongMaterial({ color: metalDark, shininess: 80 }));
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(-18, 9.5, z);
                barrel.castShadow = true;
                group.add(barrel);
            }

            // === SUPERSTRUCTURE / BRIDGE ===
            // Main bridge structure
            const bridgeGeo1 = new THREE.BoxGeometry(10, 6, 7);
            const bridgeMat = new THREE.MeshPhongMaterial({ color: hullGray, shininess: 40 });
            const bridge = new THREE.Mesh(bridgeGeo1, bridgeMat);
            bridge.position.set(4, 9, 0);
            bridge.castShadow = true;
            group.add(bridge);

            // Bridge upper level
            const bridgeGeo2 = new THREE.BoxGeometry(7, 3, 5);
            const bridgeUpper = new THREE.Mesh(bridgeGeo2, bridgeMat);
            bridgeUpper.position.set(4, 13.5, 0);
            bridgeUpper.castShadow = true;
            group.add(bridgeUpper);

            // Bridge windows (armored slits)
            for (let i = -2; i <= 2; i++) {
                const windowGeo = new THREE.BoxGeometry(1.2, 0.4, 0.2);
                const windowMat = new THREE.MeshPhongMaterial({ 
                    color: 0x1a3050, emissive: 0x0a1525, emissiveIntensity: 0.5, shininess: 100 
                });
                const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                windowMesh.position.set(4 + i * 1.5, 14, 2.55);
                group.add(windowMesh);
            }

            // Fire control tower
            const towerGeo = new THREE.CylinderGeometry(1.5, 2, 8, 12);
            const tower = new THREE.Mesh(towerGeo, bridgeMat);
            tower.position.set(4, 19, 0);
            tower.castShadow = true;
            group.add(tower);

            // Rangefinder on top
            const rangefinderGeo = new THREE.BoxGeometry(8, 1.5, 1.5);
            const rangefinder = new THREE.Mesh(rangefinderGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
            rangefinder.position.set(4, 24, 0);
            group.add(rangefinder);

            // === FUNNELS (Smokestacks) ===
            const funnelGeo = new THREE.CylinderGeometry(1.8, 2.2, 10, 16);
            const funnelMat = new THREE.MeshPhongMaterial({ color: darkGray, shininess: 30 });
            
            const funnel1 = new THREE.Mesh(funnelGeo, funnelMat);
            funnel1.position.set(-1, 14, 0);
            funnel1.castShadow = true;
            group.add(funnel1);

            // Funnel cap
            const capGeo = new THREE.CylinderGeometry(2, 1.8, 1, 16);
            const cap1 = new THREE.Mesh(capGeo, funnelMat);
            cap1.position.set(-1, 19.5, 0);
            group.add(cap1);

            // Funnel band (team color)
            const bandGeo = new THREE.CylinderGeometry(2.0, 2.0, 1.5, 16);
            const bandMat = new THREE.MeshPhongMaterial({ color: teamColor });
            const band1 = new THREE.Mesh(bandGeo, bandMat);
            band1.position.set(-1, 17, 0);
            group.add(band1);

            // === SECONDARY ARMAMENT ===
            // 5-inch dual-purpose guns
            const positions = [
                { x: 10, z: 4.5 }, { x: 10, z: -4.5 },
                { x: 0, z: 4.5 }, { x: 0, z: -4.5 }
            ];
            
            for (let pos of positions) {
                // Gun mount
                const mountGeo = new THREE.CylinderGeometry(1.2, 1.4, 1.5, 12);
                const mount = new THREE.Mesh(mountGeo, armorMat);
                mount.position.set(pos.x, 6.5, pos.z);
                group.add(mount);
                
                // Gun shield
                const shieldGeo = new THREE.BoxGeometry(2, 1.5, 2.5);
                const shieldMesh = new THREE.Mesh(shieldGeo, armorMat);
                shieldMesh.position.set(pos.x + 0.5, 7.5, pos.z);
                group.add(shieldMesh);
                
                // Gun barrel
                const gunGeo = new THREE.CylinderGeometry(0.2, 0.25, 6, 8);
                const gun = new THREE.Mesh(gunGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
                gun.rotation.z = -Math.PI / 2;
                gun.position.set(pos.x + 4.5, 7.5, pos.z);
                group.add(gun);
            }

            // === ANTI-AIRCRAFT GUNS ===
            const aaPositions = [
                { x: 8, z: 3.5 }, { x: 8, z: -3.5 },
                { x: -4, z: 3.5 }, { x: -4, z: -3.5 }
            ];
            
            for (let pos of aaPositions) {
                // AA gun quad mount
                const aaMountGeo = new THREE.CylinderGeometry(0.6, 0.8, 0.8, 8);
                const aaMount = new THREE.Mesh(aaMountGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                aaMount.position.set(pos.x, 12.5, pos.z);
                group.add(aaMount);
                
                // Quad barrels
                for (let dz of [-0.3, 0.3]) {
                    for (let dy of [-0.3, 0.3]) {
                        const aaGunGeo = new THREE.CylinderGeometry(0.08, 0.1, 2.5, 6);
                        const aaGun = new THREE.Mesh(aaGunGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
                        aaGun.rotation.z = -Math.PI / 2 + 0.3;
                        aaGun.position.set(pos.x + 1.2, 12.8 + dy, pos.z + dz);
                        group.add(aaGun);
                    }
                }
            }

            // === MAST AND RADAR ===
            const mastGeo = new THREE.CylinderGeometry(0.25, 0.4, 18, 8);
            const mastMat = new THREE.MeshPhongMaterial({ color: darkGray });
            const mast = new THREE.Mesh(mastGeo, mastMat);
            mast.position.set(4, 32, 0);
            group.add(mast);

            // Radar array
            const radarGeo = new THREE.BoxGeometry(6, 0.4, 3);
            const radarMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const radar = new THREE.Mesh(radarGeo, radarMat);
            radar.position.set(4, 40, 0);
            group.add(radar);

            // Radar mesh
            const meshGeo = new THREE.PlaneGeometry(5.5, 2.5);
            const meshMat = new THREE.MeshBasicMaterial({ 
                color: 0x333333, side: THREE.DoubleSide, transparent: true, opacity: 0.7 
            });
            const radarMesh = new THREE.Mesh(meshGeo, meshMat);
            radarMesh.position.set(4, 40.3, 0);
            group.add(radarMesh);

            // Yardarms
            const yardGeo = new THREE.CylinderGeometry(0.1, 0.1, 10, 6);
            const yard = new THREE.Mesh(yardGeo, mastMat);
            yard.rotation.z = Math.PI / 2;
            yard.position.set(4, 35, 0);
            group.add(yard);

            // === NAVIGATION LIGHTS ===
            const lightGeo = new THREE.SphereGeometry(0.4, 8, 8);
            
            // Port (red) and starboard (green) lights
            const portColor = isPlayer ? 0x00ff88 : 0xff0000;
            const starboardColor = isPlayer ? 0x00ff88 : 0x00ff00;
            
            const portLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: portColor }));
            portLight.position.set(6, 13, -3.5);
            group.add(portLight);
            
            const starboardLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: starboardColor }));
            starboardLight.position.set(6, 13, 3.5);
            group.add(starboardLight);

            // Masthead light
            const mastheadLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
            mastheadLight.position.set(4, 41, 0);
            group.add(mastheadLight);

            // === PLAYER INDICATOR ===
            if (isPlayer) {
                const glowGeo = new THREE.TorusGeometry(12, 0.6, 8, 32);
                const glowMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88, transparent: true, opacity: 0.5
                });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = Math.PI / 2;
                glow.position.y = 1;
                group.add(glow);

                const spotlight = new THREE.PointLight(0x00ff88, 1.5, 60);
                spotlight.position.set(0, 20, 0);
                group.add(spotlight);
            }

            // === TEAM FLAG ===
            const flagPoleGeo = new THREE.CylinderGeometry(0.08, 0.08, 6, 6);
            const flagPole = new THREE.Mesh(flagPoleGeo, mastMat);
            flagPole.position.set(-17, 8, 0);
            group.add(flagPole);

            const flagGeo = new THREE.PlaneGeometry(4, 2.5);
            const flagMat = new THREE.MeshPhongMaterial({ 
                color: team === 'red' ? 0xff3333 : 0x3366ff, side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(-17, 10.5, 2);
            group.add(flag);

            // === PROPELLER GUARDS (stern) ===
            for (let z of [-2.5, 2.5]) {
                const guardGeo = new THREE.BoxGeometry(3, 1.5, 0.3);
                const guard = new THREE.Mesh(guardGeo, new THREE.MeshPhongMaterial({ color: darkGray }));
                guard.position.set(-18, 0, z);
                group.add(guard);
            }

            // Rudder
            const rudderGeo = new THREE.BoxGeometry(0.5, 4, 2);
            const rudder = new THREE.Mesh(rudderGeo, new THREE.MeshPhongMaterial({ color: metalDark }));
            rudder.position.set(-19, -1, 0);
            group.add(rudder);

            return group;
        }

        // Unique ship designs for every ship in the shop
        function createShipByDesign(color, isPlayer, team, shipData) {
            if (!shipData || !isPlayer) {
                return createDetailedShip(color, isPlayer, team);
            }
            
            const group = new THREE.Group();
            const shipId = shipData.id;
            
            // Generate unique colors based on ship ID hash
            function hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = ((hash << 5) - hash) + str.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash);
            }
            
            const hash = hashCode(shipId);
            const hue1 = (hash % 360) / 360;
            const hue2 = ((hash * 7) % 360) / 360;
            const hue3 = ((hash * 13) % 360) / 360;
            
            // Create colors from hash
            const hullColor = new THREE.Color().setHSL(hue1, 0.4, 0.25);
            const accentColor = new THREE.Color().setHSL(hue2, 0.7, 0.5);
            const glowColor = new THREE.Color().setHSL(hue3, 0.9, 0.6);
            
            const hullMat = new THREE.MeshPhongMaterial({ color: hullColor, shininess: 30 });
            const accentMat = new THREE.MeshPhongMaterial({ color: accentColor, shininess: 60 });
            const darkMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, shininess: 40 });
            const glowMat = new THREE.MeshBasicMaterial({ color: glowColor });
            
            // Ship parameters from stats
            const healthScale = 0.6 + (shipData.health / 150) * 0.8;
            const speedScale = 0.7 + shipData.speed * 0.3;
            const damageScale = 0.8 + (shipData.damage - 1) * 0.3;
            
            // Unique hull shape parameters based on hash
            const bowLength = 8 + (hash % 20);
            const hullWidth = 4 + (hash % 6);
            const sternWidth = 3 + ((hash >> 4) % 4);
            const hullCurve = 2 + ((hash >> 8) % 4);
            
            // Build unique hull
            const hullShape = new THREE.Shape();
            hullShape.moveTo(-20, 0);
            hullShape.quadraticCurveTo(-18, hullCurve, -12, hullWidth);
            hullShape.lineTo(bowLength, hullWidth * 0.9);
            hullShape.quadraticCurveTo(bowLength + 10, hullWidth * 0.5, bowLength + 15, 0);
            hullShape.quadraticCurveTo(bowLength + 10, -hullWidth * 0.5, bowLength, -hullWidth * 0.9);
            hullShape.lineTo(-12, -hullWidth);
            hullShape.quadraticCurveTo(-18, -hullCurve, -20, 0);
            
            const hullGeo = new THREE.ExtrudeGeometry(hullShape, { 
                depth: 5 * healthScale, 
                bevelEnabled: true, 
                bevelThickness: 0.5, 
                bevelSize: 0.5 
            });
            const hull = new THREE.Mesh(hullGeo, hullMat);
            hull.rotation.x = Math.PI / 2;
            hull.position.y = 2;
            group.add(hull);
            
            // Deck
            const deckGeo = new THREE.BoxGeometry(bowLength + 18, 0.5, hullWidth * 1.8);
            const deckMat = new THREE.MeshPhongMaterial({ color: 0x4a3a2a, shininess: 10 });
            const deck = new THREE.Mesh(deckGeo, deckMat);
            deck.position.set(bowLength/2 - 5, 5 * healthScale, 0);
            group.add(deck);
            
            // === SUPERSTRUCTURE - unique per ship ===
            const bridgeStyle = hash % 5;
            const bridgeHeight = 4 + ((hash >> 3) % 5);
            const bridgeWidth = 4 + ((hash >> 5) % 4);
            
            if (bridgeStyle === 0) {
                // Box bridge
                const bridgeGeo = new THREE.BoxGeometry(8, bridgeHeight, bridgeWidth);
                const bridge = new THREE.Mesh(bridgeGeo, accentMat);
                bridge.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                group.add(bridge);
            } else if (bridgeStyle === 1) {
                // Cylinder tower
                const towerGeo = new THREE.CylinderGeometry(bridgeWidth/2, bridgeWidth/2 + 1, bridgeHeight, 8);
                const tower = new THREE.Mesh(towerGeo, accentMat);
                tower.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                group.add(tower);
            } else if (bridgeStyle === 2) {
                // Stepped bridge
                for (let i = 0; i < 3; i++) {
                    const stepGeo = new THREE.BoxGeometry(8 - i*2, bridgeHeight/3, bridgeWidth - i);
                    const step = new THREE.Mesh(stepGeo, accentMat);
                    step.position.set(3, 5 * healthScale + bridgeHeight/3 * (i + 0.5), 0);
                    group.add(step);
                }
            } else if (bridgeStyle === 3) {
                // Angled bridge
                const bridgeGeo = new THREE.BoxGeometry(10, bridgeHeight, bridgeWidth);
                const bridge = new THREE.Mesh(bridgeGeo, accentMat);
                bridge.position.set(3, 5 * healthScale + bridgeHeight/2, 0);
                bridge.rotation.z = 0.15;
                group.add(bridge);
            } else {
                // Dome bridge
                const domeGeo = new THREE.SphereGeometry(bridgeWidth, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2);
                const dome = new THREE.Mesh(domeGeo, accentMat);
                dome.position.set(3, 5 * healthScale, 0);
                group.add(dome);
            }
            
            // === TURRETS - number based on damage stat ===
            const numTurrets = Math.max(1, Math.min(4, Math.floor(shipData.damage)));
            const turretPositions = [
                [bowLength - 2, 0],
                [-8, 0],
                [bowLength - 8, -3],
                [bowLength - 8, 3]
            ];
            
            const turretStyle = (hash >> 10) % 3;
            for (let i = 0; i < numTurrets; i++) {
                const [tx, tz] = turretPositions[i];
                
                if (turretStyle === 0) {
                    // Round turret
                    const turretGeo = new THREE.CylinderGeometry(2, 2.5, 2, 8);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                } else if (turretStyle === 1) {
                    // Square turret
                    const turretGeo = new THREE.BoxGeometry(3, 2, 3);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                } else {
                    // Hexagonal turret
                    const turretGeo = new THREE.CylinderGeometry(2, 2.3, 2, 6);
                    const turret = new THREE.Mesh(turretGeo, darkMat);
                    turret.position.set(tx, 6 * healthScale, tz);
                    group.add(turret);
                }
                
                // Gun barrels - number varies
                const numBarrels = 1 + ((hash >> (12 + i)) % 3);
                const barrelSpacing = 1.2;
                const startZ = -(numBarrels - 1) * barrelSpacing / 2;
                
                for (let b = 0; b < numBarrels; b++) {
                    const barrelLen = 8 + damageScale * 4;
                    const barrelGeo = new THREE.CylinderGeometry(0.3 + damageScale * 0.2, 0.4 + damageScale * 0.2, barrelLen, 8);
                    const barrel = new THREE.Mesh(barrelGeo, accentMat);
                    barrel.rotation.z = Math.PI / 2;
                    barrel.position.set(tx + barrelLen/2 + 2, 6 * healthScale, tz + startZ + b * barrelSpacing);
                    group.add(barrel);
                }
            }
            
            // === MAST/ANTENNA - unique styles ===
            const mastStyle = (hash >> 15) % 4;
            
            if (mastStyle === 0) {
                // Traditional mast
                const mastGeo = new THREE.CylinderGeometry(0.2, 0.3, 15, 6);
                const mast = new THREE.Mesh(mastGeo, darkMat);
                mast.position.set(0, 12 * healthScale, 0);
                group.add(mast);
                
                const radarGeo = new THREE.BoxGeometry(6, 0.3, 2);
                const radar = new THREE.Mesh(radarGeo, accentMat);
                radar.position.set(0, 18 * healthScale, 0);
                group.add(radar);
            } else if (mastStyle === 1) {
                // Antenna array
                for (let i = 0; i < 3; i++) {
                    const antGeo = new THREE.CylinderGeometry(0.1, 0.15, 8 + i * 3, 4);
                    const ant = new THREE.Mesh(antGeo, darkMat);
                    ant.position.set(-2 + i * 2, 10 * healthScale + (8 + i * 3)/2, 0);
                    group.add(ant);
                }
            } else if (mastStyle === 2) {
                // Dome radar
                const domeGeo = new THREE.SphereGeometry(2, 12, 12);
                const dome = new THREE.Mesh(domeGeo, accentMat);
                dome.position.set(0, 14 * healthScale, 0);
                group.add(dome);
                
                const poleGeo = new THREE.CylinderGeometry(0.5, 0.5, 6, 8);
                const pole = new THREE.Mesh(poleGeo, darkMat);
                pole.position.set(0, 10 * healthScale, 0);
                group.add(pole);
            } else {
                // Lattice tower
                for (let i = 0; i < 4; i++) {
                    const legGeo = new THREE.CylinderGeometry(0.15, 0.2, 12, 4);
                    const leg = new THREE.Mesh(legGeo, darkMat);
                    const angle = (i / 4) * Math.PI * 2;
                    leg.position.set(Math.cos(angle) * 1.5, 12 * healthScale, Math.sin(angle) * 1.5);
                    group.add(leg);
                }
            }
            
            // === DECORATIVE ELEMENTS based on category ===
            const category = shipData.category;
            
            if (category === 'speed') {
                // Speed fins
                for (let z of [-hullWidth - 1, hullWidth + 1]) {
                    const finGeo = new THREE.BoxGeometry(15, 0.3, 2);
                    const fin = new THREE.Mesh(finGeo, accentMat);
                    fin.position.set(-5, 3, z);
                    fin.rotation.z = z > 0 ? 0.1 : -0.1;
                    group.add(fin);
                }
                // Engine glows
                for (let z of [-2, 0, 2]) {
                    const engineGeo = new THREE.SphereGeometry(0.8, 8, 8);
                    const engine = new THREE.Mesh(engineGeo, glowMat);
                    engine.position.set(-22, 3, z);
                    group.add(engine);
                }
            } else if (category === 'tank') {
                // Armor plates
                for (let x = -10; x <= 15; x += 5) {
                    const plateGeo = new THREE.BoxGeometry(4, 3, hullWidth * 2 + 2);
                    const plateMat = new THREE.MeshPhongMaterial({ color: 0x333333, shininess: 20 });
                    const plate = new THREE.Mesh(plateGeo, plateMat);
                    plate.position.set(x, 6 * healthScale, 0);
                    group.add(plate);
                }
                // Shield generators
                for (let z of [-hullWidth - 2, hullWidth + 2]) {
                    const shieldGeo = new THREE.SphereGeometry(1.5, 10, 10);
                    const shield = new THREE.Mesh(shieldGeo, glowMat);
                    shield.position.set(5, 8 * healthScale, z);
                    group.add(shield);
                }
            } else if (category === 'damage') {
                // Weapon glow strips
                for (let z of [-hullWidth - 0.5, hullWidth + 0.5]) {
                    const stripGeo = new THREE.BoxGeometry(bowLength + 20, 0.4, 0.4);
                    const strip = new THREE.Mesh(stripGeo, glowMat);
                    strip.position.set(0, 4, z);
                    group.add(strip);
                }
                // Extra weapon pods
                for (let x of [-12, 15]) {
                    const podGeo = new THREE.BoxGeometry(3, 2, 2);
                    const pod = new THREE.Mesh(podGeo, accentMat);
                    pod.position.set(x, 5 * healthScale, hullWidth + 2);
                    group.add(pod);
                    const pod2 = pod.clone();
                    pod2.position.z = -hullWidth - 2;
                    group.add(pod2);
                }
            } else if (category === 'special') {
                // Unique rotating rings
                const ringGeo = new THREE.TorusGeometry(4, 0.3, 8, 24);
                const ring1 = new THREE.Mesh(ringGeo, glowMat);
                ring1.position.set(3, 12 * healthScale, 0);
                ring1.rotation.x = Math.PI / 4;
                group.add(ring1);
                
                const ring2 = new THREE.Mesh(ringGeo.clone(), glowMat);
                ring2.position.set(3, 12 * healthScale, 0);
                ring2.rotation.x = -Math.PI / 4;
                group.add(ring2);
                
                // Energy orbs
                for (let i = 0; i < 4; i++) {
                    const orbGeo = new THREE.SphereGeometry(1, 8, 8);
                    const orb = new THREE.Mesh(orbGeo, glowMat);
                    const angle = (i / 4) * Math.PI * 2 + (hash % 100) / 100;
                    orb.position.set(3 + Math.cos(angle) * 6, 8 * healthScale, Math.sin(angle) * 6);
                    group.add(orb);
                }
            } else {
                // Balanced - subtle enhancements
                const detailGeo = new THREE.BoxGeometry(2, 1, hullWidth * 2);
                const detail = new THREE.Mesh(detailGeo, accentMat);
                detail.position.set(-15, 5, 0);
                group.add(detail);
            }
            
            // === EXHAUST/PROPULSION unique to each ship ===
            const exhaustStyle = (hash >> 18) % 3;
            const numExhausts = 1 + ((hash >> 20) % 4);
            
            for (let i = 0; i < numExhausts; i++) {
                const zPos = (i - (numExhausts - 1) / 2) * 2;
                
                if (exhaustStyle === 0) {
                    const exGeo = new THREE.CylinderGeometry(0.6, 0.8, 2, 8);
                    const ex = new THREE.Mesh(exGeo, darkMat);
                    ex.rotation.z = Math.PI / 2;
                    ex.position.set(-21, 3, zPos);
                    group.add(ex);
                    
                    const glowGeo = new THREE.SphereGeometry(0.5, 6, 6);
                    const glow = new THREE.Mesh(glowGeo, glowMat);
                    glow.position.set(-22, 3, zPos);
                    group.add(glow);
                } else if (exhaustStyle === 1) {
                    const exGeo = new THREE.BoxGeometry(2, 1.5, 1.5);
                    const ex = new THREE.Mesh(exGeo, darkMat);
                    ex.position.set(-21, 3, zPos);
                    group.add(ex);
                } else {
                    const exGeo = new THREE.ConeGeometry(0.8, 3, 6);
                    const ex = new THREE.Mesh(exGeo, glowMat);
                    ex.rotation.z = -Math.PI / 2;
                    ex.position.set(-22, 3, zPos);
                    group.add(ex);
                }
            }
            
            // === PLAYER INDICATOR (common) ===
            const lightGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const playerLight = new THREE.Mesh(lightGeo, new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
            playerLight.position.set(bowLength, 8, 3);
            group.add(playerLight);
            
            const playerLight2 = new THREE.Mesh(lightGeo.clone(), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));
            playerLight2.position.set(bowLength, 8, -3);
            group.add(playerLight2);
            
            // Player glow ring
            const glowRingGeo = new THREE.TorusGeometry(18, 0.5, 8, 32);
            const glowRingMat = new THREE.MeshBasicMaterial({ color: glowColor, transparent: true, opacity: 0.4 });
            const glowRing = new THREE.Mesh(glowRingGeo, glowRingMat);
            glowRing.rotation.x = Math.PI / 2;
            glowRing.position.y = 1;
            group.add(glowRing);
            
            // Player spotlight
            const spotlight = new THREE.PointLight(glowColor, 1.5, 60);
            spotlight.position.set(0, 15, 0);
            group.add(spotlight);
            
            // Team flag
            const flagPoleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 6);
            const flagPole = new THREE.Mesh(flagPoleGeo, darkMat);
            flagPole.position.set(-18, 6, 0);
            group.add(flagPole);
            
            const flagGeo = new THREE.PlaneGeometry(4, 2.5);
            const flagMat = new THREE.MeshPhongMaterial({ color: team === 'red' ? 0xff3333 : 0x3366ff, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(-18, 8, 2);
            group.add(flag);
            
            return group;
        }

        function createWake(ship) {
            const wakeGroup = new THREE.Group();
            
            // Realistic bow wave with foam spray
            const bowWaveMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: 0.7 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float opacity;
                    varying vec2 vUv;
                    
                    float noise(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    void main() {
                        float n = noise(vUv * 20.0 + time);
                        float fade = 1.0 - vUv.x;
                        float edge = smoothstep(0.0, 0.2, vUv.y) * smoothstep(1.0, 0.8, vUv.y);
                        float foam = smoothstep(0.3, 0.7, n) * fade * edge;
                        vec3 color = mix(vec3(0.7, 0.85, 0.9), vec3(1.0), foam);
                        gl_FragColor = vec4(color, opacity * fade * edge);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            
            // V-shaped bow wake with spray
            for (let side = -1; side <= 1; side += 2) {
                for (let i = 0; i < 12; i++) {
                    const width = 2 + i * 1.2;
                    const length = 4 + i * 0.5;
                    const geometry = new THREE.PlaneGeometry(length, width, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xeeffff,
                        transparent: true,
                        opacity: Math.max(0.05, 0.5 - i * 0.035),
                        side: THREE.DoubleSide,
                        depthWrite: false
                    });
                    const wakePart = new THREE.Mesh(geometry, material);
                    wakePart.rotation.x = -Math.PI / 2;
                    wakePart.position.set(-18 - i * 5, 0.4, side * (3 + i * 2));
                    wakePart.rotation.z = side * (0.25 + i * 0.02);
                    wakeGroup.add(wakePart);
                }
            }
            
            // Stern turbulence with churning water
            for (let i = 0; i < 20; i++) {
                const size = 3 + i * 0.4;
                const geometry = new THREE.CircleGeometry(size, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: i < 5 ? 0xffffff : 0xd0e8f0,
                    transparent: true,
                    opacity: Math.max(0.02, 0.35 - i * 0.015),
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                const foam = new THREE.Mesh(geometry, material);
                foam.rotation.x = -Math.PI / 2;
                foam.position.set(-22 - i * 6, 0.3, (Math.random() - 0.5) * (4 + i * 0.5));
                wakeGroup.add(foam);
            }
            
            // Propeller wash bubbles
            for (let i = 0; i < 8; i++) {
                const geo = new THREE.SphereGeometry(1 + Math.random(), 8, 8);
                const mat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4 - i * 0.04
                });
                const bubble = new THREE.Mesh(geo, mat);
                bubble.position.set(-20 - i * 3, -0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 3);
                bubble.userData = { phase: Math.random() * Math.PI * 2 };
                wakeGroup.add(bubble);
            }

            return wakeGroup;
        }

        function createSmoke(x, y, z) {
            const particles = [];
            // Realistic billowing smoke with turbulence
            for (let i = 0; i < 8; i++) {
                const size = 1.0 + Math.random() * 1.5;
                const geometry = new THREE.SphereGeometry(size, 12, 12);
                
                // Varying smoke colors from dark to light gray
                const grayValue = 0.15 + Math.random() * 0.25;
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(grayValue, grayValue, grayValue),
                    transparent: true,
                    opacity: 0.6,
                    depthWrite: false
                });
                
                const particle = new THREE.Mesh(geometry, material);
                const angle = Math.random() * Math.PI * 2;
                const spread = Math.random() * 1.5;
                particle.position.set(
                    x + Math.cos(angle) * spread,
                    y + i * 1.5 + Math.random(),
                    z + Math.sin(angle) * spread
                );
                particle.userData = {
                    vx: (Math.random() - 0.5) * 0.15 + 0.08, // Wind drift
                    vy: 0.4 + Math.random() * 0.3,
                    vz: (Math.random() - 0.5) * 0.15,
                    life: 1,
                    turbulence: Math.random() * 0.1,
                    rotSpeed: (Math.random() - 0.5) * 0.02,
                    originalSize: size
                };
                scene.add(particle);
                particles.push(particle);
            }
            return particles;
        }

        class Ship {
            constructor(team, isPlayer = false, shipData = null) {
                this.team = team;
                this.isPlayer = isPlayer;
                this.shipData = shipData;
                this.health = 100;
                this.maxHealth = 100;
                this.speed = 0.30 + Math.random() * 0.15;
                this.turnSpeed = 0.025;
                this.fireRate = 90 + Math.random() * 60;
                this.fireCooldown = Math.random() * this.fireRate;
                this.velocity = { x: 0, z: 0 };
                this.rotation = 0;
                this.smokeTimer = 0;
                this.smokeParticles = [];
                this.recoilOffset = 0;
                this.accuracy = 0.05; // Default accuracy (can be overridden for AI)

                let color;
                if (team === 'red') {
                    color = 0x8B0000;
                    this.x = -WORLD_SIZE/2 + 30 + Math.random() * 60;
                    this.z = -WORLD_SIZE/2 + 50 + Math.random() * (WORLD_SIZE - 100);
                    this.rotation = 0;
                } else {
                    color = isPlayer ? 0x006644 : 0x000066;
                    this.x = WORLD_SIZE/2 - 30 - Math.random() * 60;
                    this.z = -WORLD_SIZE/2 + 50 + Math.random() * (WORLD_SIZE - 100);
                    this.rotation = Math.PI;
                }

                // Use category-specific design for player, standard for AI
                if (isPlayer && shipData) {
                    this.mesh = createShipByDesign(color, isPlayer, team, shipData);
                } else {
                    this.mesh = createDetailedShip(color, isPlayer, team);
                }
                this.mesh.scale.setScalar(2.0);
                this.mesh.position.set(this.x, 0, this.z);
                this.mesh.rotation.y = this.rotation;
                scene.add(this.mesh);

                this.wake = createWake(this);
                this.wake.scale.setScalar(2.0);
                scene.add(this.wake);

                this.targetZ = this.z;
                this.targetRotation = this.rotation;
                this.bobOffset = Math.random() * Math.PI * 2;

                // Health bar
                const healthBarBg = new THREE.Mesh(
                    new THREE.PlaneGeometry(12, 1.5),
                    new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide })
                );
                healthBarBg.position.y = 25;
                healthBarBg.rotation.y = Math.PI / 2;
                this.mesh.add(healthBarBg);

                const healthBar = new THREE.Mesh(
                    new THREE.PlaneGeometry(11.5, 1.2),
                    new THREE.MeshBasicMaterial({ color: 0x44ff44, side: THREE.DoubleSide })
                );
                healthBar.position.y = 25;
                healthBar.position.x = 0.1;
                healthBar.rotation.y = Math.PI / 2;
                this.healthBar = healthBar;
                this.mesh.add(healthBar);
            }

            // Calculate wave height at a given position (matching shader Gerstner waves)
            calculateWaveHeight(x, z, time, windDir) {
                const gerstnerWave = (px, pz, steepness, wavelength, dirX, dirY, phase) => {
                    const k = 6.28318 / wavelength;
                    const c = Math.sqrt(9.81 / k);
                    const len = Math.sqrt(dirX * dirX + dirY * dirY);
                    const dx = dirX / len, dy = dirY / len;
                    const f = k * (dx * px + dy * pz - c * time * 0.4 + phase);
                    const a = steepness / k;
                    return a * Math.sin(f);
                };
                
                let height = 0;
                height += gerstnerWave(x, z, 0.25, 120.0, windDir.x, windDir.y, 0.0);
                height += gerstnerWave(x, z, 0.18, 80.0, windDir.x * 1.05 + 0.1, windDir.y - 0.05, 0.8);
                height += gerstnerWave(x, z, 0.12, 50.0, -windDir.y * 0.9, windDir.x * 0.9, 1.6);
                height += gerstnerWave(x, z, 0.08, 28.0, windDir.x * 0.95 - 0.1, windDir.y + 0.15, 2.4);
                height += gerstnerWave(x, z, 0.06, 18.0, -windDir.x * 0.8, -windDir.y * 0.8, 3.2);
                
                return height;
            }

            update(delta) {
                if (this.isPlayer) {
                    this.updatePlayer(delta);
                } else {
                    this.updateAI(delta);
                }

                // Update smoke
                this.smokeTimer += delta;
                if (this.smokeTimer > 0.3 && this.speed > 0 && this.smokeParticles.length < MAX_SMOKE_PARTICLES) {
                    const worldPos = new THREE.Vector3(-6, 13, 0);
                    worldPos.applyMatrix4(this.mesh.matrixWorld);
                    this.smokeParticles.push(...createSmoke(worldPos.x, worldPos.y, worldPos.z));
                    this.smokeTimer = 0;
                }

                // Update smoke particles
                this.smokeParticles = this.smokeParticles.filter(p => {
                    p.position.x += p.userData.vx;
                    p.position.y += p.userData.vy;
                    p.position.z += p.userData.vz;
                    p.userData.life -= delta * 0.5;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.setScalar(1 + (1 - p.userData.life) * 2);
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });
                
                // Fire effects when damaged
                if (this.onFire) {
                    if (!this.fireParticles) this.fireParticles = [];
                    if (Math.random() > 0.7) {
                        const firePos = new THREE.Vector3(
                            (Math.random() - 0.5) * 15,
                            5 + Math.random() * 5,
                            (Math.random() - 0.5) * 4
                        );
                        firePos.applyMatrix4(this.mesh.matrixWorld);
                        
                        const fireGeo = new THREE.SphereGeometry(0.4 + Math.random() * 0.4, 6, 6);
                        const fireMat = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xff4400 : 0xff8800,
                            transparent: true,
                            opacity: 0.9
                        });
                        const fire = new THREE.Mesh(fireGeo, fireMat);
                        fire.position.copy(firePos);
                        fire.userData = { vy: 1 + Math.random() * 2, life: 0.6 + Math.random() * 0.4 };
                        scene.add(fire);
                        this.fireParticles.push(fire);
                    }
                    
                    // Update fire particles
                    this.fireParticles = this.fireParticles.filter(f => {
                        f.position.y += f.userData.vy * delta * 3;
                        f.userData.life -= delta * 2;
                        f.material.opacity = f.userData.life;
                        f.scale.multiplyScalar(0.98);
                        if (f.userData.life <= 0) {
                            disposeMesh(f);
                            return false;
                        }
                        return true;
                    });
                }

                // Update wake
                this.wake.position.copy(this.mesh.position);
                this.wake.rotation.y = this.mesh.rotation.y;

                // Ocean bobbing with realistic wave interaction
                this.bobOffset += delta * 2;
                const time = clock.getElapsedTime();
                
                // Calculate wave height at ship position (matching the shader's Gerstner waves)
                const windDir = { x: 0.7, y: 0.3 };
                const waveHeight = this.calculateWaveHeight(this.x, this.z, time, windDir);
                
                // Smooth transition to wave height
                this.currentWaveHeight = this.currentWaveHeight || 0;
                this.currentWaveHeight += (waveHeight - this.currentWaveHeight) * 0.1;
                
                // Calculate wave slope for realistic pitch and roll
                const sampleDist = 5;
                const heightFront = this.calculateWaveHeight(this.x + Math.cos(this.rotation) * sampleDist, 
                                                             this.z - Math.sin(this.rotation) * sampleDist, time, windDir);
                const heightBack = this.calculateWaveHeight(this.x - Math.cos(this.rotation) * sampleDist, 
                                                            this.z + Math.sin(this.rotation) * sampleDist, time, windDir);
                const heightLeft = this.calculateWaveHeight(this.x + Math.sin(this.rotation) * sampleDist, 
                                                            this.z + Math.cos(this.rotation) * sampleDist, time, windDir);
                const heightRight = this.calculateWaveHeight(this.x - Math.sin(this.rotation) * sampleDist, 
                                                             this.z - Math.cos(this.rotation) * sampleDist, time, windDir);
                
                const pitchAngle = Math.atan2(heightFront - heightBack, sampleDist * 2) * 0.5;
                let rollAngle = Math.atan2(heightRight - heightLeft, sampleDist * 2) * 0.5;
                
                // Add listing when critically damaged
                if (this.listing) {
                    rollAngle += this.listAngle;
                }

                // No turn heel - keep ships stable
                
                this.mesh.position.set(this.x, this.currentWaveHeight + 1, this.z);
                this.mesh.rotation.set(pitchAngle, this.rotation, rollAngle);
                
                // Scale wake based on speed
                const currentSpeed = Math.hypot(this.velocity?.x || 0, this.velocity?.z || 0);
                const wakeScale = 0.3 + currentSpeed * 1.5;
                this.wake.scale.set(wakeScale, 1, wakeScale);
                this.wake.visible = currentSpeed > 0.02;
            }

            updatePlayer(delta) {
                // Player ship - instant response controls (no momentum)
                const moveSpeed = 0.5 * this.speed;
                const turnSpeed = 0.03;

                // Movement - only when keys pressed
                let moving = false;
                if (keys['w'] || keys['arrowup']) {
                    this.x += Math.cos(this.rotation) * moveSpeed;
                    this.z -= Math.sin(this.rotation) * moveSpeed;
                    moving = true;
                }
                if (keys['s'] || keys['arrowdown']) {
                    this.x -= Math.cos(this.rotation) * moveSpeed * 0.5;
                    this.z += Math.sin(this.rotation) * moveSpeed * 0.5;
                    moving = true;
                }

                // Turning - instant response
                if (keys['q'] || keys['a'] || keys['arrowleft']) {
                    this.rotation += turnSpeed;
                }
                if (keys['e'] || keys['d'] || keys['arrowright']) {
                    this.rotation -= turnSpeed;
                }

                // Keep in bounds
                if (this.x < -WORLD_SIZE/2 + 20) { this.x = -WORLD_SIZE/2 + 20; }
                if (this.x > WORLD_SIZE/2 - 20) { this.x = WORLD_SIZE/2 - 20; }
                if (this.z < -WORLD_SIZE/2 + 20) { this.z = -WORLD_SIZE/2 + 20; }
                if (this.z > WORLD_SIZE/2 - 20) { this.z = WORLD_SIZE/2 - 20; }
                
                // Avoid islands
                for (const island of islands) {
                    const dx = this.x - island.x;
                    const dz = this.z - island.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < island.radius + 15) {
                        const pushAngle = Math.atan2(dz, dx);
                        this.x = island.x + Math.cos(pushAngle) * (island.radius + 16);
                        this.z = island.z + Math.sin(pushAngle) * (island.radius + 16);
                    }
                }

                // Manual fire with realistic reload
                this.fireCooldown -= delta * 60;
                if (keys[' '] && this.fireCooldown <= 0) {
                    this.fire();
                    this.fireCooldown = this.fireRate;
                }
            }

            updateAI(delta) {
                // Team member allies have advanced realistic AI
                if (this.isTeamMemberAlly && playerShip && playerShip.health > 0) {
                    this.updateTeamMemberAI(delta);
                    return;
                }
                
                // Find target
                const target = this.findTarget();
                
                if (target) {
                    // Calculate angle to target
                    const dx = target.x - this.x;
                    const dz = target.z - this.z;
                    const targetAngle = Math.atan2(-dz, dx);
                    
                    // Rotate towards target instantly
                    let angleDiff = targetAngle - this.rotation;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                    
                    const turnRate = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), this.turnSpeed);
                    this.rotation += turnRate;
                }

                // Move forward at speed (no momentum)
                const moveSpeed = this.speed * 0.8;
                this.x += Math.cos(this.rotation) * moveSpeed;
                this.z -= Math.sin(this.rotation) * moveSpeed;

                // Keep in bounds
                this.x = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.x));
                this.z = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.z));
                
                // Avoid islands
                for (const island of islands) {
                    const dx = this.x - island.x;
                    const dz = this.z - island.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < island.radius + 15) {
                        const pushAngle = Math.atan2(dz, dx);
                        this.x = island.x + Math.cos(pushAngle) * (island.radius + 16);
                        this.z = island.z + Math.sin(pushAngle) * (island.radius + 16);
                    }
                }

                // Fire
                this.fireCooldown -= delta * 60;
                if (this.fireCooldown <= 0 && target) {
                    const dist = Math.hypot(target.x - this.x, target.z - this.z);
                    if (dist < 150) {
                        this.fire();
                        this.fireCooldown = this.fireRate;
                    }
                }
            }
            
            // Realistic team member AI with formation flying and personality-based behavior
            updateTeamMemberAI(delta) {
                const personality = this.teamMember?.personality || 'balanced';
                const role = this.teamMember?.role || 'Support';
                
                // Formation positions relative to player (naval formation)
                const formationOffsets = [
                    { x: -40, z: -30 },  // Left flank
                    { x: 40, z: -30 },   // Right flank  
                    { x: 0, z: -50 }     // Rear guard
                ];
                
                const formationOffset = formationOffsets[this.formationIndex] || formationOffsets[0];
                
                // Calculate formation position based on player's heading
                const playerAngle = playerShip.rotation;
                const cos = Math.cos(-playerAngle);
                const sin = Math.sin(-playerAngle);
                const formationX = playerShip.x + (formationOffset.x * cos - formationOffset.z * sin);
                const formationZ = playerShip.z + (formationOffset.x * sin + formationOffset.z * cos);
                
                // Find nearest enemy threat
                const target = this.findTarget();
                const distToFormation = Math.hypot(formationX - this.x, formationZ - this.z);
                
                // Decision making based on personality and situation
                let targetX, targetZ, shouldEngage = false;
                
                if (target) {
                    const distToEnemy = Math.hypot(target.x - this.x, target.z - this.z);
                    const enemyDistToPlayer = Math.hypot(target.x - playerShip.x, target.z - playerShip.z);
                    
                    // Health-based retreat behavior (realistic damage response)
                    const healthPercent = this.health / this.maxHealth;
                    if (healthPercent < 0.25) {
                        // Critically damaged - retreat behind player
                        targetX = playerShip.x - Math.cos(playerAngle) * 60;
                        targetZ = playerShip.z + Math.sin(playerAngle) * 60;
                        shouldEngage = false;
                    } else if (personality === 'aggressive') {
                        // Aggressive: Prioritize attacking, break formation to engage
                        if (distToEnemy < 120 || enemyDistToPlayer < 80) {
                            targetX = target.x;
                            targetZ = target.z;
                            shouldEngage = true;
                        } else {
                            targetX = formationX;
                            targetZ = formationZ;
                            shouldEngage = distToEnemy < 100;
                        }
                    } else if (personality === 'cautious') {
                        // Cautious: Maintain distance, provide covering fire
                        if (enemyDistToPlayer < 60) {
                            // Enemy too close to player - intercept
                            targetX = (target.x + playerShip.x) / 2;
                            targetZ = (target.z + playerShip.z) / 2;
                            shouldEngage = true;
                        } else {
                            // Stay in formation, engage only at range
                            targetX = formationX;
                            targetZ = formationZ;
                            shouldEngage = distToEnemy < 130 && distToEnemy > 60;
                        }
                    } else {
                        // Balanced: Adaptive behavior
                        if (role === 'Flanker' && distToEnemy < 100) {
                            // Flanking maneuver - approach from the side
                            const flankAngle = Math.atan2(target.z - this.z, target.x - this.x) + Math.PI / 3;
                            targetX = target.x + Math.cos(flankAngle) * 50;
                            targetZ = target.z + Math.sin(flankAngle) * 50;
                            shouldEngage = true;
                        } else if (role === 'Scout') {
                            // Scout ahead but return to formation
                            if (distToFormation > 80) {
                                targetX = formationX;
                                targetZ = formationZ;
                            } else {
                                targetX = formationX + Math.cos(playerAngle) * 30;
                                targetZ = formationZ - Math.sin(playerAngle) * 30;
                            }
                            shouldEngage = distToEnemy < 110;
                        } else {
                            targetX = formationX;
                            targetZ = formationZ;
                            shouldEngage = distToEnemy < 120;
                        }
                    }
                } else {
                    // No enemies - return to formation
                    targetX = formationX;
                    targetZ = formationZ;
                }
                
                // Collision avoidance with other friendly ships
                for (const other of ships) {
                    if (other !== this && other.team === this.team && other.health > 0) {
                        const dist = Math.hypot(other.x - this.x, other.z - this.z);
                        if (dist < 25) {
                            // Push away from nearby friendly
                            const pushAngle = Math.atan2(this.z - other.z, this.x - other.x);
                            targetX += Math.cos(pushAngle) * (25 - dist) * 0.5;
                            targetZ += Math.sin(pushAngle) * (25 - dist) * 0.5;
                        }
                    }
                }
                
                // Navigate to target position with realistic turning
                const dx = targetX - this.x;
                const dz = targetZ - this.z;
                const targetAngle = Math.atan2(-dz, dx);
                
                let angleDiff = targetAngle - this.rotation;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // Realistic turn rate (larger ships turn slower)
                const turnRate = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), this.turnSpeed * 0.8);
                this.rotation += turnRate;
                
                // Move forward with speed variation based on situation
                let speedMult = 0.8;
                if (distToFormation > 60) speedMult = 1.0; // Catch up to formation
                if (shouldEngage && target) speedMult = 0.9; // Slightly slower when engaging
                
                const moveSpeed = this.speed * speedMult;
                this.x += Math.cos(this.rotation) * moveSpeed;
                this.z -= Math.sin(this.rotation) * moveSpeed;
                
                // Keep in bounds
                this.x = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.x));
                this.z = Math.max(-WORLD_SIZE/2 + 20, Math.min(WORLD_SIZE/2 - 20, this.z));
                
                // Avoid islands
                for (const island of islands) {
                    const dx = this.x - island.x;
                    const dz = this.z - island.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    if (dist < island.radius + 15) {
                        const pushAngle = Math.atan2(dz, dx);
                        this.x = island.x + Math.cos(pushAngle) * (island.radius + 16);
                        this.z = island.z + Math.sin(pushAngle) * (island.radius + 16);
                    }
                }
                
                // Firing with lead prediction (realistic aiming)
                this.fireCooldown -= delta * 60;
                if (this.fireCooldown <= 0 && target && shouldEngage) {
                    const distToTarget = Math.hypot(target.x - this.x, target.z - this.z);
                    if (distToTarget < 150) {
                        // Check if target is roughly in front (don't fire backwards)
                        const angleToTarget = Math.atan2(-(target.z - this.z), target.x - this.x);
                        let aimDiff = angleToTarget - this.rotation;
                        while (aimDiff > Math.PI) aimDiff -= Math.PI * 2;
                        while (aimDiff < -Math.PI) aimDiff += Math.PI * 2;
                        
                        if (Math.abs(aimDiff) < Math.PI / 3) { // 60 degree firing arc
                            this.fire();
                            this.fireCooldown = this.fireRate;
                        }
                    }
                }
            }

            fire() {
                // Fire straight forward based on ship rotation
                const angle = -this.rotation;
                
                // Fire from center barrel
                const gunPos = new THREE.Vector3(33, 9.5, 0);
                gunPos.applyMatrix4(this.mesh.matrixWorld);
                
                const damage = 25 * (this.damageMultiplier || 1);
                bullets.push(new Bullet(gunPos.x, gunPos.z, angle, this.team, this.accuracy, damage));
                if (this.isPlayer) updateQuestProgress('shotsFired', 1);
                this.createMuzzleFlash(gunPos);
                this.createMuzzleSmoke(gunPos);
            }

            createMuzzleFlash(pos) {
                // Bright initial flash
                const flashGeometry = new THREE.SphereGeometry(3, 8, 8);
                const flashMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff44,
                    transparent: true,
                    opacity: 1
                });
                const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                flash.position.set(pos.x, pos.y, pos.z);
                scene.add(flash);
                
                // Outer fireball
                const fireballGeo = new THREE.SphereGeometry(5, 8, 8);
                const fireballMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.8
                });
                const fireball = new THREE.Mesh(fireballGeo, fireballMat);
                fireball.position.set(pos.x, pos.y, pos.z);
                scene.add(fireball);
                
                // Animate flash
                let flashLife = 1.0;
                const animateFlash = () => {
                    flashLife -= 0.15;
                    flash.scale.setScalar(1 + (1 - flashLife) * 2);
                    flash.material.opacity = flashLife;
                    fireball.scale.setScalar(1 + (1 - flashLife) * 3);
                    fireball.material.opacity = flashLife * 0.6;
                    if (flashLife > 0) {
                        requestAnimationFrame(animateFlash);
                    } else {
                        disposeMesh(flash);
                        disposeMesh(fireball);
                    }
                };
                animateFlash();
            }
            
            createMuzzleSmoke(pos) {
                // Smoke ring expanding outward
                for (let i = 0; i < 12; i++) {
                    const smokeGeo = new THREE.SphereGeometry(1 + Math.random(), 6, 6);
                    const smokeMat = new THREE.MeshBasicMaterial({
                        color: 0x666666,
                        transparent: true,
                        opacity: 0.6
                    });
                    const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                    smoke.position.set(pos.x, pos.y, pos.z);
                    
                    const spreadAngle = Math.random() * Math.PI * 2;
                    const spreadSpeed = 0.3 + Math.random() * 0.4;
                    smoke.userData = {
                        vx: Math.cos(spreadAngle) * spreadSpeed + Math.cos(-this.rotation) * 0.5,
                        vy: 0.2 + Math.random() * 0.3,
                        vz: Math.sin(spreadAngle) * spreadSpeed + Math.sin(-this.rotation) * 0.5,
                        life: 1.5 + Math.random() * 0.5
                    };
                    scene.add(smoke);
                    
                    const animateSmoke = () => {
                        smoke.userData.life -= 0.02;
                        smoke.userData.vy *= 0.98;
                        smoke.position.x += smoke.userData.vx;
                        smoke.position.y += smoke.userData.vy;
                        smoke.position.z += smoke.userData.vz;
                        smoke.userData.vx *= 0.96;
                        smoke.userData.vz *= 0.96;
                        smoke.scale.multiplyScalar(1.03);
                        smoke.material.opacity = smoke.userData.life * 0.4;
                        if (smoke.userData.life > 0) {
                            requestAnimationFrame(animateSmoke);
                        } else {
                            disposeMesh(smoke);
                        }
                    };
                    animateSmoke();
                }
            }

            findTarget() {
                let closest = null;
                let closestDist = Infinity;
                for (const ship of ships) {
                    if (ship.team !== this.team && ship.health > 0) {
                        const dist = Math.hypot(ship.x - this.x, ship.z - this.z);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closest = ship;
                        }
                    }
                }
                return closest;
            }

            takeDamage(amount) {
                this.health -= amount;
                const healthPercent = Math.max(0, this.health / this.maxHealth);
                this.healthBar.scale.x = healthPercent;
                this.healthBar.position.z = -5.75 * (1 - healthPercent);
                
                // Color changes based on damage
                if (this.health > 60) {
                    this.healthBar.material.color.setHex(0x44ff44);
                } else if (this.health > 30) {
                    this.healthBar.material.color.setHex(0xffaa00);
                } else {
                    this.healthBar.material.color.setHex(0xff4444);
                }
                
                // Start fires when heavily damaged
                if (this.health < 50 && !this.onFire) {
                    this.onFire = true;
                    this.fireParticles = [];
                }
                
                // Ship listing when critically damaged
                if (this.health < 30 && !this.listing) {
                    this.listing = true;
                    this.listAngle = (Math.random() > 0.5 ? 1 : -1) * 0.15;
                }

                if (this.health <= 0) {
                    explosions.push(new Explosion(this.x, this.z));
                    scene.remove(this.mesh);
                    scene.remove(this.wake);
                    for (const p of this.smokeParticles) {
                        scene.remove(p);
                    }
                    if (this.fireParticles) {
                        for (const p of this.fireParticles) {
                            scene.remove(p);
                        }
                    }
                    if (this.team === 'red') {
                        blueScore++;
                        document.getElementById('blueScore').textContent = blueScore;
                    } else {
                        redScore++;
                        document.getElementById('redScore').textContent = redScore;
                    }
                }
            }
        }

        class Bullet {
            constructor(x, z, angle, team, accuracy = 0.05, damage = 25) {
                this.x = x;
                this.z = z;
                this.y = 8;
                this.team = team;
                this.damage = damage;
                
                // Realistic ballistics with accuracy spread (lower = more accurate)
                const spread = (Math.random() - 0.5) * accuracy;
                this.angle = angle + spread;
                
                // Shell velocity components (realistic arc)
                const muzzleVelocity = 2.5;
                const elevationAngle = 0.15 + Math.random() * 0.05; // Gun elevation
                this.speed = muzzleVelocity * Math.cos(elevationAngle);
                this.vy = muzzleVelocity * Math.sin(elevationAngle) * 8;
                this.gravity = -0.12;
                
                // Wind effect
                this.windX = (Math.random() - 0.5) * 0.02;
                this.windZ = (Math.random() - 0.5) * 0.02;
                
                // Air resistance
                this.dragCoeff = 0.998;

                // Shell mesh - large naval artillery shell
                const geometry = new THREE.CylinderGeometry(0.8, 0.8, 5.0, 12);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x554433,
                    emissive: team === 'red' ? 0xff2200 : 0x0033ff,
                    emissiveIntensity: 0.5,
                    shininess: 80
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.rotation.z = Math.PI / 2;
                this.mesh.rotation.y = -this.angle;
                this.mesh.position.set(x, this.y, z);
                scene.add(this.mesh);

                // Smoke trail
                this.trailParticles = [];
                this.trailTimer = 0;
            }

            update(delta) {
                // Add trail particles
                this.trailTimer += delta;
                if (this.trailTimer > 0.03 && this.y > 2 && this.trailParticles.length < MAX_TRAIL_PARTICLES) {
                    const trailGeo = new THREE.SphereGeometry(0.15, 4, 4);
                    const trailMat = new THREE.MeshBasicMaterial({
                        color: 0x888888,
                        transparent: true,
                        opacity: 0.4
                    });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.position.set(this.x, this.y, this.z);
                    trail.userData = { life: 1.0 };
                    scene.add(trail);
                    this.trailParticles.push(trail);
                    this.trailTimer = 0;
                }
                
                // Fade trail particles
                this.trailParticles = this.trailParticles.filter(p => {
                    p.userData.life -= delta * 2;
                    p.material.opacity = p.userData.life * 0.4;
                    p.scale.multiplyScalar(1.02);
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });

                // Physics with air resistance and wind
                this.vy += this.gravity;
                this.speed *= this.dragCoeff;
                
                this.y += this.vy;
                this.x += Math.cos(this.angle) * this.speed + this.windX;
                this.z += Math.sin(this.angle) * this.speed + this.windZ;

                // Update shell orientation to follow trajectory
                const velocityAngle = Math.atan2(this.vy, this.speed);
                this.mesh.rotation.x = velocityAngle;
                this.mesh.position.set(this.x, Math.max(0.5, this.y), this.z);

                // Hit water - create realistic splash
                if (this.y < 0) {
                    this.createSplash();
                    this.hit = true;
                }
            }

            createSplash() {
                // Water column
                const columnGeo = new THREE.CylinderGeometry(0.5, 2, 8, 8);
                const columnMat = new THREE.MeshBasicMaterial({
                    color: 0xaaddff,
                    transparent: true,
                    opacity: 0.7
                });
                const column = new THREE.Mesh(columnGeo, columnMat);
                column.position.set(this.x, 4, this.z);
                scene.add(column);
                
                // Animate water column
                let columnLife = 1.0;
                const animateColumn = () => {
                    columnLife -= 0.03;
                    column.scale.y = 1 + (1 - columnLife) * 2;
                    column.position.y = 4 + (1 - columnLife) * 4;
                    column.material.opacity = columnLife * 0.7;
                    if (columnLife > 0) {
                        requestAnimationFrame(animateColumn);
                    } else {
                        disposeMesh(column);
                    }
                };
                animateColumn();
                
                // Spray particles (reduced count)
                for (let i = 0; i < 8; i++) {
                    const geometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.4, 4, 4);
                    const material = new THREE.MeshBasicMaterial({
                        color: 0xcceeFF,
                        transparent: true,
                        opacity: 0.8
                    });
                    const splash = new THREE.Mesh(geometry, material);
                    splash.position.set(this.x, 0.5, this.z);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    splash.userData = {
                        vx: Math.cos(angle) * speed,
                        vy: 2 + Math.random() * 4,
                        vz: Math.sin(angle) * speed,
                        life: 1
                    };
                    scene.add(splash);
                    
                    const animateSplash = () => {
                        splash.position.x += splash.userData.vx * 0.1;
                        splash.position.y += splash.userData.vy * 0.1;
                        splash.position.z += splash.userData.vz * 0.1;
                        splash.userData.vy -= 0.2;
                        splash.userData.life -= 0.025;
                        splash.material.opacity = splash.userData.life * 0.8;
                        
                        if (splash.userData.life > 0 && splash.position.y > 0) {
                            requestAnimationFrame(animateSplash);
                        } else {
                            disposeMesh(splash);
                        }
                    };
                    animateSplash();
                }
                
                // Ripple ring
                const ringGeo = new THREE.RingGeometry(1, 2, 32);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(this.x, 0.2, this.z);
                scene.add(ring);
                
                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.3;
                    ring.scale.set(ringScale, ringScale, 1);
                    ring.material.opacity -= 0.02;
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        disposeMesh(ring);
                    }
                };
                animateRing();
            }

            isOffScreen() {
                return Math.abs(this.x) > WORLD_SIZE || Math.abs(this.z) > WORLD_SIZE || this.y < -10;
            }

            remove() {
                disposeMesh(this.mesh);
                for (const p of this.trailParticles) {
                    disposeMesh(p);
                }
            }
        }

        // Global screen shake
        let screenShakeIntensity = 0;
        let screenShakeDecay = 0.92;
        
        function triggerScreenShake(intensity) {
            screenShakeIntensity = Math.max(screenShakeIntensity, intensity);
        }
        
        class Explosion {
            constructor(x, z) {
                this.particles = [];
                this.fires = [];
                this.shockwaves = [];
                this.x = x;
                this.z = z;
                
                // Trigger screen shake based on distance from player
                if (playerShip) {
                    const distToPlayer = Math.hypot(x - playerShip.x, z - playerShip.z);
                    const shakeIntensity = Math.max(0, 8 - distToPlayer / 30);
                    triggerScreenShake(shakeIntensity);
                }
                
                // Multiple dynamic lights for realistic illumination
                const primaryLight = new THREE.PointLight(0xffaa33, 15, 200);
                primaryLight.position.set(x, 20, z);
                scene.add(primaryLight);
                
                const secondaryLight = new THREE.PointLight(0xff6600, 8, 100);
                secondaryLight.position.set(x, 10, z);
                scene.add(secondaryLight);
                
                // Animate lights
                let lightLife = 1.0;
                const fadeLight = () => {
                    lightLife -= 0.03;
                    primaryLight.intensity = 15 * Math.pow(lightLife, 2);
                    secondaryLight.intensity = 8 * lightLife;
                    if (lightLife > 0) {
                        requestAnimationFrame(fadeLight);
                    } else {
                        scene.remove(primaryLight);
                        scene.remove(secondaryLight);
                    }
                };
                fadeLight();
                
                // Multi-stage blast (inner hot core, outer fireball)
                // Inner white-hot core
                const coreGeo = new THREE.SphereGeometry(3, 16, 16);
                const coreMat = new THREE.MeshBasicMaterial({
                    color: 0xffffee,
                    transparent: true,
                    opacity: 1.0
                });
                const core = new THREE.Mesh(coreGeo, coreMat);
                core.position.set(x, 10, z);
                scene.add(core);
                this.particles.push(core);
                core.userData = { life: 1, isCore: true, expandRate: 2.5 };
                
                // Orange fireball layer
                const fireballGeo = new THREE.SphereGeometry(6, 20, 20);
                const fireballMat = new THREE.MeshBasicMaterial({
                    color: 0xff6600,
                    transparent: true,
                    opacity: 0.85
                });
                const fireball = new THREE.Mesh(fireballGeo, fireballMat);
                fireball.position.set(x, 10, z);
                scene.add(fireball);
                this.particles.push(fireball);
                fireball.userData = { life: 1, isBlast: true, expandRate: 1.8 };
                
                // Outer red layer
                const outerGeo = new THREE.SphereGeometry(8, 16, 16);
                const outerMat = new THREE.MeshBasicMaterial({
                    color: 0xcc3300,
                    transparent: true,
                    opacity: 0.6
                });
                const outer = new THREE.Mesh(outerGeo, outerMat);
                outer.position.set(x, 10, z);
                scene.add(outer);
                this.particles.push(outer);
                outer.userData = { life: 1, isBlast: true, expandRate: 1.5 };
                
                // Volumetric fire particles
                for (let i = 0; i < 35; i++) {
                    const size = 1.0 + Math.random() * 2.5;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const isDebris = Math.random() > 0.7;
                    
                    let color;
                    if (isDebris) {
                        const gray = 0.1 + Math.random() * 0.2;
                        color = new THREE.Color(gray, gray, gray);
                    } else {
                        // Fire gradient from white to red
                        const t = Math.random();
                        if (t < 0.2) color = new THREE.Color(1.0, 1.0, 0.9);
                        else if (t < 0.4) color = new THREE.Color(1.0, 0.9, 0.4);
                        else if (t < 0.6) color = new THREE.Color(1.0, 0.6, 0.1);
                        else if (t < 0.8) color = new THREE.Color(1.0, 0.3, 0.0);
                        else color = new THREE.Color(0.8, 0.1, 0.0);
                    }
                    
                    const material = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 1
                    });
                    
                    const particle = new THREE.Mesh(geometry, material);
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = Math.random() * Math.PI * 0.5;
                    const speed = 3 + Math.random() * 8;
                    
                    particle.position.set(
                        x + Math.cos(angle) * Math.random() * 4,
                        8 + Math.random() * 6,
                        z + Math.sin(angle) * Math.random() * 4
                    );
                    particle.userData = {
                        vx: Math.cos(angle) * Math.cos(elevation) * speed,
                        vy: Math.sin(elevation) * speed + 2,
                        vz: Math.sin(angle) * Math.cos(elevation) * speed,
                        life: 0.7 + Math.random() * 0.5,
                        rotSpeed: (Math.random() - 0.5) * 0.5,
                        isDebris: isDebris,
                        drag: 0.96 + Math.random() * 0.03,
                        originalSize: size
                    };
                    scene.add(particle);
                    this.particles.push(particle);
                }
                
                // Flying debris (metal shards)
                for (let i = 0; i < 12; i++) {
                    const geo = new THREE.BoxGeometry(
                        0.3 + Math.random() * 0.5,
                        0.1 + Math.random() * 0.2,
                        0.5 + Math.random() * 1.0
                    );
                    const mat = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        shininess: 60
                    });
                    const debris = new THREE.Mesh(geo, mat);
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 8 + Math.random() * 15;
                    debris.position.set(x, 8 + Math.random() * 5, z);
                    debris.userData = {
                        vx: Math.cos(angle) * speed,
                        vy: 5 + Math.random() * 10,
                        vz: Math.sin(angle) * speed,
                        life: 2,
                        rotX: (Math.random() - 0.5) * 0.3,
                        rotY: (Math.random() - 0.5) * 0.3,
                        rotZ: (Math.random() - 0.5) * 0.3,
                        isDebris: true,
                        isMetal: true,
                        drag: 0.99
                    };
                    scene.add(debris);
                    this.particles.push(debris);
                }

                // Smoke column
                this.smokeTimer = 0;
                this.smokeDuration = 4;
                this.smokeActive = true;
                
                // Secondary explosions with delays
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        if (!this.smokeActive) return;
                        const secX = x + (Math.random() - 0.5) * 20;
                        const secZ = z + (Math.random() - 0.5) * 20;
                        
                        // Secondary fireball
                        const secGeo = new THREE.SphereGeometry(4, 12, 12);
                        const secMat = new THREE.MeshBasicMaterial({
                            color: 0xff8844,
                            transparent: true,
                            opacity: 0.9
                        });
                        const secondary = new THREE.Mesh(secGeo, secMat);
                        secondary.position.set(secX, 6 + Math.random() * 6, secZ);
                        secondary.userData = { life: 0.6, isBlast: true, expandRate: 1.3 };
                        scene.add(secondary);
                        this.particles.push(secondary);
                        
                        // Secondary light flash
                        const secLight = new THREE.PointLight(0xff6600, 8, 60);
                        secLight.position.set(secX, 10, secZ);
                        scene.add(secLight);
                        setTimeout(() => scene.remove(secLight), 200);
                    }, 150 + i * 250 + Math.random() * 150);
                }
                
                // Persistent fires
                for (let i = 0; i < 6; i++) {
                    const fireX = x + (Math.random() - 0.5) * 12;
                    const fireZ = z + (Math.random() - 0.5) * 12;
                    this.fires.push({ x: fireX, z: fireZ, life: 2.5 + Math.random() * 2.5 });
                }

                // Shockwave ring
                const ringGeo = new THREE.RingGeometry(3, 5, 48);
                const ringMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeo, ringMat);
                ring.rotation.x = -Math.PI / 2;
                ring.position.set(x, 0.5, z);
                scene.add(ring);
                
                let ringScale = 1;
                const animateRing = () => {
                    ringScale += 0.8;
                    ring.scale.set(ringScale, ringScale, 1);
                    ring.material.opacity -= 0.02;
                    if (ring.material.opacity > 0) {
                        requestAnimationFrame(animateRing);
                    } else {
                        disposeMesh(ring);
                    }
                };
                animateRing();
                
                // Water splash column
                for (let i = 0; i < 15; i++) {
                    const splashGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.8, 8, 8);
                    const splashMat = new THREE.MeshBasicMaterial({
                        color: 0xaaccdd,
                        transparent: true,
                        opacity: 0.7
                    });
                    const splash = new THREE.Mesh(splashGeo, splashMat);
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 3 + Math.random() * 8;
                    splash.position.set(x + Math.cos(angle) * dist, 1, z + Math.sin(angle) * dist);
                    splash.userData = {
                        vx: Math.cos(angle) * 2,
                        vy: 8 + Math.random() * 12,
                        vz: Math.sin(angle) * 2,
                        life: 1,
                        drag: 0.98,
                        isSplash: true
                    };
                    scene.add(splash);
                    this.particles.push(splash);
                }
            }

            update(delta) {
                // Update all particles
                for (const p of this.particles) {
                    if (p.userData.isCore) {
                        // White hot core expands and fades quickly
                        p.scale.multiplyScalar(1 + p.userData.expandRate * delta);
                        p.userData.life -= delta * 4;
                        p.material.opacity = Math.max(0, p.userData.life);
                    } else if (p.userData.isBlast) {
                        // Fireball expansion
                        const expand = 1 + (p.userData.expandRate || 1.5) * delta;
                        p.scale.multiplyScalar(expand);
                        p.userData.life -= delta * 2.5;
                        p.material.opacity = Math.max(0, p.userData.life * 0.9);
                    } else if (p.userData.vx !== undefined) {
                        // Physics-based particles
                        p.position.x += p.userData.vx * delta * 6;
                        p.position.y += p.userData.vy * delta * 6;
                        p.position.z += p.userData.vz * delta * 6;
                        
                        // Gravity
                        p.userData.vy -= delta * 18;
                        
                        // Drag
                        p.userData.vx *= p.userData.drag;
                        p.userData.vz *= p.userData.drag;
                        
                        // Rotation
                        if (p.userData.isMetal) {
                            p.rotation.x += p.userData.rotX;
                            p.rotation.y += p.userData.rotY;
                            p.rotation.z += p.userData.rotZ;
                        } else if (p.userData.rotSpeed) {
                            p.rotation.x += p.userData.rotSpeed;
                            p.rotation.y += p.userData.rotSpeed * 0.7;
                        }
                        
                        // Fade
                        const fadeRate = p.userData.isDebris ? 0.3 : (p.userData.isSplash ? 1.5 : 1.0);
                        p.userData.life -= delta * fadeRate;
                        if (p.material.opacity !== undefined) {
                            p.material.opacity = Math.max(0, p.userData.life);
                        }
                        
                        // Water collision
                        if (p.position.y < 0.5 && !p.userData.hitWater) {
                            p.userData.hitWater = true;
                            p.userData.vy *= -0.3;
                            p.userData.vx *= 0.3;
                            p.userData.vz *= 0.3;
                            p.position.y = 0.5;
                            
                            // Water splash effect for debris
                            if (p.userData.isDebris && !p.userData.isSplash) {
                                p.userData.life = Math.min(p.userData.life, 0.5);
                            }
                        }
                        
                        // Fire particles shrink
                        if (!p.userData.isDebris && !p.userData.isSplash && p.userData.life < 0.5) {
                            p.scale.multiplyScalar(0.97);
                        }
                    } else {
                        // Rising smoke
                        p.position.y += (p.userData.vy || 1) * delta;
                        if (p.userData.vy) p.userData.vy *= 0.99;
                        p.scale.multiplyScalar(1.008);
                        p.userData.life -= delta * 0.25;
                        p.material.opacity = Math.max(0, p.userData.life * 0.5);
                    }
                }
                
                // Generate smoke column
                this.smokeTimer += delta;
                if (this.smokeActive && this.smokeDuration > 0 && this.particles.length < MAX_EXPLOSION_PARTICLES) {
                    this.smokeDuration -= delta;
                    if (this.smokeTimer > 0.08) {
                        const size = 2.5 + Math.random() * 3;
                        const smokeGeo = new THREE.SphereGeometry(size, 8, 8);
                        const gray = 0.08 + Math.random() * 0.15;
                        const smokeMat = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(gray, gray, gray),
                            transparent: true,
                            opacity: 0.6,
                            depthWrite: false
                        });
                        const smoke = new THREE.Mesh(smokeGeo, smokeMat);
                        smoke.position.set(
                            this.x + (Math.random() - 0.5) * 10,
                            6 + Math.random() * 12,
                            this.z + (Math.random() - 0.5) * 10
                        );
                        smoke.userData = {
                            vy: 2 + Math.random() * 2,
                            life: 1
                        };
                        scene.add(smoke);
                        this.particles.push(smoke);
                        this.smokeTimer = 0;
                    }
                }
                
                // Cleanup dead particles
                this.particles = this.particles.filter(p => {
                    if (p.userData.life <= 0) {
                        disposeMesh(p);
                        return false;
                    }
                    return true;
                });
                
                // Update fires (create fire particles - with limit)
                for (const fire of this.fires) {
                    fire.life -= delta;
                    if (fire.life > 0 && Math.random() > 0.8 && this.particles.length < MAX_EXPLOSION_PARTICLES) {
                        const flameGeo = new THREE.SphereGeometry(0.5 + Math.random() * 0.5, 4, 4);
                        const flameMat = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0xff4400 : 0xff8800,
                            transparent: true,
                            opacity: 0.8
                        });
                        const flame = new THREE.Mesh(flameGeo, flameMat);
                        flame.position.set(
                            fire.x + (Math.random() - 0.5) * 2,
                            0.5 + Math.random() * 2,
                            fire.z + (Math.random() - 0.5) * 2
                        );
                        flame.userData = { vy: 2 + Math.random() * 2, life: 0.5 };
                        scene.add(flame);
                        this.particles.push(flame);
                    }
                }
            }

            isDone() {
                return this.particles.every(p => p.userData.life <= 0) && this.fires.every(f => f.life <= 0);
            }

            remove() {
                this.smokeActive = false;
                for (const p of this.particles) {
                    disposeMesh(p);
                }
                this.particles = [];
            }
        }

        function spawnShips() {
            // Difficulty settings: 5v5 for all, harder = better AI (faster fire, speed, accuracy)
            const difficultySettings = {
                1: { enemies: 5, allies: 4, fireRateMult: 1.5, speedMult: 0.7, accuracy: 0.08, playerHealth: 150 },  // Easy
                2: { enemies: 5, allies: 4, fireRateMult: 1.2, speedMult: 0.85, accuracy: 0.06, playerHealth: 120 },  // Medium
                3: { enemies: 5, allies: 4, fireRateMult: 1.0, speedMult: 1.0, accuracy: 0.04, playerHealth: 100 },  // Hard
                4: { enemies: 5, allies: 4, fireRateMult: 0.7, speedMult: 1.2, accuracy: 0.025, playerHealth: 80 },  // Extreme
                5: { enemies: 5, allies: 4, fireRateMult: 0.5, speedMult: 1.4, accuracy: 0.015, playerHealth: 60 }   // Nightmare
            };
            
            const settings = difficultySettings[difficulty];
            
            // Spawn enemy ships
            for (let i = 0; i < settings.enemies; i++) {
                const ship = new Ship('red');
                ship.fireRate *= settings.fireRateMult;
                ship.speed *= settings.speedMult;
                ship.accuracy = settings.accuracy;
                ships.push(ship);
            }
            
            // Spawn ally ships using team member assignments with realistic behavior
            // First ally is always a generic one, then 3 team members
            ships.push(new Ship('blue'));
            
            for (let i = 0; i < Math.min(teamMembers.length, settings.allies - 1); i++) {
                const member = teamMembers[i];
                const memberShipStats = getTeamMemberShipStats(member.id);
                
                // Create ally with specific ship stats
                const ally = new Ship('blue', false, memberShipStats);
                
                // Apply ship stats to ally
                const allyBaseHealth = 100 * (memberShipStats.health / 100);
                ally.health = allyBaseHealth;
                ally.maxHealth = allyBaseHealth;
                ally.speed *= memberShipStats.speed;
                ally.fireRate /= memberShipStats.fireRate;
                ally.damageMultiplier = memberShipStats.damage;
                ally.accuracy = 0.05 / memberShipStats.accuracy;
                
                // Store team member info for AI behavior
                ally.teamMember = member;
                ally.isTeamMemberAlly = true;
                ally.formationIndex = i; // Position in formation around player
                
                ships.push(ally);
            }
            
            // Apply selected ship stats to player
            const shipStats = getSelectedShipStats();
            playerShip = new Ship('blue', true, shipStats);
            const baseHealth = settings.playerHealth * (shipStats.health / 100);
            playerShip.health = baseHealth;
            playerShip.maxHealth = baseHealth;
            playerShip.speed *= shipStats.speed;
            playerShip.fireRate /= shipStats.fireRate; // Lower = faster
            playerShip.damageMultiplier = shipStats.damage;
            playerShip.accuracy = 0.05 / shipStats.accuracy; // Lower = more accurate
            ships.push(playerShip);
        }

        function checkCollisions() {
            // Bullet-ship collisions
            for (const bullet of bullets) {
                if (bullet.hit) continue;
                for (const ship of ships) {
                    if (bullet.team !== ship.team && ship.health > 0) {
                        const dist = Math.hypot(bullet.x - ship.x, bullet.z - ship.z);
                        if (dist < 12 && bullet.y < 15 && bullet.y > 0) {
                            const wasAlive = ship.health > 0;
                            ship.takeDamage(bullet.damage);
                            bullet.hit = true;
                            
                            // Track quest progress for player hits
                            if (bullet.team === 'blue' && playerShip) {
                                updateQuestProgress('shotsHit', 1);
                                updateQuestProgress('damageDealt', Math.round(bullet.damage));
                                if (wasAlive && ship.health <= 0) {
                                    updateQuestProgress('kills', 1);
                                }
                            }
                            
                            // Hit effect
                            const hitFlash = new THREE.PointLight(0xffaa00, 3, 30);
                            hitFlash.position.set(bullet.x, bullet.y, bullet.z);
                            scene.add(hitFlash);
                            setTimeout(() => scene.remove(hitFlash), 100);
                        }
                    }
                }
            }
            
            // Ship-ship collisions disabled - ships can pass through each other
        }

        let gameOver = false;
        let winner = null;

        function checkGameOver() {
            if (gameOver) return;
            
            const redAlive = ships.filter(s => s.team === 'red' && s.health > 0).length;
            const blueAlive = ships.filter(s => s.team === 'blue' && s.health > 0).length;
            
            if (redAlive === 0 && blueAlive > 0) {
                gameOver = true;
                winner = 'BLUE';
                if (playerShip && playerShip.health > 0) {
                    updateQuestProgress('survived', 1);
                    // Award 100 coins for winning
                    money += 100;
                    totalMoneyEarned += 100;
                    saveStats();
                    document.getElementById('money').textContent = money.toLocaleString();
                }
                showVictoryScreen('BLUE TEAM WINS!', '#5599ff');
            } else if (blueAlive === 0 && redAlive > 0) {
                gameOver = true;
                winner = 'RED';
                showVictoryScreen('RED TEAM WINS!', '#ff5555');
            }
        }
        
        function showVictoryScreen(message, color) {
            const overlay = document.createElement('div');
            overlay.id = 'victoryOverlay';
            overlay.style.cssText = `
                position: fixed;
                top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 1000;
            `;
            overlay.innerHTML = `
                <h1 style="color: ${color}; font-size: 4em; text-shadow: 0 0 30px ${color}; margin-bottom: 20px;">${message}</h1>
                <p style="color: #fff; font-size: 1.5em; margin-bottom: 30px;">Final Score - RED: ${redScore} | BLUE: ${blueScore}</p>
                <div style="display: flex; gap: 20px;">
                    <button onclick="restartGame()" style="
                        background: linear-gradient(180deg, #00d4ff, #0088aa);
                        border: none;
                        padding: 15px 40px;
                        font-size: 1.3em;
                        color: #fff;
                        border-radius: 25px;
                        cursor: pointer;
                    ">üîÑ PLAY AGAIN</button>
                    <button onclick="goToHomeScreen()" style="
                        background: linear-gradient(180deg, #ff9900, #cc6600);
                        border: none;
                        padding: 15px 40px;
                        font-size: 1.3em;
                        color: #fff;
                        border-radius: 25px;
                        cursor: pointer;
                    ">üè† HOME</button>
                </div>
            `;
            document.body.appendChild(overlay);
        }
        
        function restartGame() {
            const overlay = document.getElementById('victoryOverlay');
            if (overlay) overlay.remove();
            gameOver = false;
            winner = null;
            resetGame();
        }
        
        function goToHomeScreen() {
            const overlay = document.getElementById('victoryOverlay');
            if (overlay) overlay.remove();
            gameOver = false;
            winner = null;
            gameStarted = false;
            paused = true;
            
            // Clean up current game
            for (const ship of ships) {
                scene.remove(ship.mesh);
                scene.remove(ship.wake);
                for (const p of ship.smokeParticles) scene.remove(p);
            }
            for (const bullet of bullets) bullet.remove();
            for (const exp of explosions) exp.remove();
            ships = [];
            bullets = [];
            explosions = [];
            redScore = 0;
            blueScore = 0;
            document.getElementById('redScore').textContent = '0';
            document.getElementById('blueScore').textContent = '0';
            
            // Show home screen
            document.getElementById('homeScreen').style.display = 'flex';
            document.getElementById('money').textContent = money.toLocaleString();
            initQuests();
        }

        function gameLoop() {
            requestAnimationFrame(gameLoop);
            const delta = Math.min(clock.getDelta(), 0.1);

            if (!paused) {
                // Update water
                water.material.uniforms.time.value += delta;
                
                // Update sky clouds
                if (sky && sky.material.uniforms.time) {
                    sky.material.uniforms.time.value += delta;
                }
                
                // Update god rays
                if (godRaysMesh && godRaysMesh.material.uniforms.time) {
                    godRaysMesh.material.uniforms.time.value += delta;
                }
                
                // Update sea spray particles
                updateSeaSpray(delta);
                
                // Update lens flare
                updateLensFlare();
                
                // Update island animations (seagulls, waves, butterflies, seaweed)
                updateIslandAnimations(delta, clock.getElapsedTime());

                // Update ships
                for (const ship of ships) {
                    if (ship.health > 0) {
                        ship.update(delta);
                    }
                }

                // Update bullets
                for (const bullet of bullets) {
                    bullet.update(delta);
                }

                // Update explosions
                for (const exp of explosions) {
                    exp.update(delta);
                }

                checkCollisions();

                // Clean up bullets
                const aliveBullets = [];
                for (const b of bullets) {
                    if (b.isOffScreen() || b.hit) {
                        b.remove();
                    } else {
                        aliveBullets.push(b);
                    }
                }
                bullets = aliveBullets;

                // Clean up ships
                ships = ships.filter(s => s.health > 0);

                // Clean up explosions
                const aliveExplosions = [];
                for (const e of explosions) {
                    if (e.isDone()) {
                        e.remove();
                    } else {
                        aliveExplosions.push(e);
                    }
                }
                explosions = aliveExplosions;

                checkGameOver();

                // Camera follows player from behind
                if (playerShip && playerShip.health > 0) {
                    const camDistance = 140;
                    const camHeight = 70;
                    const targetCamX = playerShip.x - Math.cos(playerShip.rotation) * camDistance;
                    const targetCamZ = playerShip.z + Math.sin(playerShip.rotation) * camDistance;
                    
                    camera.position.x += (targetCamX - camera.position.x) * 0.08;
                    camera.position.z += (targetCamZ - camera.position.z) * 0.08;
                    camera.position.y = camHeight;
                    
                    // Apply recoil camera shake
                    if (playerShip.recoilOffset > 0) {
                        camera.position.x += (Math.random() - 0.5) * playerShip.recoilOffset;
                        camera.position.y += (Math.random() - 0.5) * playerShip.recoilOffset * 0.5;
                        camera.position.z += (Math.random() - 0.5) * playerShip.recoilOffset;
                        playerShip.recoilOffset *= 0.85;
                        if (playerShip.recoilOffset < 0.1) playerShip.recoilOffset = 0;
                    }
                    
                    // Apply explosion screen shake
                    if (screenShakeIntensity > 0.1) {
                        camera.position.x += (Math.random() - 0.5) * screenShakeIntensity;
                        camera.position.y += (Math.random() - 0.5) * screenShakeIntensity * 0.7;
                        camera.position.z += (Math.random() - 0.5) * screenShakeIntensity;
                        camera.rotation.z = (Math.random() - 0.5) * screenShakeIntensity * 0.01;
                        screenShakeIntensity *= screenShakeDecay;
                    } else {
                        camera.rotation.z = 0;
                    }
                    
                    camera.lookAt(playerShip.x, 10, playerShip.z);
                }
            }

            renderer.render(scene, camera);
        }

        function resetGame() {
            for (const ship of ships) {
                scene.remove(ship.mesh);
                scene.remove(ship.wake);
                for (const p of ship.smokeParticles) scene.remove(p);
            }
            for (const bullet of bullets) bullet.remove();
            for (const exp of explosions) exp.remove();

            ships = [];
            bullets = [];
            explosions = [];
            redScore = 0;
            blueScore = 0;
            document.getElementById('redScore').textContent = '0';
            document.getElementById('blueScore').textContent = '0';
            spawnShips();
        }

        function togglePause() {
            paused = !paused;
        }
        
        function setDifficulty(level) {
            difficulty = level;
            // Update button styles
            document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
            const diffNames = ['', 'easy', 'medium', 'hard', 'extreme', 'nightmare'];
            document.querySelector(`.diff-btn.${diffNames[level]}`).classList.add('selected');
        }
        
        let gameStarted = false;
        
        function startGame() {
            document.getElementById('homeScreen').style.display = 'none';
            if (!gameStarted) {
                gameStarted = true;
                initQuests();
                updateQuestProgress('gamesPlayed', 1);
                spawnShips();
            }
            paused = false;
            startBackgroundMusic();
        }
        
        function showControls() {
            alert('CONTROLS:\\n\\nW / ‚Üë - Increase throttle\\nS / ‚Üì - Reverse throttle\\nA / ‚Üê - Turn left\\nD / ‚Üí - Turn right\\nSPACE - Fire main guns\\n\\nYour ship has GREEN navigation lights!');
        }

        init();
        gameLoop();
    </script>
</body>
</html>
